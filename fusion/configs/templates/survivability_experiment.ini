# ============================================================================
# FUSION Survivability Experiment Configuration
# For offline RL + protection + failure testing
# ============================================================================

[general_settings]
# Load range for experiments
erlang_start = 100
erlang_stop = 300
erlang_step = 100

# Simulation parameters
max_iters = 5
num_requests = 2000
holding_time = 3.0
thread_num = s1

# Request bandwidth distribution (in Gbps)
request_distribution = {"25": 0.10, "50": 0.10, "100": 0.50, "200": 0.20, "400": 0.10}

# Modulation format settings
mod_assumption = DEFAULT
mod_assumption_path = data/json_input/example_mods/default_mod_formats.json

# Required simulation control parameters
thread_erlangs = False
dynamic_lps = False
fixed_grid = False
pre_calc_mod_selection = False
max_segments = 4

# Routing and spectrum assignment (also defined in sections below)
route_method = k_shortest_path
allocation_method = first_fit
k_paths = 4
guard_slots = 1

# Output and monitoring
save_snapshots = False
snapshot_step = 10
print_step = 15
save_step = 10
save_start_end_slots = False
spectrum_priority = None

# Logging control
verbose_logging = False
log_level = WARNING

# ============================================================================
# SEEDING STRATEGY: Separate request generation from RL components
# ============================================================================
# For reproducibility, FUSION supports separate seeding for:
# 1. Request generation (traffic patterns) - typically varies per iteration
# 2. RL/ML components (PyTorch, random) - typically constant for training
#
# Configuration options:
# - seed: General seed (used as constant RL seed if rl_seed not specified)
# - request_seeds: List of seeds for request gen (one per iteration)
# - rl_seed: Fixed seed for RL components (constant across iterations)
#
# Examples:
# A) Simple (all RNGs use same seed, varies per iteration):
#    seed = 42
#
# B) RL Training (constant RL seed, varying traffic):
#    seed = 42           # Constant RL behavior
#    request_seeds = []  # Traffic varies per iteration (iteration+1)
#
# C) Full Control (specify both explicitly):
#    request_seeds = [1, 2, 3, 4, 5]  # Traffic patterns per iteration
#    rl_seed = 42                      # Constant RL seed
# ============================================================================

# Random seed (set to specific value for reproducibility)
seed = 42

# Optional: Separate seeds for request generation (varies per iteration)
# request_seeds = []

# Optional: Fixed seed for RL components (constant across iterations)
# rl_seed = 42

[topology_settings]
# Network topology
network = NSFNet
cores_per_link = 7
bw_per_slot = 12.5
const_link_weight = False
is_only_core_node = True
multi_fiber = False

[spectrum_settings]
# C-band spectrum allocation
c_band = 320
guard_slots = 1
allocation_method = first_fit

[file_settings]
# Output format configuration
file_type = json

[ml_settings]
# Machine learning configuration
deploy_model = False

[rl_settings]
# Reinforcement learning configuration (not used in survivability mode)
# These settings are for the legacy RL training mode
obs_space = obs_3
n_trials = 1
device = cpu
optimize_hyperparameters = False
optuna_trials = 1
is_training = False
path_algorithm = dqn
path_model = None
core_algorithm = first_fit
core_model = None
spectrum_algorithm = first_fit
spectrum_model = None
render_mode = None
super_channel_space = 3
alpha_start = 0.000215
alpha_end = 0.000215
alpha_update = linear_decay
gamma = 0.1
epsilon_start = 0.01
epsilon_end = 0.01
epsilon_update = exp_decay
path_levels = 2
decay_rate = 0.4
feature_extractor = path_gnn
gnn_type = graph_conv
layers = 2
emb_dim = 64
heads = 4
conf_param = 2
cong_cutoff = 0.9
reward = 1
penalty = -10
dynamic_reward = False
core_beta = 0.1

[routing_settings]
# K-path candidate generation
route_method = k_shortest_path
k_paths = 4
path_ordering = hops
precompute_paths = true

[failure_settings]
# Failure type: none, link, node, srlg, geo
failure_type = none

# Failure timing (specified in request arrival indices, NOT simulation time)
# The system converts arrival indices to simulation time internally based on the arrival process.
#
# t_fail_arrival_index: Which request arrival the failure occurs at
#   -1 = uniform_mid (midpoint of simulation: num_requests // 2)
#   Otherwise: specific arrival index (e.g., 500 = fail at the 500th request)
#
# t_repair_after_arrivals: Number of arrivals AFTER the failure until repair
#   Example: If failure at arrival 500 and repair_after = 1000, repair at arrival 1500
t_fail_arrival_index = -1
t_repair_after_arrivals = 1000

# Link failure (F1) parameters
failed_link_src = 0
failed_link_dst = 1

# Node failure (F2) parameters (not in v1, but structure prepared)
failed_node_id = 0

# SRLG failure (F3) parameters
# List of link tuples: [(0,1), (2,3)]
srlg_links = []

# Geographic failure (F4) parameters
geo_center_node = 5
geo_hop_radius = 2

[protection_settings]
# Protection mode: none, 1plus1
protection_mode = none

# 1+1 protection timing (milliseconds)
protection_switchover_ms = 50.0
restoration_latency_ms = 100.0

# Whether to revert to primary after repair
revert_to_primary = false

[offline_rl_settings]
# Policy selection: ksp_ff, one_plus_one, bc, iql
policy_type = ksp_ff

# Model paths (required if using bc or iql)
bc_model_path = models/bc_model.pt
iql_model_path = models/iql_model.pt

# Compute device: cpu, cuda, mps
device = cpu

# Fallback policy when all actions masked
fallback_policy = ksp_ff

[dataset_logging]
# Enable offline dataset logging for training
log_offline_dataset = false
dataset_output_path = data/datasets/offline_data.jsonl

# Epsilon-mix probability (0.0 = no exploration)
epsilon_mix = 0.1

[recovery_timing]
# Recovery time modeling parameters (milliseconds)
protection_switchover_ms = 50.0
restoration_latency_ms = 100.0

# Failure window size (number of arrivals after failure)
failure_window_size = 1000

[reporting]
# CSV export settings
export_csv = true
csv_output_path = results/survivability_results.csv

# Multi-seed aggregation
aggregate_seeds = true
seed_list = [42, 43, 44, 45, 46]

[snr_settings]
# SNR/QoT settings (not used in v1)
snr_type = None
input_power = 0.001
egn_model = False
beta = 0.5
theta = 0.0
xt_type = without_length
xt_noise = False
requested_xt = {"QPSK": -26.19, "16-QAM": -36.69, "64-QAM": -41.69}
phi = {"QPSK": 1, "16-QAM": 0.68, "64-QAM": 0.6190476190476191}
