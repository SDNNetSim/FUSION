# P4.1 Shared Context - Legacy RL Data Paths

**Purpose:** Summarize how the legacy RL implementation obtains paths, checks feasibility, and applies actions. This context is shared across P4.1 micro-tasks.

## Source Files (for reference)

- `fusion/modules/rl/gymnasium_envs/general_sim_env.py` - SimEnv class
- `fusion/modules/rl/utils/general_utils.py` - CoreUtilHelpers with mock_handle_arrival
- `fusion/modules/rl/utils/sim_env.py` - SimEnvUtils, SimEnvObs helpers
- `fusion/modules/rl/agents/path_agent.py` - PathAgent for path selection
- `fusion/core/routing.py` - Routing dispatcher

---

## 1. Path Generation Flow (Legacy)

### Entry Point: SimEnv.reset() / SimEnv.step()

When generating observations, legacy RL:

1. **Gets current request** from `rl_props.arrival_list[arrival_count]`
2. **Updates mock SDN state** via `CoreUtilHelpers.update_mock_sdn(current_request)`
3. **Calls routing** via `route_obj.get_route()` which populates `route_props.paths_matrix`
4. **For each candidate path**, computes:
   - Congestion via `find_path_congestion(path, network_spectrum)`
   - Available slots ratio
   - Path length (hops and km)

### Key Data Structures

```python
# paths_matrix: list of k candidate paths
paths_matrix = [
    [0, 2, 5, 3],  # Path 0: node sequence
    [0, 1, 3],     # Path 1
    [0, 4, 2, 3],  # Path 2
]

# Each path has associated metadata
path_features = {
    "weight_km": 450.5,        # Total path length in km
    "num_hops": 3,             # Number of links
    "mod_format": "QPSK",      # Selected modulation
    "slots_needed": 4,         # Required spectrum slots
    "congestion": 0.35,        # Congestion metric [0, 1]
    "available_slots": 0.65,   # Available spectrum ratio
}
```

---

## 2. Feasibility Check Flow (Legacy)

### mock_handle_arrival() in CoreUtilHelpers

Location: `fusion/modules/rl/utils/general_utils.py`

```python
@staticmethod
def mock_handle_arrival(
    engine_props: dict,
    sdn_props: dict,
    path_list: list,
    mod_format_list: list
) -> bool:
    # 1. Create temporary RoutingProps and SDNProps objects
    route_props = RoutingProps()
    sdn_props_obj = SDNProps()

    # 2. Copy dict to SDNProps object
    for key, value in sdn_props.items():
        setattr(sdn_props_obj, key, value)

    # 3. Create SpectrumAssignment simulator
    spectrum_obj = SpectrumAssignment(
        engine_props=engine_props,
        sdn_props=sdn_props_obj,
        route_props=route_props
    )

    # 4. Check spectrum availability (NO ACTUAL ALLOCATION)
    spectrum_obj.spectrum_props.path_list = path_list
    spectrum_obj.get_spectrum(mod_format_list=mod_format_list)

    # 5. Return feasibility
    return spectrum_obj.spectrum_props.is_free is True
```

### What mock_handle_arrival DUPLICATES

- SpectrumAssignment algorithm instantiation
- Modulation format validation
- Contiguous slot checking
- Guard band application

### What mock_handle_arrival does NOT do

- Update `network_spectrum_dict` (no actual allocation)
- Record statistics
- Trigger lightpath creation
- Handle request lifecycle

---

## 3. Action Application Flow (Legacy)

### SimEnv.step(action) Flow

```python
def step(self, action: int):
    # 1. Get chosen path from k candidates
    chosen_path = paths_matrix[action]
    rl_props.chosen_path_list = chosen_path

    # 2. Update route properties
    rl_help_obj.update_route_props(
        chosen_path=chosen_path,
        bandwidth=str(bandwidth)
    )

    # 3. Call actual allocation via engine
    rl_help_obj.allocate()  # Calls engine_obj.handle_arrival()

    # 4. Check allocation result
    if was_allocated:
        reward = engine_props["reward"]  # +1.0
    else:
        reward = engine_props["penalty"]  # -1.0

    return obs, reward, terminated, truncated, info
```

### allocate() Implementation

```python
def allocate(self):
    # Calls the actual simulation engine
    self.engine_obj.handle_arrival(
        current_request=self.current_request,
        route_props=self.route_props  # Contains chosen_path
    )
```

---

## 4. Observation Building (Legacy)

### SimEnvObs.get_drl_obs() Output

```python
observation = {
    # Request features (one-hot encoded)
    "source": np.array([1, 0, 0, ...]),      # One-hot source node
    "destination": np.array([0, 0, 1, ...]), # One-hot destination
    "request_bandwidth": np.array([0, 1, 0]),# One-hot bandwidth class
    "holding_time": 0.75,                     # Normalized [0, 1]

    # Path features (arrays of length k_paths)
    "slots_needed": [4, 5, 3],     # -1 if invalid modulation
    "path_lengths": [3.2, 4.1, 5.0],
    "paths_cong": [0.2, 0.8, 0.5],
    "available_slots": [0.6, 0.3, 0.7],
}
```

---

## 5. Key Differences from V4 Orchestrator

| Aspect | Legacy RL | V4 Orchestrator |
|--------|-----------|-----------------|
| Routing | `route_obj.get_route()` | `routing_pipeline.find_routes()` |
| Spectrum check | `mock_handle_arrival()` | `spectrum_pipeline.find_spectrum()` |
| Allocation | `engine_obj.handle_arrival()` | `orchestrator.handle_arrival()` |
| State container | `engine_props` dict | `NetworkState` object |
| Path forcing | Via `route_props.chosen_path_list` | Via `forced_path` parameter |

---

## 6. What RLSimulationAdapter Must Replace

1. **mock_handle_arrival()** -> Call real `spectrum_pipeline.find_spectrum()` without allocation
2. **Direct engine_props access** -> Query through `NetworkState` methods
3. **Manual path selection** -> Use `forced_path` parameter in orchestrator
4. **Separate routing call** -> Use same `routing_pipeline` instance as orchestrator

---

## 7. Integration Points for Adapter

### Required Pipeline Access

```python
# Adapter needs access to these (same instances as orchestrator)
routing_pipeline: RoutingPipeline      # find_routes(request, network_state)
spectrum_pipeline: SpectrumPipeline    # find_spectrum(path, request, network_state)
```

### Required Orchestrator Hooks

```python
# Orchestrator must support forced_path parameter
orchestrator.handle_arrival(
    request: Request,
    network_state: NetworkState,
    forced_path: list[str] | None = None  # If set, skip routing, use this path
) -> AllocationResult
```

### Required NetworkState Queries

```python
# Read-only queries for observation building
network_state.get_spectrum_availability(link)
network_state.get_lightpaths_on_link(link)
network_state.compute_link_utilization(link)
```
