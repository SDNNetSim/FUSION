# Task ID: P4.1.b - Design PathOption Dataclass

**Sub-phase:** P4.1
**Scope:** Phase 4 - RL Integration only
**Task type:** design

## Purpose

Design the `PathOption` dataclass that represents a candidate path with its metadata. This dataclass is returned by `RLSimulationAdapter.get_path_options()` and used for:
- Action masking (via `is_feasible` field)
- Observation building (path features)
- Action application (path selection)

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.shared_context_legacy_rl_paths.md`
- `.claude/v4-docs/architecture/rl_integration.md` (PathOption section)
- `fusion/core/properties.py` (RoutingProps, SpectrumProps for reference)
- `.claude/v5-final-docs/phase-1-core-domain/` (any result type definitions)

## Outputs

### 1. PathOption Dataclass Definition

Create `fusion/rl/adapter.py` with the following dataclass:

```python
from dataclasses import dataclass
from typing import Any

@dataclass(frozen=True)
class PathOption:
    """Represents a candidate path for RL action selection.

    This dataclass encapsulates all information about a candidate path
    that an RL agent needs to make a routing decision. The is_feasible
    field is computed from REAL spectrum pipeline checks, not mocked.

    Attributes:
        path_index: Index in the k-paths list (0 to k-1)
        path: Sequence of node IDs representing the path
        weight_km: Total path length in kilometers
        num_hops: Number of links in the path
        modulation: Selected modulation format (e.g., "QPSK", "16-QAM")
        slots_needed: Number of contiguous spectrum slots required
        is_feasible: True if path can be allocated (from real spectrum check)
        congestion: Congestion metric in [0, 1], higher = more congested
        available_slots: Ratio of available slots on most constrained link
        spectrum_start: Start slot if feasible, None otherwise
        spectrum_end: End slot if feasible, None otherwise
        core_index: Core index if multi-core, None for single-core
        band: Spectrum band (e.g., "C", "L") if multi-band, None otherwise
    """
    path_index: int
    path: tuple[str, ...]  # Immutable for hashability
    weight_km: float
    num_hops: int
    modulation: str | None
    slots_needed: int
    is_feasible: bool
    congestion: float
    available_slots: float
    spectrum_start: int | None = None
    spectrum_end: int | None = None
    core_index: int | None = None
    band: str | None = None

    def __post_init__(self) -> None:
        """Validate invariants."""
        if self.path_index < 0:
            raise ValueError("path_index must be non-negative")
        if self.weight_km < 0:
            raise ValueError("weight_km must be non-negative")
        if self.congestion < 0 or self.congestion > 1:
            raise ValueError("congestion must be in [0, 1]")
        if self.available_slots < 0 or self.available_slots > 1:
            raise ValueError("available_slots must be in [0, 1]")
```

### 2. Design Rationale

Document these design decisions:

| Decision | Rationale |
|----------|-----------|
| `frozen=True` | Immutable to prevent accidental modification; hashable for caching |
| `path: tuple` | Immutable sequence; allows use as dict key if needed |
| `is_feasible` from real check | Core requirement - no mocked feasibility |
| Optional spectrum fields | Only populated when feasible; saves computation |
| `congestion` normalized | Consistent scale for observation building |
| Separate `slots_needed` | Allows observation without spectrum result |

### 3. Factory Method for Creation

Add a factory method that creates PathOption from pipeline results:

```python
@classmethod
def from_pipeline_results(
    cls,
    path_index: int,
    route_result: RouteResult,  # From routing pipeline
    spectrum_result: SpectrumResult | None,  # From spectrum pipeline
    congestion: float,
    available_slots: float,
) -> "PathOption":
    """Create PathOption from V4 pipeline results.

    Args:
        path_index: Index in k-paths list
        route_result: Result from routing pipeline for this path
        spectrum_result: Result from spectrum pipeline, or None if not checked
        congestion: Pre-computed congestion metric
        available_slots: Pre-computed available slots ratio

    Returns:
        PathOption instance
    """
    return cls(
        path_index=path_index,
        path=tuple(route_result.path),
        weight_km=route_result.weight_km,
        num_hops=len(route_result.path) - 1,
        modulation=route_result.modulation,
        slots_needed=route_result.slots_needed,
        is_feasible=spectrum_result.is_free if spectrum_result else False,
        congestion=congestion,
        available_slots=available_slots,
        spectrum_start=spectrum_result.start_slot if spectrum_result and spectrum_result.is_free else None,
        spectrum_end=spectrum_result.end_slot if spectrum_result and spectrum_result.is_free else None,
        core_index=spectrum_result.core_index if spectrum_result else None,
        band=spectrum_result.band if spectrum_result else None,
    )
```

### 4. Action Masking Helper

Add a utility function for action mask generation:

```python
def compute_action_mask(options: list[PathOption], k_paths: int) -> np.ndarray:
    """Generate action mask from path options.

    Args:
        options: List of PathOption instances
        k_paths: Total number of possible actions (action space size)

    Returns:
        Boolean array where True = action is valid (feasible path)
    """
    mask = np.zeros(k_paths, dtype=bool)
    for opt in options:
        if opt.path_index < k_paths:
            mask[opt.path_index] = opt.is_feasible
    return mask
```

### 5. Type Aliases

Define type aliases for clarity:

```python
from typing import TypeAlias

PathOptionList: TypeAlias = list[PathOption]
ActionMask: TypeAlias = np.ndarray  # Shape: (k_paths,), dtype: bool
```

## Verification

- [ ] `PathOption` dataclass is frozen and immutable
- [ ] All fields have appropriate types and defaults
- [ ] Factory method correctly maps pipeline results
- [ ] `is_feasible` comes from spectrum pipeline, not heuristics
- [ ] Action mask generation is correct
- [ ] Unit tests cover creation, validation, and edge cases

## Test Cases to Implement

```python
def test_pathoption_immutable():
    """PathOption should be frozen."""
    opt = PathOption(...)
    with pytest.raises(FrozenInstanceError):
        opt.is_feasible = True

def test_pathoption_validation():
    """PathOption should validate invariants."""
    with pytest.raises(ValueError):
        PathOption(path_index=-1, ...)  # Negative index
    with pytest.raises(ValueError):
        PathOption(congestion=1.5, ...)  # Out of range

def test_action_mask_generation():
    """Action mask should match feasibility."""
    options = [
        PathOption(path_index=0, is_feasible=True, ...),
        PathOption(path_index=1, is_feasible=False, ...),
        PathOption(path_index=2, is_feasible=True, ...),
    ]
    mask = compute_action_mask(options, k_paths=3)
    assert mask.tolist() == [True, False, True]
```

## Next Task

Proceed to **P4.1.c** to design the full `RLSimulationAdapter` API.
