# Task ID: P4.1.f - Offline RL Policy Compatibility

**Sub-phase:** P4.1
**Scope:** Phase 4 - RL Integration only
**Task type:** design
**Priority:** High (blocks BC/IQL policy migration)

## Purpose

Define how `RLSimulationAdapter` and `PathOption` integrate with offline RL policies (BC, IQL) that expect a specific state format different from the Gymnasium observation space.

## Context

Legacy offline RL policies (BCPolicy, IQLPolicy) use a flattened tensor state format:
```python
# From fusion/modules/rl/policies/bc_policy.py
features = [
    state["src"],
    state["dst"],
    state["slots_needed"],
    state["est_remaining_time"],
    state["is_disaster"],
    # Per-path features
    path_features["path_hops"],
    path_features["min_residual_slots"],
    path_features["frag_indicator"],
    path_features["failure_mask"],
    path_features["dist_to_disaster_centroid"],
]
```

This differs from the Gymnasium Dict observation space used by online RL.

## Outputs

### 1. Offline State Builder

Add to `RLSimulationAdapter`:

```python
class RLSimulationAdapter:
    """Extended adapter with offline RL support."""

    def build_offline_state(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
        disaster_state: DisasterState | None = None,
    ) -> dict[str, Any]:
        """Build state dict for offline RL policies.

        This method creates the flattened state dictionary expected by
        BC and IQL policies trained on heuristic behavior logs.

        Args:
            request: Current request
            options: Available path options
            network_state: Current network state
            disaster_state: Optional disaster information

        Returns:
            State dict compatible with BCPolicy/IQLPolicy
        """
        state = {
            "src": request.source,
            "dst": request.destination,
            "slots_needed": self._get_min_slots_needed(options),
            "est_remaining_time": self._normalize_holding_time(
                request.holding_time
            ),
            "is_disaster": 1.0 if disaster_state and disaster_state.active else 0.0,
            "paths": [],
        }

        for opt in options:
            path_features = {
                "path_hops": opt.num_hops,
                "min_residual_slots": self._compute_min_residual(
                    opt.path, network_state
                ),
                "frag_indicator": self._compute_fragmentation(
                    opt.path, network_state
                ),
                "failure_mask": self._compute_failure_mask(
                    opt.path, disaster_state
                ),
                "dist_to_disaster_centroid": self._compute_disaster_distance(
                    opt.path, disaster_state
                ),
            }
            state["paths"].append(path_features)

        # Pad to k_paths if needed
        while len(state["paths"]) < self._config.k_paths:
            state["paths"].append(self._dummy_path_features())

        return state

    def _get_min_slots_needed(self, options: list[PathOption]) -> float:
        """Get minimum slots needed across all feasible paths."""
        feasible = [o for o in options if o.is_feasible]
        if not feasible:
            return -1.0
        return min(o.slots_needed for o in feasible)

    def _compute_min_residual(
        self, path: tuple[str, ...], network_state: NetworkState
    ) -> float:
        """Compute minimum residual slots along path.

        Returns normalized value in [0, 1].
        """
        if len(path) < 2:
            return 0.0

        min_available = float("inf")
        for i in range(len(path) - 1):
            available = network_state.get_available_slots(path[i], path[i+1])
            min_available = min(min_available, available)

        return min_available / network_state.total_slots

    def _compute_fragmentation(
        self, path: tuple[str, ...], network_state: NetworkState
    ) -> float:
        """Compute path fragmentation indicator.

        Returns normalized value in [0, 1] where 0 = no fragmentation.
        """
        if not hasattr(network_state, 'fragmentation_tracker'):
            return 0.0

        # Use existing FragmentationTracker if available
        tracker = network_state.fragmentation_tracker
        path_int = [int(n) for n in path]
        frag_dict = tracker.get_fragmentation(path_int, core_index=0)
        return float(frag_dict.get("path_frag", [0.0])[0])

    def _compute_failure_mask(
        self, path: tuple[str, ...], disaster_state: DisasterState | None
    ) -> float:
        """Compute whether path passes through failed links.

        Returns 1.0 if any link is failed, 0.0 otherwise.
        """
        if disaster_state is None or not disaster_state.active:
            return 0.0

        failed_links = disaster_state.failed_links
        for i in range(len(path) - 1):
            link = (path[i], path[i+1])
            if link in failed_links or (link[1], link[0]) in failed_links:
                return 1.0
        return 0.0

    def _compute_disaster_distance(
        self, path: tuple[str, ...], disaster_state: DisasterState | None
    ) -> float:
        """Compute normalized distance from path centroid to disaster.

        Returns value in [0, 1] where 0 = at disaster, 1 = max distance.
        """
        if disaster_state is None or not disaster_state.active:
            return 1.0  # No disaster = max safety

        if disaster_state.centroid is None:
            return 1.0

        # Compute path centroid
        path_centroid = self._compute_path_centroid(path)

        # Compute distance to disaster centroid
        dx = path_centroid[0] - disaster_state.centroid[0]
        dy = path_centroid[1] - disaster_state.centroid[1]
        distance = (dx**2 + dy**2) ** 0.5

        # Normalize by network diameter
        max_distance = disaster_state.network_diameter
        return min(distance / max_distance, 1.0)

    def _compute_path_centroid(
        self, path: tuple[str, ...]
    ) -> tuple[float, float]:
        """Compute geographic centroid of path nodes."""
        coords = [self._get_node_coords(n) for n in path]
        x = sum(c[0] for c in coords) / len(coords)
        y = sum(c[1] for c in coords) / len(coords)
        return (x, y)

    def _dummy_path_features(self) -> dict[str, float]:
        """Return dummy features for padding."""
        return {
            "path_hops": 0,
            "min_residual_slots": 0.0,
            "frag_indicator": 0.0,
            "failure_mask": 1.0,  # Masked = infeasible
            "dist_to_disaster_centroid": 0.0,
        }
```

### 2. DisasterState Data Class

```python
from dataclasses import dataclass


@dataclass(frozen=True)
class DisasterState:
    """Immutable disaster state information.

    Attributes:
        active: Whether a disaster is currently active
        centroid: Geographic centroid (x, y) of disaster
        radius: Affected radius from centroid
        failed_links: Set of failed link tuples
        network_diameter: Max distance across network (for normalization)
    """
    active: bool
    centroid: tuple[float, float] | None = None
    radius: float = 0.0
    failed_links: frozenset[tuple[str, str]] = frozenset()
    network_diameter: float = 1.0


def create_disaster_state_from_engine(
    engine_props: dict,
) -> DisasterState | None:
    """Create DisasterState from legacy engine_props.

    Args:
        engine_props: Legacy engine properties dict

    Returns:
        DisasterState if disaster active, None otherwise
    """
    if not engine_props.get("is_disaster", False):
        return None

    return DisasterState(
        active=True,
        centroid=engine_props.get("disaster_centroid"),
        radius=engine_props.get("disaster_radius", 0.0),
        failed_links=frozenset(
            tuple(link) for link in engine_props.get("failed_links", [])
        ),
        network_diameter=engine_props.get("network_diameter", 1.0),
    )
```

### 3. Offline Policy Adapter

```python
class OfflinePolicyAdapter:
    """Adapter to use offline RL policies with UnifiedSimEnv.

    This adapter bridges the gap between the Gymnasium observation space
    used by online RL and the flattened state format expected by offline
    RL policies (BC, IQL).

    Example:
        adapter = OfflinePolicyAdapter(bc_policy, rl_adapter)
        action = adapter.select_action(obs, info)
    """

    def __init__(
        self,
        policy: "BCPolicy | IQLPolicy",
        rl_adapter: RLSimulationAdapter,
        config: "SimulationConfig",
    ) -> None:
        self._policy = policy
        self._rl_adapter = rl_adapter
        self._config = config

    def select_action(
        self,
        gym_obs: dict[str, np.ndarray],
        info: dict[str, Any],
        request: "Request",
        options: list[PathOption],
        network_state: "NetworkState",
        disaster_state: DisasterState | None = None,
    ) -> int:
        """Select action using offline policy.

        Args:
            gym_obs: Gymnasium observation dict
            info: Info dict with action_mask
            request: Current request
            options: Path options
            network_state: Network state
            disaster_state: Optional disaster state

        Returns:
            Selected action index
        """
        # Build offline state format
        offline_state = self._rl_adapter.build_offline_state(
            request, options, network_state, disaster_state
        )

        # Get action mask
        action_mask = info.get("action_mask", [True] * self._config.k_paths)
        action_mask_list = list(action_mask)

        # Call offline policy
        return self._policy.select_path(offline_state, action_mask_list)
```

### 4. Usage Example

```python
from fusion.rl.environments import UnifiedSimEnv
from fusion.modules.rl.policies.bc_policy import BCPolicy
from fusion.rl.adapter import RLSimulationAdapter, OfflinePolicyAdapter

# Load offline policy
bc_policy = BCPolicy("models/bc_model.pt", device="cpu")

# Create unified environment
config = SimulationConfig.from_file("config.ini")
env = UnifiedSimEnv(config)

# Create offline adapter
offline_adapter = OfflinePolicyAdapter(
    policy=bc_policy,
    rl_adapter=env.adapter,
    config=config,
)

# Run evaluation
obs, info = env.reset(seed=42)
total_reward = 0

while True:
    # Get current state for offline policy
    request = env.current_request
    options = env.adapter._current_options  # Access cached options
    network_state = env.network_state
    disaster_state = env.disaster_state  # If available

    # Select action using offline policy
    action = offline_adapter.select_action(
        obs, info, request, options, network_state, disaster_state
    )

    obs, reward, terminated, truncated, info = env.step(action)
    total_reward += reward

    if terminated or truncated:
        break

print(f"Total reward: {total_reward}")
```

### 5. Feature Mapping Table

| Offline State Feature | Source | PathOption Equivalent |
|----------------------|--------|----------------------|
| `src` | `request.source` | N/A (request-level) |
| `dst` | `request.destination` | N/A (request-level) |
| `slots_needed` | min of options | `PathOption.slots_needed` |
| `est_remaining_time` | `request.holding_time` | N/A (request-level) |
| `is_disaster` | `disaster_state.active` | N/A (global state) |
| `path_hops` | path length | `PathOption.num_hops` |
| `min_residual_slots` | computed | via `available_slots` |
| `frag_indicator` | computed | NEW field needed |
| `failure_mask` | computed | NEW field needed |
| `dist_to_disaster_centroid` | computed | NEW field needed |

### 6. Extended PathOption

```python
@dataclass(frozen=True)
class PathOption:
    """Extended PathOption with disaster-aware features."""

    # Core fields (existing)
    path_index: int
    path: tuple[str, ...]
    weight_km: float
    num_hops: int
    modulation: str
    slots_needed: int
    is_feasible: bool
    congestion: float
    available_slots: float

    # Spectrum fields (existing)
    spectrum_start: int | None = None
    spectrum_end: int | None = None
    core_index: int | None = None
    band: str | None = None

    # Disaster-aware fields (NEW)
    frag_indicator: float = 0.0
    failure_mask: bool = False
    dist_to_disaster: float = 1.0
    min_residual_slots: float = 1.0
```

## Verification

- [ ] `build_offline_state()` produces valid state dict
- [ ] State format matches BC/IQL policy expectations
- [ ] DisasterState correctly extracted from engine_props
- [ ] OfflinePolicyAdapter successfully selects actions
- [ ] Feature values match legacy computation
- [ ] Padded paths have correct dummy values

## Next Task

After P4.1.f completion, proceed to **P4.1.g: Disaster-Aware Feature Support**.
