# Task ID: P4.1.d - Wiring Plan: Adapter to Pipelines

**Sub-phase:** P4.1
**Scope:** Phase 4 - RL Integration only
**Task type:** wiring-plan

## Purpose

Plan how `RLSimulationAdapter` connects to the V4 pipelines through the orchestrator, ensuring pipeline identity is preserved and no new algorithm logic is introduced.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.c_design_adapter_api.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.1_pipeline_factory/P3.1.index.md` (PipelineFactory design)
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.index.md` (orchestrator design)
- `fusion/core/sdn_controller.py` (current SDNController structure)

## Outputs

### 1. Wiring Diagram

```
                    ┌─────────────────────────────────────────┐
                    │           UnifiedSimEnv                 │
                    │  (owns SimulationEngine, NetworkState)  │
                    └───────────────┬─────────────────────────┘
                                    │
                                    │ uses
                                    ▼
                    ┌─────────────────────────────────────────┐
                    │        RLSimulationAdapter              │
                    │  - get_path_options()                   │
                    │  - apply_action()                       │
                    │  - compute_reward()                     │
                    └───────────────┬─────────────────────────┘
                                    │
                         ┌──────────┴──────────┐
                         │                     │
              references │                     │ calls
                         ▼                     ▼
          ┌──────────────────────┐  ┌─────────────────────────┐
          │   SDNOrchestrator    │  │     Pipeline Access     │
          │  (owns pipelines)    │  │  (same instances)       │
          └──────────┬───────────┘  └─────────────────────────┘
                     │
        ┌────────────┼────────────┬────────────┐
        │            │            │            │
        ▼            ▼            ▼            ▼
   ┌─────────┐ ┌──────────┐ ┌─────────┐ ┌─────────┐
   │ Routing │ │ Spectrum │ │Grooming │ │   SNR   │
   │Pipeline │ │ Pipeline │ │Pipeline │ │Pipeline │
   └─────────┘ └──────────┘ └─────────┘ └─────────┘
```

### 2. Initialization Sequence

```python
# 1. PipelineFactory creates pipelines
pipeline_set = PipelineFactory.create_all(config)

# 2. SDNOrchestrator is created with pipelines
orchestrator = SDNOrchestrator(
    pipelines=pipeline_set,
    config=config,
)

# 3. RLSimulationAdapter is created with orchestrator reference
adapter = RLSimulationAdapter(
    orchestrator=orchestrator,
    config=config,
)

# 4. Verify identity (test assertion)
assert adapter.routing_pipeline is orchestrator.routing_pipeline
assert adapter.spectrum_pipeline is orchestrator.spectrum_pipeline
```

### 3. Required Orchestrator Modifications

The orchestrator must expose these for adapter access:

```python
class SDNOrchestrator:
    """Modified orchestrator with pipeline exposure."""

    def __init__(self, pipelines: PipelineSet, config: SimulationConfig):
        self._routing = pipelines.routing
        self._spectrum = pipelines.spectrum
        self._grooming = pipelines.grooming
        self._snr = pipelines.snr
        self._slicing = pipelines.slicing
        self._config = config

    @property
    def routing_pipeline(self) -> RoutingPipeline:
        """Expose routing pipeline for adapter access."""
        return self._routing

    @property
    def spectrum_pipeline(self) -> SpectrumPipeline:
        """Expose spectrum pipeline for adapter access."""
        return self._spectrum

    def handle_arrival(
        self,
        request: Request,
        network_state: NetworkState,
        forced_path: list[str] | None = None,  # NEW PARAMETER
    ) -> AllocationResult:
        """Handle request arrival with optional forced path.

        If forced_path is provided (from RL agent), skip routing
        and use the specified path directly.
        """
        if forced_path is not None:
            # Skip routing, use forced path
            route_result = RouteResult(
                path=forced_path,
                # ... populate from config/lookup
            )
        else:
            # Normal routing
            route_results = self._routing.find_routes(request, network_state)
            route_result = route_results[0]  # Or iterate as before

        # Continue with spectrum assignment, SNR, etc.
        # ... existing orchestrator logic
```

### 4. Spectrum Pipeline: allocate=False Mode

The spectrum pipeline must support a read-only mode:

```python
class SpectrumPipeline(Protocol):
    def find_spectrum(
        self,
        path: list[str],
        request: Request,
        network_state: NetworkState,
        allocate: bool = True,  # NEW PARAMETER
    ) -> SpectrumResult:
        """Find available spectrum on path.

        Args:
            allocate: If True, mark spectrum as used. If False, just check.
        """
```

Implementation in adapter wrapper (if needed):

```python
class SpectrumAdapter:
    """Adapter around legacy spectrum assignment."""

    def find_spectrum(
        self,
        path: list[str],
        request: Request,
        network_state: NetworkState,
        allocate: bool = True,
    ) -> SpectrumResult:
        # Create temporary objects
        sdn_props = self._build_sdn_props(request, network_state)
        spectrum_obj = SpectrumAssignment(...)

        # Check availability
        spectrum_obj.get_spectrum(...)

        if allocate and spectrum_obj.spectrum_props.is_free:
            # Actually allocate in network_state
            network_state.allocate_spectrum(
                path=path,
                start=spectrum_obj.spectrum_props.start_slot,
                end=spectrum_obj.spectrum_props.end_slot,
            )

        return SpectrumResult(
            is_free=spectrum_obj.spectrum_props.is_free,
            start_slot=spectrum_obj.spectrum_props.start_slot,
            end_slot=spectrum_obj.spectrum_props.end_slot,
            core_index=spectrum_obj.spectrum_props.core_index,
        )
```

### 5. NetworkState Query Methods

Ensure NetworkState exposes these read-only methods for adapter:

```python
class NetworkState:
    """Required methods for adapter access."""

    def get_link_utilization(self, src: str, dst: str) -> float:
        """Return link utilization in [0, 1]."""

    def get_available_slots(self, src: str, dst: str) -> int:
        """Return number of available slots on link."""

    @property
    def total_slots(self) -> int:
        """Total slots per link."""

    @property
    def num_nodes(self) -> int:
        """Number of nodes in topology."""
```

### 6. No New Algorithm Logic

The adapter MUST NOT contain:

- Routing algorithms (uses routing_pipeline)
- Spectrum assignment logic (uses spectrum_pipeline)
- Modulation selection (from route_result)
- SNR calculation (from snr_pipeline via orchestrator)
- Grooming logic (from grooming_pipeline via orchestrator)

The adapter ONLY:

- Queries existing pipelines
- Transforms results to PathOption format
- Computes observation features from domain objects
- Delegates allocation to orchestrator

### 7. Wiring Verification Tests

```python
def test_adapter_uses_same_routing_pipeline(orchestrator, adapter):
    """Adapter must use same pipeline instance."""
    assert adapter.routing_pipeline is orchestrator.routing_pipeline

def test_adapter_uses_same_spectrum_pipeline(orchestrator, adapter):
    """Adapter must use same pipeline instance."""
    assert adapter.spectrum_pipeline is orchestrator.spectrum_pipeline

def test_get_path_options_is_readonly(adapter, request, network_state):
    """get_path_options must not modify network state."""
    # Snapshot state before
    before = network_state.snapshot()

    # Call method
    adapter.get_path_options(request, network_state)

    # State should be unchanged
    assert network_state.snapshot() == before

def test_apply_action_uses_orchestrator(adapter, orchestrator, request, network_state):
    """apply_action must route through orchestrator."""
    options = adapter.get_path_options(request, network_state)

    with patch.object(orchestrator, 'handle_arrival') as mock:
        mock.return_value = AllocationResult(success=True, ...)
        adapter.apply_action(0, request, network_state, options)

        # Verify orchestrator was called
        mock.assert_called_once()
        # Verify forced_path was passed
        assert mock.call_args.kwargs.get('forced_path') is not None
```

## Verification

- [ ] Adapter initialization gets pipelines from orchestrator
- [ ] Pipeline identity is preserved (same instances)
- [ ] Orchestrator exposes routing_pipeline and spectrum_pipeline properties
- [ ] Orchestrator supports forced_path parameter
- [ ] Spectrum pipeline supports allocate=False mode
- [ ] NetworkState has required query methods
- [ ] No algorithm logic duplicated in adapter

## Next Task

Proceed to **P4.1.e** to define the verification plan and unit tests.
