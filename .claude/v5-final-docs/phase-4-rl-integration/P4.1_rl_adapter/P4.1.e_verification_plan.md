# Task ID: P4.1.e - Verification Plan: RLSimulationAdapter

**Sub-phase:** P4.1
**Scope:** Phase 4 - RL Integration only
**Task type:** verification-plan

## Purpose

Define comprehensive unit tests for `RLSimulationAdapter` and `PathOption` to ensure correctness, invariant preservation, and proper integration with V4 pipelines.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.b_design_pathoption.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.c_design_adapter_api.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.d_wiring_plan_pipelines.md`
- `.claude/v4-docs/testing/phase_4_testing.md`

## Outputs

### 1. Test File Structure

```
fusion/tests/rl/
├── __init__.py
├── conftest.py                    # Shared fixtures
├── test_pathoption.py             # PathOption unit tests
├── test_adapter.py                # RLSimulationAdapter tests
├── test_adapter_pipelines.py      # Pipeline integration tests
├── test_adapter_observation.py    # Observation building tests
└── test_adapter_reward.py         # Reward computation tests
```

### 2. Shared Fixtures (conftest.py)

```python
import pytest
from unittest.mock import Mock, MagicMock
import numpy as np

from fusion.rl.adapter import RLSimulationAdapter, PathOption


@pytest.fixture
def mock_config():
    """Mock simulation config with RL settings."""
    config = Mock()
    config.k_paths = 3
    config.rl_success_reward = 1.0
    config.rl_block_penalty = -1.0
    config.rl_grooming_bonus = 0.1
    config.rl_slicing_penalty = -0.05
    config.rl_bandwidth_weighted = False
    config.max_holding_time = 100.0
    return config


@pytest.fixture
def mock_network_state():
    """Mock network state with query methods."""
    state = Mock()
    state.num_nodes = 14
    state.total_slots = 320
    state.get_link_utilization.return_value = 0.5
    state.get_available_slots.return_value = 160
    state.snapshot.return_value = {"frozen": "state"}
    return state


@pytest.fixture
def mock_request():
    """Mock request object."""
    req = Mock()
    req.id = 42
    req.source = 0
    req.destination = 5
    req.bandwidth_gbps = 100.0
    req.holding_time = 50.0
    return req


@pytest.fixture
def mock_route_result():
    """Mock routing result."""
    result = Mock()
    result.path = ["0", "2", "5"]
    result.weight_km = 450.0
    result.modulation = "QPSK"
    result.slots_needed = 4
    return result


@pytest.fixture
def mock_spectrum_result_feasible():
    """Mock feasible spectrum result."""
    result = Mock()
    result.is_free = True
    result.start_slot = 10
    result.end_slot = 13
    result.core_index = 0
    result.band = "C"
    return result


@pytest.fixture
def mock_spectrum_result_infeasible():
    """Mock infeasible spectrum result."""
    result = Mock()
    result.is_free = False
    result.start_slot = None
    result.end_slot = None
    result.core_index = None
    result.band = None
    return result


@pytest.fixture
def mock_routing_pipeline(mock_route_result):
    """Mock routing pipeline."""
    pipeline = Mock()
    pipeline.find_routes.return_value = [mock_route_result]
    return pipeline


@pytest.fixture
def mock_spectrum_pipeline(mock_spectrum_result_feasible):
    """Mock spectrum pipeline."""
    pipeline = Mock()
    pipeline.find_spectrum.return_value = mock_spectrum_result_feasible
    return pipeline


@pytest.fixture
def mock_orchestrator(mock_routing_pipeline, mock_spectrum_pipeline):
    """Mock orchestrator with pipelines."""
    orch = Mock()
    orch.routing_pipeline = mock_routing_pipeline
    orch.spectrum_pipeline = mock_spectrum_pipeline
    orch.handle_arrival.return_value = Mock(success=True)
    return orch


@pytest.fixture
def adapter(mock_orchestrator, mock_config):
    """Create adapter instance."""
    return RLSimulationAdapter(
        orchestrator=mock_orchestrator,
        config=mock_config,
    )
```

### 3. PathOption Tests (test_pathoption.py)

```python
import pytest
import numpy as np
from dataclasses import FrozenInstanceError

from fusion.rl.adapter import PathOption, compute_action_mask


class TestPathOptionCreation:
    """Tests for PathOption construction."""

    def test_create_basic_pathoption(self):
        """Can create PathOption with required fields."""
        opt = PathOption(
            path_index=0,
            path=("0", "2", "5"),
            weight_km=450.0,
            num_hops=2,
            modulation="QPSK",
            slots_needed=4,
            is_feasible=True,
            congestion=0.3,
            available_slots=0.7,
        )
        assert opt.path_index == 0
        assert opt.path == ("0", "2", "5")
        assert opt.is_feasible is True

    def test_pathoption_with_spectrum_fields(self):
        """PathOption can include spectrum assignment details."""
        opt = PathOption(
            path_index=0,
            path=("0", "2", "5"),
            weight_km=450.0,
            num_hops=2,
            modulation="QPSK",
            slots_needed=4,
            is_feasible=True,
            congestion=0.3,
            available_slots=0.7,
            spectrum_start=10,
            spectrum_end=13,
            core_index=0,
            band="C",
        )
        assert opt.spectrum_start == 10
        assert opt.spectrum_end == 13


class TestPathOptionImmutability:
    """Tests for PathOption frozen behavior."""

    def test_pathoption_is_frozen(self):
        """PathOption should not allow attribute modification."""
        opt = PathOption(
            path_index=0, path=("0", "5"), weight_km=100.0,
            num_hops=1, modulation="QPSK", slots_needed=4,
            is_feasible=True, congestion=0.1, available_slots=0.9,
        )
        with pytest.raises(FrozenInstanceError):
            opt.is_feasible = False

    def test_pathoption_is_hashable(self):
        """PathOption should be hashable for use in sets/dicts."""
        opt = PathOption(
            path_index=0, path=("0", "5"), weight_km=100.0,
            num_hops=1, modulation="QPSK", slots_needed=4,
            is_feasible=True, congestion=0.1, available_slots=0.9,
        )
        # Should not raise
        hash(opt)
        {opt}  # Can use in set


class TestPathOptionValidation:
    """Tests for PathOption invariant validation."""

    def test_negative_path_index_raises(self):
        """path_index must be non-negative."""
        with pytest.raises(ValueError, match="path_index"):
            PathOption(
                path_index=-1, path=("0", "5"), weight_km=100.0,
                num_hops=1, modulation="QPSK", slots_needed=4,
                is_feasible=True, congestion=0.1, available_slots=0.9,
            )

    def test_negative_weight_raises(self):
        """weight_km must be non-negative."""
        with pytest.raises(ValueError, match="weight_km"):
            PathOption(
                path_index=0, path=("0", "5"), weight_km=-100.0,
                num_hops=1, modulation="QPSK", slots_needed=4,
                is_feasible=True, congestion=0.1, available_slots=0.9,
            )

    def test_congestion_out_of_range_raises(self):
        """congestion must be in [0, 1]."""
        with pytest.raises(ValueError, match="congestion"):
            PathOption(
                path_index=0, path=("0", "5"), weight_km=100.0,
                num_hops=1, modulation="QPSK", slots_needed=4,
                is_feasible=True, congestion=1.5, available_slots=0.9,
            )

    def test_available_slots_out_of_range_raises(self):
        """available_slots must be in [0, 1]."""
        with pytest.raises(ValueError, match="available_slots"):
            PathOption(
                path_index=0, path=("0", "5"), weight_km=100.0,
                num_hops=1, modulation="QPSK", slots_needed=4,
                is_feasible=True, congestion=0.1, available_slots=-0.1,
            )


class TestActionMask:
    """Tests for action mask generation."""

    def test_action_mask_basic(self):
        """Action mask reflects feasibility."""
        options = [
            PathOption(path_index=0, path=("0",), weight_km=0, num_hops=0,
                      modulation="QPSK", slots_needed=4, is_feasible=True,
                      congestion=0, available_slots=1),
            PathOption(path_index=1, path=("1",), weight_km=0, num_hops=0,
                      modulation="QPSK", slots_needed=4, is_feasible=False,
                      congestion=0.5, available_slots=0.5),
            PathOption(path_index=2, path=("2",), weight_km=0, num_hops=0,
                      modulation="QPSK", slots_needed=4, is_feasible=True,
                      congestion=0.2, available_slots=0.8),
        ]
        mask = compute_action_mask(options, k_paths=3)
        assert mask.tolist() == [True, False, True]

    def test_action_mask_fewer_options_than_k(self):
        """Mask handles fewer options than k_paths."""
        options = [
            PathOption(path_index=0, path=("0",), weight_km=0, num_hops=0,
                      modulation="QPSK", slots_needed=4, is_feasible=True,
                      congestion=0, available_slots=1),
        ]
        mask = compute_action_mask(options, k_paths=3)
        assert mask.tolist() == [True, False, False]

    def test_action_mask_empty_options(self):
        """Mask handles empty options list."""
        mask = compute_action_mask([], k_paths=3)
        assert mask.tolist() == [False, False, False]
```

### 4. Adapter Core Tests (test_adapter.py)

```python
import pytest
from unittest.mock import Mock, patch

from fusion.rl.adapter import RLSimulationAdapter


class TestAdapterInitialization:
    """Tests for adapter construction."""

    def test_create_adapter(self, mock_orchestrator, mock_config):
        """Can create adapter with valid orchestrator."""
        adapter = RLSimulationAdapter(mock_orchestrator, mock_config)
        assert adapter is not None

    def test_none_orchestrator_raises(self, mock_config):
        """Creating adapter with None orchestrator raises."""
        with pytest.raises(ValueError, match="orchestrator"):
            RLSimulationAdapter(None, mock_config)

    def test_adapter_references_same_pipelines(
        self, adapter, mock_orchestrator
    ):
        """Adapter uses same pipeline instances as orchestrator."""
        assert adapter.routing_pipeline is mock_orchestrator.routing_pipeline
        assert adapter.spectrum_pipeline is mock_orchestrator.spectrum_pipeline


class TestGetPathOptions:
    """Tests for get_path_options method."""

    def test_returns_path_options(
        self, adapter, mock_request, mock_network_state
    ):
        """get_path_options returns PathOption list."""
        options = adapter.get_path_options(mock_request, mock_network_state)
        assert len(options) >= 1
        assert all(isinstance(opt, PathOption) for opt in options)

    def test_calls_routing_pipeline(
        self, adapter, mock_request, mock_network_state, mock_orchestrator
    ):
        """get_path_options calls routing pipeline."""
        adapter.get_path_options(mock_request, mock_network_state)
        mock_orchestrator.routing_pipeline.find_routes.assert_called_once()

    def test_calls_spectrum_pipeline_without_allocate(
        self, adapter, mock_request, mock_network_state, mock_orchestrator
    ):
        """get_path_options calls spectrum with allocate=False."""
        adapter.get_path_options(mock_request, mock_network_state)

        call_kwargs = mock_orchestrator.spectrum_pipeline.find_spectrum.call_args.kwargs
        assert call_kwargs.get('allocate') is False

    def test_is_readonly(self, adapter, mock_request, mock_network_state):
        """get_path_options does not modify network state."""
        before = mock_network_state.snapshot()
        adapter.get_path_options(mock_request, mock_network_state)
        after = mock_network_state.snapshot()
        assert before == after


class TestApplyAction:
    """Tests for apply_action method."""

    def test_apply_valid_action(
        self, adapter, mock_request, mock_network_state
    ):
        """apply_action with valid action returns result."""
        options = adapter.get_path_options(mock_request, mock_network_state)
        result = adapter.apply_action(0, mock_request, mock_network_state, options)
        assert result is not None

    def test_apply_action_calls_orchestrator(
        self, adapter, mock_request, mock_network_state, mock_orchestrator
    ):
        """apply_action routes through orchestrator."""
        options = adapter.get_path_options(mock_request, mock_network_state)
        adapter.apply_action(0, mock_request, mock_network_state, options)

        mock_orchestrator.handle_arrival.assert_called_once()

    def test_apply_action_passes_forced_path(
        self, adapter, mock_request, mock_network_state, mock_orchestrator
    ):
        """apply_action passes forced_path to orchestrator."""
        options = adapter.get_path_options(mock_request, mock_network_state)
        adapter.apply_action(0, mock_request, mock_network_state, options)

        call_kwargs = mock_orchestrator.handle_arrival.call_args.kwargs
        assert 'forced_path' in call_kwargs
        assert call_kwargs['forced_path'] is not None

    def test_invalid_action_index_raises(
        self, adapter, mock_request, mock_network_state, mock_config
    ):
        """apply_action with out-of-range action raises."""
        options = adapter.get_path_options(mock_request, mock_network_state)

        with pytest.raises(ValueError, match="out of range"):
            adapter.apply_action(
                mock_config.k_paths + 1,  # Out of range
                mock_request, mock_network_state, options
            )

    def test_negative_action_raises(
        self, adapter, mock_request, mock_network_state
    ):
        """apply_action with negative action raises."""
        options = adapter.get_path_options(mock_request, mock_network_state)

        with pytest.raises(ValueError, match="out of range"):
            adapter.apply_action(-1, mock_request, mock_network_state, options)
```

### 5. Reward Tests (test_adapter_reward.py)

```python
import pytest
from unittest.mock import Mock


class TestComputeReward:
    """Tests for reward computation."""

    def test_success_reward(self, adapter, mock_request):
        """Successful allocation returns positive reward."""
        result = Mock(success=True, is_groomed=False, is_sliced=False)
        reward = adapter.compute_reward(result, mock_request)
        assert reward == 1.0  # config.rl_success_reward

    def test_failure_penalty(self, adapter, mock_request):
        """Failed allocation returns negative reward."""
        result = Mock(success=False)
        reward = adapter.compute_reward(result, mock_request)
        assert reward == -1.0  # config.rl_block_penalty

    def test_grooming_bonus(self, adapter, mock_request):
        """Groomed allocation gets bonus."""
        result = Mock(success=True, is_groomed=True, is_sliced=False)
        reward = adapter.compute_reward(result, mock_request)
        assert reward == 1.1  # success + grooming_bonus

    def test_slicing_penalty(self, adapter, mock_request):
        """Sliced allocation gets penalty."""
        result = Mock(success=True, is_groomed=False, is_sliced=True)
        reward = adapter.compute_reward(result, mock_request)
        assert reward == 0.95  # success + slicing_penalty
```

### 6. Coverage Requirements

| Module | Target Coverage |
|--------|-----------------|
| `fusion/rl/adapter.py` | >= 90% |
| `fusion/rl/__init__.py` | 100% |
| Total `fusion/rl/` | >= 80% |

### 7. Test Commands

```bash
# Run all P4.1 tests
pytest fusion/tests/rl/test_pathoption.py fusion/tests/rl/test_adapter*.py -v

# Run with coverage
pytest fusion/tests/rl/ --cov=fusion/rl --cov-report=term-missing

# Run specific test class
pytest fusion/tests/rl/test_adapter.py::TestGetPathOptions -v
```

## Verification Checklist

- [ ] All test files created and importable
- [ ] conftest.py fixtures work correctly
- [ ] PathOption tests pass (creation, immutability, validation, action mask)
- [ ] Adapter initialization tests pass
- [ ] get_path_options tests pass (read-only, pipeline calls)
- [ ] apply_action tests pass (orchestrator routing, forced_path)
- [ ] Reward computation tests pass
- [ ] Coverage >= 80% for `fusion/rl/`
- [ ] All tests pass with `make test-new`

## Next Sub-Phase

After P4.1 verification passes, proceed to **P4.2: UnifiedSimEnv Wiring**.
