# Task ID: P4.1.c - Design RLSimulationAdapter API

**Sub-phase:** P4.1
**Scope:** Phase 4 - RL Integration only
**Task type:** design

## Purpose

Design the complete public API for `RLSimulationAdapter`, the central coordination layer between RL environments and the V4 simulation stack.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.shared_context_legacy_rl_paths.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.b_design_pathoption.md` (PathOption design)
- `.claude/v4-docs/architecture/rl_integration.md` (adapter architecture)
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.index.md` (orchestrator interface)

## Outputs

### 1. RLSimulationAdapter Class Definition

Create the full class in `fusion/rl/adapter.py`:

```python
from dataclasses import dataclass
from typing import Protocol, Any
import numpy as np

from fusion.rl.adapter import PathOption, PathOptionList, ActionMask


class RLSimulationAdapter:
    """Adapter layer between RL environments and V4 simulation stack.

    This adapter provides RL agents with access to routing and spectrum
    pipelines WITHOUT duplicating any simulation logic. It uses the SAME
    pipeline instances as the SDNOrchestrator.

    Key Invariants:
    - Adapter never stores NetworkState (receives per-call)
    - Adapter never directly mutates spectrum (goes through orchestrator)
    - get_path_options() is read-only
    - apply_action() returns AllocationResult from orchestrator

    Example:
        adapter = RLSimulationAdapter(orchestrator)

        # In env.step():
        options = adapter.get_path_options(request, network_state)
        mask = adapter.get_action_mask(options)

        # After agent selects action:
        result = adapter.apply_action(action, request, network_state, options)
        reward = adapter.compute_reward(result, request)
    """

    def __init__(
        self,
        orchestrator: "SDNOrchestrator",
        config: "SimulationConfig",
    ) -> None:
        """Initialize adapter with orchestrator reference.

        Args:
            orchestrator: SDNOrchestrator instance (shares pipelines)
            config: Simulation configuration for RL-specific settings

        Raises:
            ValueError: If orchestrator is None or misconfigured
        """
        if orchestrator is None:
            raise ValueError("orchestrator cannot be None")

        self._orchestrator = orchestrator
        self._config = config

        # Verify we have access to required pipelines
        # These are the SAME instances used by orchestrator
        self._routing = orchestrator.routing_pipeline
        self._spectrum = orchestrator.spectrum_pipeline

    @property
    def routing_pipeline(self) -> "RoutingPipeline":
        """Access to shared routing pipeline (same as orchestrator)."""
        return self._routing

    @property
    def spectrum_pipeline(self) -> "SpectrumPipeline":
        """Access to shared spectrum pipeline (same as orchestrator)."""
        return self._spectrum

    def get_path_options(
        self,
        request: "Request",
        network_state: "NetworkState",
    ) -> PathOptionList:
        """Get candidate paths with feasibility information.

        This method is READ-ONLY. It queries routing and spectrum pipelines
        but does NOT allocate any spectrum or modify network state.

        Args:
            request: Current request to route
            network_state: Current network state (not stored)

        Returns:
            List of PathOption, one per candidate path, with:
            - Path geometry (nodes, length, hops)
            - Modulation and slots needed
            - Feasibility from real spectrum check
            - Congestion and availability metrics

        Note:
            The number of options returned may be less than k_paths
            if routing cannot find enough paths.
        """
        # 1. Get candidate paths from routing pipeline
        route_results = self._routing.find_routes(
            request=request,
            network_state=network_state,
            k=self._config.k_paths,
        )

        options: list[PathOption] = []

        for idx, route_result in enumerate(route_results):
            # 2. Check spectrum feasibility for each path (READ-ONLY)
            spectrum_result = self._spectrum.find_spectrum(
                path=route_result.path,
                request=request,
                network_state=network_state,
                allocate=False,  # Critical: do not allocate
            )

            # 3. Compute congestion metrics
            congestion = self._compute_path_congestion(
                path=route_result.path,
                network_state=network_state,
            )
            available = self._compute_available_slots(
                path=route_result.path,
                network_state=network_state,
            )

            # 4. Create PathOption
            option = PathOption.from_pipeline_results(
                path_index=idx,
                route_result=route_result,
                spectrum_result=spectrum_result,
                congestion=congestion,
                available_slots=available,
            )
            options.append(option)

        return options

    def get_action_mask(
        self,
        options: PathOptionList,
    ) -> ActionMask:
        """Generate action mask from path options.

        Args:
            options: List of PathOption from get_path_options()

        Returns:
            Boolean array of shape (k_paths,) where True = feasible
        """
        return compute_action_mask(options, self._config.k_paths)

    def apply_action(
        self,
        action: int,
        request: "Request",
        network_state: "NetworkState",
        options: PathOptionList,
    ) -> "AllocationResult":
        """Apply the selected action via orchestrator.

        This method routes through the SDNOrchestrator with a forced path,
        ensuring all allocation logic (spectrum assignment, SNR validation,
        grooming, slicing) uses the same code paths as non-RL simulation.

        Args:
            action: Index of selected path (0 to k_paths-1)
            request: Current request
            network_state: Current network state
            options: PathOption list from get_path_options()

        Returns:
            AllocationResult from orchestrator

        Raises:
            ValueError: If action index is out of range
            RuntimeError: If no matching PathOption found
        """
        if action < 0 or action >= self._config.k_paths:
            raise ValueError(f"Action {action} out of range [0, {self._config.k_paths})")

        # Find the corresponding PathOption
        selected_option: PathOption | None = None
        for opt in options:
            if opt.path_index == action:
                selected_option = opt
                break

        if selected_option is None:
            # Action refers to a path that wasn't returned (e.g., not enough paths)
            # Return a failed allocation result
            return AllocationResult(
                success=False,
                block_reason="NO_PATH_FOR_ACTION",
                request_id=request.id,
            )

        # Apply via orchestrator with forced path
        result = self._orchestrator.handle_arrival(
            request=request,
            network_state=network_state,
            forced_path=list(selected_option.path),
        )

        return result

    def compute_reward(
        self,
        result: "AllocationResult",
        request: "Request",
    ) -> float:
        """Compute reward signal from allocation result.

        Reward structure:
        - Success: +config.rl_success_reward (default: 1.0)
        - Failure: +config.rl_block_penalty (default: -1.0)
        - Grooming bonus: +config.rl_grooming_bonus (default: 0.1)
        - Slicing penalty: +config.rl_slicing_penalty (default: -0.05)

        Optional bandwidth weighting scales reward by request size.

        Args:
            result: AllocationResult from apply_action()
            request: Request that was processed

        Returns:
            Scalar reward value
        """
        if not result.success:
            return self._config.rl_block_penalty

        reward = self._config.rl_success_reward

        # Apply bonuses/penalties based on allocation type
        if getattr(result, 'is_groomed', False):
            reward += self._config.rl_grooming_bonus
        if getattr(result, 'is_sliced', False):
            reward += self._config.rl_slicing_penalty

        # Optional bandwidth weighting
        if self._config.rl_bandwidth_weighted:
            reward *= request.bandwidth_gbps / 100.0

        return reward

    def build_observation(
        self,
        request: "Request",
        options: PathOptionList,
        network_state: "NetworkState",
    ) -> dict[str, Any]:
        """Build observation dictionary for RL agent.

        Constructs observation from domain objects (Request, PathOption,
        NetworkState) without accessing raw numpy arrays or engine_props.

        Args:
            request: Current request
            options: PathOption list from get_path_options()
            network_state: Current network state

        Returns:
            Dict matching the observation space specification
        """
        k = self._config.k_paths
        num_nodes = network_state.num_nodes

        # Request features
        source_onehot = np.zeros(num_nodes, dtype=np.float32)
        source_onehot[request.source] = 1.0

        dest_onehot = np.zeros(num_nodes, dtype=np.float32)
        dest_onehot[request.destination] = 1.0

        # Normalize holding time to [0, 1]
        max_ht = self._config.max_holding_time
        holding_time = min(request.holding_time / max_ht, 1.0)

        # Path features (padded to k_paths)
        slots_needed = np.full(k, -1.0, dtype=np.float32)
        path_lengths = np.zeros(k, dtype=np.float32)
        congestion = np.zeros(k, dtype=np.float32)
        available = np.zeros(k, dtype=np.float32)
        is_feasible = np.zeros(k, dtype=np.float32)

        for opt in options:
            i = opt.path_index
            if i < k:
                slots_needed[i] = float(opt.slots_needed)
                path_lengths[i] = float(opt.num_hops)
                congestion[i] = opt.congestion
                available[i] = opt.available_slots
                is_feasible[i] = 1.0 if opt.is_feasible else 0.0

        return {
            "source": source_onehot,
            "destination": dest_onehot,
            "holding_time": np.array([holding_time], dtype=np.float32),
            "slots_needed": slots_needed,
            "path_lengths": path_lengths,
            "congestion": congestion,
            "available_slots": available,
            "is_feasible": is_feasible,
        }

    # --- Private helper methods ---

    def _compute_path_congestion(
        self,
        path: list[str],
        network_state: "NetworkState",
    ) -> float:
        """Compute congestion metric for a path.

        Congestion = max link utilization along the path.
        Returns value in [0, 1].
        """
        if len(path) < 2:
            return 0.0

        max_util = 0.0
        for i in range(len(path) - 1):
            src, dst = path[i], path[i + 1]
            util = network_state.get_link_utilization(src, dst)
            max_util = max(max_util, util)

        return max_util

    def _compute_available_slots(
        self,
        path: list[str],
        network_state: "NetworkState",
    ) -> float:
        """Compute available slots ratio for a path.

        Returns min(available/total) across all links.
        Value in [0, 1] where 1 = fully available.
        """
        if len(path) < 2:
            return 1.0

        min_ratio = 1.0
        for i in range(len(path) - 1):
            src, dst = path[i], path[i + 1]
            avail = network_state.get_available_slots(src, dst)
            total = network_state.total_slots
            min_ratio = min(min_ratio, avail / total if total > 0 else 0.0)

        return min_ratio
```

### 2. Configuration Fields

Add these fields to `SimulationConfig` (or RL-specific config):

```python
@dataclass
class RLConfig:
    """RL-specific configuration."""
    k_paths: int = 3
    rl_success_reward: float = 1.0
    rl_block_penalty: float = -1.0
    rl_grooming_bonus: float = 0.1
    rl_slicing_penalty: float = -0.05
    rl_bandwidth_weighted: bool = False
    max_holding_time: float = 100.0  # For normalization
```

### 3. Protocol for Type Safety

Define protocol for pipeline access:

```python
from typing import Protocol

class RoutingPipeline(Protocol):
    def find_routes(
        self,
        request: "Request",
        network_state: "NetworkState",
        k: int,
    ) -> list["RouteResult"]: ...

class SpectrumPipeline(Protocol):
    def find_spectrum(
        self,
        path: list[str],
        request: "Request",
        network_state: "NetworkState",
        allocate: bool = True,
    ) -> "SpectrumResult": ...
```

### 4. Invariants Enforcement

The adapter enforces these invariants:

1. **Pipeline Identity**: Same instances as orchestrator
   ```python
   assert adapter.routing_pipeline is orchestrator.routing_pipeline
   ```

2. **Stateless Design**: No NetworkState caching
   ```python
   # Adapter has no _network_state field
   # Every method receives network_state as parameter
   ```

3. **Read-Only get_path_options**:
   ```python
   # Spectrum pipeline called with allocate=False
   spectrum_result = self._spectrum.find_spectrum(..., allocate=False)
   ```

4. **Write-Through Orchestrator**:
   ```python
   # apply_action goes through orchestrator, not directly to pipelines
   result = self._orchestrator.handle_arrival(...)
   ```

## Verification

- [ ] All public methods have type annotations
- [ ] Docstrings explain purpose and invariants
- [ ] Pipeline identity is preserved
- [ ] NetworkState is never stored
- [ ] get_path_options is read-only
- [ ] apply_action routes through orchestrator
- [ ] Reward computation uses AllocationResult

## Next Task

Proceed to **P4.1.d** to plan the wiring between adapter and pipelines.
