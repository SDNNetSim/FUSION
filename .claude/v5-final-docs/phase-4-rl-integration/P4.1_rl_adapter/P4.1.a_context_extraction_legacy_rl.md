# Task ID: P4.1.a - Context Extraction: Legacy RL Paths

**Sub-phase:** P4.1
**Scope:** Phase 4 - RL Integration only
**Task type:** context-extraction

## Purpose

Extract and document the complete data flow of how legacy RL code:
1. Obtains candidate paths for a request
2. Checks feasibility of each path
3. Applies the selected action (allocates spectrum)
4. Computes rewards

This extraction informs the design of `RLSimulationAdapter`.

## Context to load before running this task

- `fusion/modules/rl/gymnasium_envs/general_sim_env.py` (full file)
- `fusion/modules/rl/utils/general_utils.py` (CoreUtilHelpers class, especially mock_handle_arrival)
- `fusion/modules/rl/utils/sim_env.py` (SimEnvUtils, SimEnvObs classes)
- `fusion/modules/rl/agents/path_agent.py` (PathAgent.get_route method)

## Outputs

After running this task, produce:

### 1. Path Generation Trace

Document the exact call sequence from `SimEnv.step()` to obtaining k candidate paths:

```
SimEnv.step(action)
  -> step_helper.get_obs(bandwidth, holding_time)
    -> sim_env_helper.get_drl_obs(bandwidth, holding_time)
      -> route_obj.get_route()
        -> [routing algorithm].get_route()
          -> Returns: paths_matrix, mod_formats, weights
```

Include:
- Method signatures with parameter types
- Which properties objects are modified
- What data structures hold the paths

### 2. Feasibility Check Trace

Document how legacy RL determines if a path can be allocated:

```
SimEnvObs._get_paths_slots()
  -> For each path in paths_matrix:
    -> find_path_congestion(path, network_spectrum)
    -> Optionally: mock_handle_arrival() for binary feasibility
```

Include:
- When `mock_handle_arrival()` is called vs. when congestion heuristics are used
- What determines "feasible" vs "infeasible" in the observation

### 3. Action Application Trace

Document the exact flow when an action is applied:

```
SimEnv.step(action)
  -> step_helper.handle_step(action)
    -> path_agent.get_route(route_obj, action)
      -> Sets: rl_props.chosen_path_list = paths_matrix[action]
  -> rl_help_obj.allocate()
    -> engine_obj.handle_arrival(...)
```

Include:
- How the chosen path is communicated to the simulation engine
- What triggers actual spectrum allocation
- How success/failure is determined

### 4. Reward Computation Trace

Document how rewards are calculated:

```
SimEnv.step(action)
  -> After allocation:
    -> if was_allocated: reward = engine_props["reward"]
    -> else: reward = engine_props["penalty"]
```

Include:
- Where reward/penalty values come from (config?)
- Any dynamic reward shaping logic
- Grooming/slicing bonuses if any

### 5. Data Structure Summary

Create a table of key data structures:

| Structure | Location | Purpose | Key Fields |
|-----------|----------|---------|------------|
| `paths_matrix` | `route_props` | Candidate paths | List of node sequences |
| `mock_sdn_dict` | `rl_props` | Mock SDN state | bandwidth, topology, spectrum |
| ... | ... | ... | ... |

### 6. Mapping to V4 Components

For each legacy component, identify the V4 equivalent:

| Legacy Component | V4 Equivalent | Notes |
|------------------|---------------|-------|
| `route_obj.get_route()` | `routing_pipeline.find_routes()` | Same algorithms, different interface |
| `mock_handle_arrival()` | `spectrum_pipeline.find_spectrum()` | Must not allocate |
| `engine_obj.handle_arrival()` | `orchestrator.handle_arrival()` | Add forced_path support |
| ... | ... | ... |

## Verification

- [ ] All method signatures documented with types
- [ ] Call sequences are traceable end-to-end
- [ ] Data flow between components is clear
- [ ] V4 mappings are complete

## Next Task

Proceed to **P4.1.b** to design the `PathOption` dataclass based on this extraction.
