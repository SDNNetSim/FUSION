# Task ID: P4.3.b - Migration Plan: Factory Function and Feature Flags

**Sub-phase:** P4.3
**Scope:** Phase 4 - RL Integration only
**Task type:** migration-plan

## Purpose

Design and plan implementation of the environment factory function and feature flag system that enables gradual migration from `GeneralSimEnv` to `UnifiedSimEnv`.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.3_migrate_experiments/P4.3.shared_context_training_scripts.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.3_migrate_experiments/P4.3.a_context_extraction_experiments.md`
- `fusion/modules/rl/gymnasium_envs/__init__.py`
- `fusion/modules/rl/utils/gym_envs.py`

## Outputs

### 1. Factory Function Design

Create in `fusion/modules/rl/gymnasium_envs/__init__.py`:

```python
"""RL environment factory and exports."""

from __future__ import annotations

import os
import warnings
from typing import TYPE_CHECKING

import gymnasium as gym

if TYPE_CHECKING:
    from fusion.core.config import SimulationConfig


# Environment type selection
class EnvType:
    """Environment type constants."""
    LEGACY = "legacy"
    UNIFIED = "unified"


def create_sim_env(
    config: dict | SimulationConfig,
    env_type: str | None = None,
    **kwargs,
) -> gym.Env:
    """Create RL simulation environment.

    This factory function creates either the legacy GeneralSimEnv or
    the new UnifiedSimEnv based on the env_type parameter or environment
    variables.

    Args:
        config: Simulation configuration (dict for legacy, SimulationConfig for unified)
        env_type: Environment type to create:
            - "legacy": Use GeneralSimEnv (default)
            - "unified": Use UnifiedSimEnv
            - None: Check USE_UNIFIED_ENV env var, default to legacy
        **kwargs: Additional arguments passed to environment constructor

    Returns:
        Gymnasium environment instance

    Environment Variables:
        USE_UNIFIED_ENV: Set to "1" or "true" to use UnifiedSimEnv by default
        RL_ENV_TYPE: Explicit environment type ("legacy" or "unified")

    Examples:
        # Legacy (default)
        env = create_sim_env(sim_dict)

        # Unified via parameter
        env = create_sim_env(config, env_type="unified")

        # Unified via environment variable
        os.environ["USE_UNIFIED_ENV"] = "1"
        env = create_sim_env(config)
    """
    # Determine environment type
    resolved_type = _resolve_env_type(env_type)

    if resolved_type == EnvType.UNIFIED:
        return _create_unified_env(config, **kwargs)
    else:
        return _create_legacy_env(config, **kwargs)


def _resolve_env_type(env_type: str | None) -> str:
    """Resolve environment type from parameter or environment.

    Priority:
    1. Explicit env_type parameter
    2. RL_ENV_TYPE environment variable
    3. USE_UNIFIED_ENV environment variable
    4. Default to legacy
    """
    if env_type is not None:
        return env_type

    # Check RL_ENV_TYPE
    rl_env_type = os.environ.get("RL_ENV_TYPE", "").lower()
    if rl_env_type in (EnvType.LEGACY, EnvType.UNIFIED):
        return rl_env_type

    # Check USE_UNIFIED_ENV
    use_unified = os.environ.get("USE_UNIFIED_ENV", "").lower()
    if use_unified in ("1", "true", "yes"):
        return EnvType.UNIFIED

    # Default to legacy
    return EnvType.LEGACY


def _create_unified_env(
    config: dict | SimulationConfig,
    **kwargs,
) -> gym.Env:
    """Create UnifiedSimEnv instance."""
    from fusion.rl.environments import UnifiedSimEnv

    # Convert dict to SimulationConfig if needed
    if isinstance(config, dict):
        from fusion.core.config import SimulationConfig
        config = SimulationConfig.from_dict(config)

    return UnifiedSimEnv(config, **kwargs)


def _create_legacy_env(
    config: dict | SimulationConfig,
    **kwargs,
) -> gym.Env:
    """Create legacy GeneralSimEnv instance."""
    from fusion.modules.rl.gymnasium_envs.general_sim_env import SimEnv

    # Convert SimulationConfig to dict if needed
    if hasattr(config, 'to_legacy_dict'):
        sim_dict = config.to_legacy_dict()
    elif isinstance(config, dict):
        sim_dict = config
    else:
        raise TypeError(f"Unsupported config type: {type(config)}")

    # Wrap in "s1" key if needed
    if "s1" not in sim_dict:
        sim_dict = {"s1": sim_dict}

    return SimEnv(sim_dict=sim_dict, **kwargs)


# Re-export for backward compatibility
from fusion.modules.rl.gymnasium_envs.general_sim_env import SimEnv

__all__ = [
    "create_sim_env",
    "EnvType",
    "SimEnv",  # Backward compatibility
]
```

### 2. Feature Flag System

#### 2.1 Environment Variable Flags

| Variable | Values | Effect |
|----------|--------|--------|
| `USE_UNIFIED_ENV` | `"1"`, `"true"`, `"yes"` | Default to UnifiedSimEnv |
| `RL_ENV_TYPE` | `"legacy"`, `"unified"` | Explicit env type |

#### 2.2 Config File Option

Add to INI config:

```ini
[rl]
# ... existing options ...
use_unified_env = false  ; or true
```

#### 2.3 CLI Argument

Add to `run_train.py`:

```python
parser.add_argument(
    "--use-unified-env",
    action="store_true",
    default=False,
    help="Use UnifiedSimEnv instead of legacy GeneralSimEnv"
)
```

### 3. Update create_environment()

Modify `fusion/modules/rl/utils/gym_envs.py`:

```python
def create_environment(
    config_path: str | None = None,
    env_type: str | None = None,
):
    """Create RL environment with callbacks.

    Args:
        config_path: Path to configuration file
        env_type: Environment type ("legacy" or "unified")

    Returns:
        Tuple of (env, sim_dict, callback_list)
    """
    # Setup callbacks
    ep_call_obj = EpisodicRewardCallback(verbose=1)
    param_call_obj = LearnRateEntCallback(verbose=1)
    callback_list = CallbackList([ep_call_obj, param_call_obj])

    # Load configuration
    flat_dict = setup_rl_sim(config_path=config_path)

    # Check config for env_type if not provided
    if env_type is None:
        env_type = flat_dict.get("use_unified_env", None)
        if env_type is True:
            env_type = "unified"
        elif env_type is False:
            env_type = "legacy"

    # Create environment via factory
    env = create_sim_env(
        config=flat_dict,
        env_type=env_type,
        custom_callback=ep_call_obj,
    )

    # Wrap dict for backward compatibility
    wrapped_dict = {"s1": flat_dict} if "s1" not in flat_dict else flat_dict

    return env, wrapped_dict, callback_list
```

### 4. Update CLI Entry Point

Modify `fusion/cli/run_train.py`:

```python
def create_training_argument_parser():
    parser = argparse.ArgumentParser(description="Train RL agent")

    # ... existing arguments ...

    parser.add_argument(
        "--use-unified-env",
        action="store_true",
        default=False,
        help="Use UnifiedSimEnv (V4 stack) instead of legacy GeneralSimEnv"
    )

    parser.add_argument(
        "--env-type",
        choices=["legacy", "unified"],
        default=None,
        help="Explicit environment type selection"
    )

    return parser


def run_training_pipeline(args):
    # Determine env_type
    env_type = args.env_type
    if env_type is None and args.use_unified_env:
        env_type = "unified"

    # Create environment with type
    env, sim_dict, callbacks = create_environment(
        config_path=args.config_path,
        env_type=env_type,
    )

    # ... rest of training ...
```

### 5. Backward Compatibility Layer

Ensure existing imports work:

```python
# These must continue to work:
from fusion.modules.rl.gymnasium_envs import SimEnv
from fusion.modules.rl.gymnasium_envs.general_sim_env import SimEnv

# Direct instantiation still works:
env = SimEnv(sim_dict={"s1": config})
```

### 6. Action Mask Wrapper Integration

Update factory to optionally wrap with ActionMaskWrapper:

```python
def create_sim_env(
    config: dict | SimulationConfig,
    env_type: str | None = None,
    wrap_action_mask: bool = True,  # New parameter
    **kwargs,
) -> gym.Env:
    """Create RL simulation environment.

    Args:
        config: Simulation configuration
        env_type: Environment type
        wrap_action_mask: If True and using unified env, wrap with ActionMaskWrapper
        **kwargs: Additional arguments
    """
    resolved_type = _resolve_env_type(env_type)

    if resolved_type == EnvType.UNIFIED:
        env = _create_unified_env(config, **kwargs)
        if wrap_action_mask:
            from fusion.rl.environments import ActionMaskWrapper
            env = ActionMaskWrapper(env)
        return env
    else:
        return _create_legacy_env(config, **kwargs)
```

### 7. Migration Testing Points

```python
def test_factory_creates_legacy_by_default():
    """Default should be legacy env."""
    env = create_sim_env(config)
    assert isinstance(env, SimEnv)


def test_factory_creates_unified_with_parameter():
    """Explicit parameter should create unified env."""
    env = create_sim_env(config, env_type="unified")
    from fusion.rl.environments import UnifiedSimEnv
    assert isinstance(env.unwrapped, UnifiedSimEnv)


def test_factory_respects_env_variable():
    """Environment variable should control type."""
    os.environ["USE_UNIFIED_ENV"] = "1"
    try:
        env = create_sim_env(config)
        from fusion.rl.environments import UnifiedSimEnv
        assert isinstance(env.unwrapped, UnifiedSimEnv)
    finally:
        del os.environ["USE_UNIFIED_ENV"]


def test_legacy_import_still_works():
    """Legacy imports must continue working."""
    from fusion.modules.rl.gymnasium_envs import SimEnv
    env = SimEnv(sim_dict={"s1": config})
    assert env is not None
```

### 8. Implementation Order

1. Add factory function to `gymnasium_envs/__init__.py`
2. Update `gym_envs.py:create_environment()`
3. Update CLI argument parsing
4. Add config file option parsing
5. Add deprecation warning to `SimEnv.__init__`
6. Update documentation

## Verification

- [ ] Factory function implemented
- [ ] Environment variable flags work
- [ ] CLI argument works
- [ ] Config file option works
- [ ] Backward compatibility preserved
- [ ] All tests pass

## Next Task

Proceed to **P4.3.c** to plan deprecation warnings and migration guide.
