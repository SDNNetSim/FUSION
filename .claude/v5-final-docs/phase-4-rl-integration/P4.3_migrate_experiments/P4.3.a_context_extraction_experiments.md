# Task ID: P4.3.a - Context Extraction: Existing RL Experiments

**Sub-phase:** P4.3
**Scope:** Phase 4 - RL Integration only
**Task type:** context-extraction

## Purpose

Document all existing RL training scripts, experiment configurations, and environment usage patterns to ensure migration plan covers all use cases.

## Context to load before running this task

- `fusion/cli/run_train.py`
- `fusion/sim/train_pipeline.py`
- `fusion/modules/rl/workflow_runner.py`
- `fusion/modules/rl/utils/gym_envs.py`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.3_migrate_experiments/P4.3.shared_context_training_scripts.md`

## Outputs

### 1. Training Entry Point Inventory

Document all ways users can start RL training:

```
Entry Points:
1. CLI: `python -m fusion.cli.run_train --config config.ini`
   - Parses arguments
   - Calls train_pipeline.train_rl_agent()

2. Direct import:
   from fusion.modules.rl.utils.gym_envs import create_environment
   env, _, _ = create_environment("config.ini")

3. Experiment scripts:
   experiments/*/train.py
   - Custom training loops
   - May create env directly

4. Notebooks:
   notebooks/rl_demo.ipynb
   - Interactive training
```

### 2. Environment Creation Patterns

Document all patterns for creating RL environments:

```python
# Pattern 1: Via factory function
from fusion.modules.rl.utils.gym_envs import create_environment
env, sim_dict, callbacks = create_environment(config_path)

# Pattern 2: Direct instantiation
from fusion.modules.rl.gymnasium_envs import SimEnv
sim_dict = load_config(config_path)
env = SimEnv(sim_dict={"s1": sim_dict})

# Pattern 3: With custom callback
callback = CustomCallback()
env = SimEnv(custom_callback=callback, sim_dict=sim_dict)

# Pattern 4: Via workflow runner
workflow_runner.run(env=env, sim_dict=sim_dict, ...)
```

### 3. Configuration Sources

Document all configuration sources:

| Source | Format | Usage |
|--------|--------|-------|
| INI files | `[section]` format | Main config |
| YAML files | `key: value` | Hyperparameters |
| Environment variables | `FUSION_*` | Overrides |
| CLI arguments | `--key value` | Runtime overrides |
| Python dicts | `sim_dict` | Internal representation |

### 4. Algorithm Usage Mapping

Document which algorithms use which environment features:

| Algorithm | Observation Keys | Action Masking | Custom Reward |
|-----------|------------------|----------------|---------------|
| PPO | All | Via wrapper | No |
| A2C | All | Via wrapper | No |
| DQN | All | Via wrapper | No |
| QR-DQN | All | Via wrapper | No |
| Q-Learning | source, dest only | Manual | Yes |
| Bandits | path_cong only | No | No |

### 5. Training Script Inventory

List all training scripts and their patterns:

```
Scripts:
1. fusion/cli/run_train.py
   - Standard CLI training
   - Uses workflow_runner

2. experiments/nsfnet/train_ppo.py
   - PPO training on NSFNet
   - Custom hyperparameters

3. experiments/cost266/train_a2c.py
   - A2C training on COST266
   - With curriculum learning

4. scripts/benchmark_algorithms.py
   - Compares multiple algorithms
   - Creates multiple environments

5. notebooks/rl_tutorial.ipynb
   - Educational notebook
   - Step-by-step training
```

### 6. Callback Usage

Document callback patterns:

```python
# Standard callbacks
callbacks = [
    EpisodicRewardCallback(),
    LearnRateEntCallback(),
]

# Custom callbacks
class BlockingRateCallback(BaseCallback):
    def _on_step(self):
        # Track blocking rate
        pass

# Tensorboard logging
from stable_baselines3.common.callbacks import TensorboardCallback
callbacks.append(TensorboardCallback())
```

### 7. Model Save/Load Patterns

Document model persistence patterns:

```python
# Training
model.save("path/to/model")

# Loading for inference
model = PPO.load("path/to/model", env=env)

# Loading for continued training
model = PPO.load("path/to/model")
model.set_env(env)
model.learn(additional_timesteps)
```

### 8. Environment Wrapping Patterns

Document how environments are wrapped:

```python
# Current (no action masking wrapper)
env = SimEnv(sim_dict=sim_dict)
model = PPO("MultiInputPolicy", env)

# With vector env
from stable_baselines3.common.vec_env import DummyVecEnv
env = DummyVecEnv([lambda: SimEnv(sim_dict=sim_dict)])

# With monitoring
from stable_baselines3.common.monitor import Monitor
env = Monitor(SimEnv(sim_dict=sim_dict))
```

### 9. Identified Migration Requirements

Based on the analysis, identify what the migration must support:

| Requirement | Current State | Migration Need |
|-------------|---------------|----------------|
| Factory function | Returns SimEnv only | Return either env based on flag |
| CLI argument | None | Add `--use-unified-env` flag |
| Env variable | None | Support `USE_UNIFIED_ENV` |
| Config option | None | Add `use_unified_env` in INI |
| Backward compat | N/A | SimEnv must still work |
| Deprecation | N/A | Add warning to SimEnv |

### 10. Migration Complexity Assessment

For each pattern, assess migration complexity:

| Pattern | Complexity | Notes |
|---------|------------|-------|
| CLI training | Low | Single change point |
| Direct instantiation | Medium | Many call sites |
| Experiment scripts | Medium | Each needs update |
| Notebooks | Low | Few instances |
| Custom wrappers | High | May need adaptation |
| Model loading | High | Observation space changes |

## Verification

- [ ] All training entry points documented
- [ ] All environment creation patterns identified
- [ ] All configuration sources listed
- [ ] Algorithm-feature mapping complete
- [ ] Migration requirements clear
- [ ] Complexity assessment realistic

## Next Task

Proceed to **P4.3.b** to plan the factory function and feature flags.
