# Task ID: P4.3.d - Verification Plan: Migration Testing

**Sub-phase:** P4.3
**Scope:** Phase 4 - RL Integration only
**Task type:** verification-plan

## Purpose

Define tests to verify that the migration infrastructure works correctly, backward compatibility is preserved, and both environments can be used interchangeably.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.3_migrate_experiments/P4.3.b_migration_plan_factory.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.3_migrate_experiments/P4.3.c_deprecation_plan.md`

## Outputs

### 1. Test File Structure

```
fusion/tests/rl/
├── __init__.py
├── conftest.py                    # Extended with migration fixtures
├── test_migration_factory.py      # Factory function tests
├── test_migration_compat.py       # Backward compatibility tests
├── test_migration_deprecation.py  # Deprecation warning tests
└── test_migration_training.py     # End-to-end training tests
```

### 2. Factory Function Tests (test_migration_factory.py)

```python
import pytest
import os
from unittest.mock import patch

from fusion.modules.rl.gymnasium_envs import create_sim_env, EnvType


class TestFactoryBasic:
    """Basic factory function tests."""

    def test_factory_exists(self):
        """Factory function should be importable."""
        from fusion.modules.rl.gymnasium_envs import create_sim_env
        assert callable(create_sim_env)

    def test_factory_creates_env(self, env_config):
        """Factory should create environment."""
        env = create_sim_env(env_config)
        assert env is not None
        env.close()


class TestFactoryEnvType:
    """Environment type selection tests."""

    def test_default_is_legacy(self, env_config):
        """Default should create legacy environment."""
        env = create_sim_env(env_config)
        from fusion.modules.rl.gymnasium_envs import SimEnv
        assert isinstance(env, SimEnv)
        env.close()

    def test_explicit_legacy(self, env_config):
        """Explicit 'legacy' should create SimEnv."""
        env = create_sim_env(env_config, env_type=EnvType.LEGACY)
        from fusion.modules.rl.gymnasium_envs import SimEnv
        assert isinstance(env, SimEnv)
        env.close()

    def test_explicit_unified(self, env_config):
        """Explicit 'unified' should create UnifiedSimEnv."""
        env = create_sim_env(env_config, env_type=EnvType.UNIFIED)
        from fusion.rl.environments import UnifiedSimEnv, ActionMaskWrapper
        # May be wrapped
        assert isinstance(env.unwrapped, UnifiedSimEnv)
        env.close()

    def test_unified_string_type(self, env_config):
        """String 'unified' should work."""
        env = create_sim_env(env_config, env_type="unified")
        from fusion.rl.environments import UnifiedSimEnv
        assert isinstance(env.unwrapped, UnifiedSimEnv)
        env.close()


class TestFactoryEnvVars:
    """Environment variable tests."""

    def test_use_unified_env_true(self, env_config):
        """USE_UNIFIED_ENV=1 should create unified env."""
        with patch.dict(os.environ, {"USE_UNIFIED_ENV": "1"}):
            env = create_sim_env(env_config)
            from fusion.rl.environments import UnifiedSimEnv
            assert isinstance(env.unwrapped, UnifiedSimEnv)
            env.close()

    def test_use_unified_env_false(self, env_config):
        """USE_UNIFIED_ENV=0 should create legacy env."""
        with patch.dict(os.environ, {"USE_UNIFIED_ENV": "0"}):
            env = create_sim_env(env_config)
            from fusion.modules.rl.gymnasium_envs import SimEnv
            assert isinstance(env, SimEnv)
            env.close()

    def test_rl_env_type_unified(self, env_config):
        """RL_ENV_TYPE=unified should create unified env."""
        with patch.dict(os.environ, {"RL_ENV_TYPE": "unified"}):
            env = create_sim_env(env_config)
            from fusion.rl.environments import UnifiedSimEnv
            assert isinstance(env.unwrapped, UnifiedSimEnv)
            env.close()

    def test_explicit_overrides_env_var(self, env_config):
        """Explicit parameter should override env var."""
        with patch.dict(os.environ, {"USE_UNIFIED_ENV": "1"}):
            # Explicit legacy should override env var
            env = create_sim_env(env_config, env_type="legacy")
            from fusion.modules.rl.gymnasium_envs import SimEnv
            assert isinstance(env, SimEnv)
            env.close()


class TestFactoryActionMaskWrapper:
    """Action mask wrapper tests."""

    def test_unified_wrapped_by_default(self, env_config):
        """Unified env should be wrapped with ActionMaskWrapper."""
        env = create_sim_env(env_config, env_type="unified")
        from fusion.rl.environments import ActionMaskWrapper
        assert isinstance(env, ActionMaskWrapper)
        env.close()

    def test_can_disable_wrapping(self, env_config):
        """Should be able to disable ActionMaskWrapper."""
        env = create_sim_env(
            env_config,
            env_type="unified",
            wrap_action_mask=False
        )
        from fusion.rl.environments import ActionMaskWrapper
        assert not isinstance(env, ActionMaskWrapper)
        env.close()
```

### 3. Backward Compatibility Tests (test_migration_compat.py)

```python
import pytest
import warnings


class TestLegacyImports:
    """Test that legacy imports still work."""

    def test_simenv_import_from_gymnasium_envs(self):
        """SimEnv should be importable from gymnasium_envs."""
        from fusion.modules.rl.gymnasium_envs import SimEnv
        assert SimEnv is not None

    def test_simenv_import_from_general_sim_env(self):
        """SimEnv should be importable from general_sim_env."""
        from fusion.modules.rl.gymnasium_envs.general_sim_env import SimEnv
        assert SimEnv is not None

    def test_create_sim_env_import(self):
        """Factory should be importable."""
        from fusion.modules.rl.gymnasium_envs import create_sim_env
        assert callable(create_sim_env)


class TestLegacyInstantiation:
    """Test that legacy instantiation patterns work."""

    def test_direct_simenv_creation(self, legacy_config):
        """Direct SimEnv creation should work."""
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", DeprecationWarning)
            from fusion.modules.rl.gymnasium_envs import SimEnv
            env = SimEnv(sim_dict={"s1": legacy_config})
            assert env is not None
            env.close()

    def test_simenv_with_callback(self, legacy_config):
        """SimEnv with custom callback should work."""
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", DeprecationWarning)
            from fusion.modules.rl.gymnasium_envs import SimEnv
            from unittest.mock import Mock
            callback = Mock()
            env = SimEnv(
                sim_dict={"s1": legacy_config},
                custom_callback=callback
            )
            assert env is not None
            env.close()


class TestLegacyBehavior:
    """Test that legacy environment behavior is preserved."""

    def test_legacy_reset_returns_tuple(self, legacy_env):
        """Legacy reset should return (obs, info)."""
        result = legacy_env.reset(seed=42)
        assert isinstance(result, tuple)
        assert len(result) == 2

    def test_legacy_step_returns_5_tuple(self, legacy_env):
        """Legacy step should return 5-tuple."""
        legacy_env.reset(seed=42)
        result = legacy_env.step(0)
        assert isinstance(result, tuple)
        assert len(result) == 5

    def test_legacy_observation_space_exists(self, legacy_env):
        """Legacy env should have observation_space."""
        assert hasattr(legacy_env, 'observation_space')

    def test_legacy_action_space_exists(self, legacy_env):
        """Legacy env should have action_space."""
        assert hasattr(legacy_env, 'action_space')
```

### 4. Deprecation Warning Tests (test_migration_deprecation.py)

```python
import pytest
import warnings
import os
from unittest.mock import patch


class TestDeprecationWarning:
    """Test deprecation warning behavior."""

    def test_simenv_emits_deprecation_warning(self, legacy_config):
        """SimEnv should emit DeprecationWarning."""
        from fusion.modules.rl.gymnasium_envs import SimEnv

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            env = SimEnv(sim_dict={"s1": legacy_config})
            env.close()

            # Should have at least one DeprecationWarning
            deprecation_warnings = [
                x for x in w if issubclass(x.category, DeprecationWarning)
            ]
            assert len(deprecation_warnings) >= 1

    def test_warning_mentions_unified_env(self, legacy_config):
        """Warning should mention UnifiedSimEnv."""
        from fusion.modules.rl.gymnasium_envs import SimEnv

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            env = SimEnv(sim_dict={"s1": legacy_config})
            env.close()

            deprecation_warnings = [
                x for x in w if issubclass(x.category, DeprecationWarning)
            ]
            assert any("UnifiedSimEnv" in str(x.message) for x in deprecation_warnings)

    def test_warning_mentions_migration_guide(self, legacy_config):
        """Warning should mention migration guide."""
        from fusion.modules.rl.gymnasium_envs import SimEnv

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            env = SimEnv(sim_dict={"s1": legacy_config})
            env.close()

            deprecation_warnings = [
                x for x in w if issubclass(x.category, DeprecationWarning)
            ]
            assert any("migration" in str(x.message).lower() for x in deprecation_warnings)

    def test_can_suppress_warning_with_env_var(self, legacy_config):
        """Should be able to suppress warning via env var."""
        from fusion.modules.rl.gymnasium_envs import SimEnv

        with patch.dict(os.environ, {"SUPPRESS_SIMENV_DEPRECATION": "1"}):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always")
                env = SimEnv(sim_dict={"s1": legacy_config})
                env.close()

                deprecation_warnings = [
                    x for x in w if issubclass(x.category, DeprecationWarning)
                ]
                # May have warnings from other sources, but not from SimEnv
                simenv_warnings = [
                    x for x in deprecation_warnings
                    if "SimEnv" in str(x.message)
                ]
                assert len(simenv_warnings) == 0


class TestUnifiedEnvNoWarning:
    """UnifiedSimEnv should not emit deprecation warnings."""

    def test_unified_env_no_deprecation(self, unified_config):
        """UnifiedSimEnv should not emit DeprecationWarning."""
        from fusion.rl.environments import UnifiedSimEnv

        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter("always")
            env = UnifiedSimEnv(unified_config)
            env.close()

            deprecation_warnings = [
                x for x in w if issubclass(x.category, DeprecationWarning)
            ]
            # No deprecation warnings from UnifiedSimEnv
            unified_warnings = [
                x for x in deprecation_warnings
                if "UnifiedSimEnv" in str(x.message)
            ]
            assert len(unified_warnings) == 0
```

### 5. Training Smoke Tests (test_migration_training.py)

```python
import pytest
import numpy as np


class TestLegacyTrainingSmoke:
    """Smoke tests for legacy environment training."""

    def test_legacy_episode_completes(self, legacy_env):
        """Can complete an episode with legacy env."""
        obs, _ = legacy_env.reset(seed=42)
        done = False
        steps = 0
        max_steps = 100

        while not done and steps < max_steps:
            action = legacy_env.action_space.sample()
            obs, reward, terminated, truncated, info = legacy_env.step(action)
            done = terminated or truncated
            steps += 1

        assert steps > 0

    def test_legacy_deterministic(self, legacy_env):
        """Legacy env should be deterministic with seed."""
        legacy_env.reset(seed=123)
        rewards1 = [legacy_env.step(0)[1] for _ in range(5)]

        legacy_env.reset(seed=123)
        rewards2 = [legacy_env.step(0)[1] for _ in range(5)]

        assert rewards1 == rewards2


class TestUnifiedTrainingSmoke:
    """Smoke tests for unified environment training."""

    def test_unified_episode_completes(self, unified_env):
        """Can complete an episode with unified env."""
        obs, info = unified_env.reset(seed=42)
        done = False
        steps = 0
        max_steps = 100

        while not done and steps < max_steps:
            mask = info.get("action_mask", np.ones(unified_env.action_space.n, dtype=bool))
            valid_actions = np.where(mask)[0]
            action = np.random.choice(valid_actions) if len(valid_actions) > 0 else 0
            obs, reward, terminated, truncated, info = unified_env.step(action)
            done = terminated or truncated
            steps += 1

        assert steps > 0

    def test_unified_deterministic(self, unified_env):
        """Unified env should be deterministic with seed."""
        unified_env.reset(seed=123)
        rewards1 = [unified_env.step(0)[1] for _ in range(5)]

        unified_env.reset(seed=123)
        rewards2 = [unified_env.step(0)[1] for _ in range(5)]

        assert rewards1 == rewards2

    def test_unified_action_mask_provided(self, unified_env):
        """Unified env should provide action mask."""
        _, info = unified_env.reset(seed=42)
        assert "action_mask" in info
        assert isinstance(info["action_mask"], np.ndarray)


class TestBothEnvsUsable:
    """Test that both environments work in same process."""

    def test_can_use_both_sequentially(self, legacy_config, unified_config):
        """Can create and use both envs sequentially."""
        import warnings
        from fusion.modules.rl.gymnasium_envs import SimEnv
        from fusion.rl.environments import UnifiedSimEnv

        # Use legacy
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", DeprecationWarning)
            legacy = SimEnv(sim_dict={"s1": legacy_config})
            legacy.reset(seed=1)
            legacy.step(0)
            legacy.close()

        # Use unified
        unified = UnifiedSimEnv(unified_config)
        unified.reset(seed=1)
        unified.step(0)
        unified.close()

        # Both worked
        assert True
```

### 6. Fixtures for Migration Tests

Add to `conftest.py`:

```python
import pytest
import warnings


@pytest.fixture
def legacy_config():
    """Configuration dict for legacy SimEnv."""
    return {
        "k_paths": 3,
        "spectral_slots": 320,
        "num_requests": 50,
        "reward": 1.0,
        "penalty": -1.0,
        # ... other legacy config keys
    }


@pytest.fixture
def unified_config():
    """SimulationConfig for UnifiedSimEnv."""
    from fusion.core.config import SimulationConfig
    config = SimulationConfig()
    config.k_paths = 3
    config.spectral_slots = 320
    config.num_requests = 50
    config.rl_success_reward = 1.0
    config.rl_block_penalty = -1.0
    return config


@pytest.fixture
def legacy_env(legacy_config):
    """Legacy SimEnv instance."""
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", DeprecationWarning)
        from fusion.modules.rl.gymnasium_envs import SimEnv
        env = SimEnv(sim_dict={"s1": legacy_config})
        yield env
        env.close()


@pytest.fixture
def unified_env(unified_config):
    """UnifiedSimEnv instance."""
    from fusion.rl.environments import UnifiedSimEnv
    env = UnifiedSimEnv(unified_config)
    yield env
    env.close()
```

### 7. Coverage Requirements

| Module | Target Coverage |
|--------|-----------------|
| `fusion/modules/rl/gymnasium_envs/__init__.py` | >= 90% |
| Factory function | 100% |
| Environment type resolution | 100% |

### 8. Test Commands

```bash
# Run all migration tests
pytest fusion/tests/rl/test_migration*.py -v

# Run with warnings visible
pytest fusion/tests/rl/test_migration*.py -v -W always

# Run backward compatibility only
pytest fusion/tests/rl/test_migration_compat.py -v
```

## Verification Checklist

- [ ] Factory function tests pass
- [ ] Environment variable tests pass
- [ ] Backward compatibility tests pass
- [ ] Deprecation warning tests pass
- [ ] Training smoke tests pass
- [ ] Both envs usable in same process
- [ ] Coverage >= 90% for factory code

## Next Sub-Phase

After P4.3 verification passes, proceed to **P4.4: Parity Validation & Differences Documentation**.
