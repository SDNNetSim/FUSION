# Task ID: P4.2.a - Context Extraction: GeneralSimEnv Behavior

**Sub-phase:** P4.2
**Scope:** Phase 4 - RL Integration only
**Task type:** context-extraction

## Purpose

Document the complete behavior of the legacy `GeneralSimEnv` (SimEnv) class to ensure `UnifiedSimEnv` provides behavioral parity where appropriate, and intentional differences where necessary.

## Context to load before running this task

- `fusion/modules/rl/gymnasium_envs/general_sim_env.py` (full file)
- `fusion/modules/rl/utils/sim_env.py` (SimEnvUtils, SimEnvObs classes)
- `fusion/modules/rl/utils/setup.py` (SetupHelper class)
- `.claude/v5-final-docs/phase-4-rl-integration/P4.2_unified_env/P4.2.shared_context_env_requirements.md`

## Outputs

### 1. SimEnv.__init__() Analysis

Document initialization flow:

```
SimEnv.__init__(render_mode, custom_callback, sim_dict)
  |
  v
Create RLProps object with configuration
  - rl_props.super_channel_space = sim_dict["super_channel_space"]
  - rl_props.arrival_count = 0
  |
  v
Initialize helper objects
  - rl_help_obj = CoreUtilHelpers(...)
  - setup_helper = SetupHelper(sim_env=self)
  - sim_env_helper = SimEnvObs(sim_env=self)
  - step_helper = SimEnvUtils(sim_env=self)
  |
  v
Call reset(options={"save_sim": False}) to initialize
  |
  v
Set observation_space and action_space from algorithm
```

Document:
- What is stored in `sim_dict`?
- What does `RLProps` contain?
- What does each helper class do?

### 2. SimEnv.reset() Analysis

Document reset behavior:

```
reset(seed, options) -> (obs, info)
  |
  v
First reset: call setup() to initialize engine_obj, route_obj
  |
  v
Call _init_props_envs(seed)
  - engine_obj.init_iter(seed, trial, iteration)
  - engine_obj.create_topology()
  - Reset arrival_count to 0
  |
  v
Call rl_help_obj.reset_reqs_dict(seed)
  - Generate all requests via engine_obj.generate_requests()
  - Split into arrival_list and depart_list
  - Store in rl_props
  |
  v
Get first request observation via step_helper.get_obs()
  |
  v
Return (obs, {})  # Note: no action_mask in info!
```

Document:
- How is seeding propagated?
- How are requests pre-generated?
- What's in the initial observation?

### 3. SimEnv.step() Analysis

Document step behavior:

```
step(action) -> (obs, reward, terminated, truncated, info)
  |
  v
Handle path routing via step_helper.handle_step(action)
  - path_agent.get_route(route_obj, action)
  - Sets rl_props.chosen_path_list
  |
  v
Process releases via rl_help_obj.handle_releases()
  |
  v
Allocate via rl_help_obj.allocate()
  - Calls engine_obj.handle_arrival()
  |
  v
Compute reward
  - if was_allocated: reward = engine_props["reward"]
  - else: reward = engine_props["penalty"]
  |
  v
Increment arrival_count
  |
  v
Get next observation via step_helper.get_obs()
  |
  v
Check termination
  - terminated = (arrival_count == num_requests)
  |
  v
Return (obs, reward, terminated, False, {})  # Note: no action_mask!
```

Document:
- How is path selection communicated?
- When are releases processed?
- What triggers termination?

### 4. Observation Generation

Document `SimEnvObs.get_drl_obs()`:

```python
def get_drl_obs(bandwidth, holding_time) -> dict:
    # 1. Get current request from arrival_list
    current_req = rl_props.arrival_list[arrival_count]

    # 2. Update mock SDN with request info
    rl_props.mock_sdn_dict = update_mock_sdn(current_req)

    # 3. Get k-shortest paths
    route_obj.get_route()  # Populates route_props.paths_matrix

    # 4. For each path, compute features
    for path in paths_matrix:
        congestion = find_path_congestion(path)
        available = compute_available_slots(path)
        slots_needed = get_slots_for_path(path, bandwidth)

    # 5. Build observation dict
    return {
        "source": one_hot(source, num_nodes),
        "destination": one_hot(destination, num_nodes),
        "holding_time": normalize(holding_time),
        "slots_needed": array(slots_per_path),
        "path_lengths": array(hops_per_path),
        "paths_cong": array(congestion_per_path),
        "available_slots": array(available_per_path),
    }
```

Document:
- What routing algorithm is used?
- How is congestion computed?
- What normalization is applied?

### 5. Observation Space Definition

Document `get_obs_space()`:

```python
# From fusion/modules/rl/utils/deep_rl.py
def get_obs_space(engine_props, rl_props, route_obj):
    num_nodes = len(topology.nodes)
    k_paths = engine_props["k_paths"]
    num_bw = len(bandwidth_options)

    return spaces.Dict({
        "source": spaces.Box(0, 1, (num_nodes,), np.float32),
        "destination": spaces.Box(0, 1, (num_nodes,), np.float32),
        "request_bandwidth": spaces.Box(0, 1, (num_bw,), np.float32),
        "holding_time": spaces.Box(0, 1, (1,), np.float32),
        "slots_needed": spaces.Box(-1, max_slots, (k_paths,), np.float32),
        "path_lengths": spaces.Box(0, max_hops, (k_paths,), np.float32),
        "paths_cong": spaces.Box(0, 1, (k_paths,), np.float32),
        "available_slots": spaces.Box(0, 1, (k_paths,), np.float32),
    })
```

### 6. Action Space Definition

Document `get_action_space()`:

```python
def get_action_space(engine_props):
    k_paths = engine_props["k_paths"]
    return spaces.Discrete(k_paths)
```

### 7. Reward Configuration

Document reward/penalty values:

| Parameter | Source | Default Value |
|-----------|--------|---------------|
| `reward` | `engine_props["reward"]` | +1.0 |
| `penalty` | `engine_props["penalty"]` | -1.0 |
| Dynamic reward | `engine_props["dynamic_reward"]` | False |
| Decay factor | `engine_props["decay_factor"]` | 0.0 |

### 8. Action Masking Status

**Important Finding:** Legacy SimEnv does NOT implement action masking in `info` dict.

- `reset()` returns `(obs, {})` - empty info
- `step()` returns `(obs, reward, terminated, False, {})` - empty info

Action validity is learned through reward signal, not explicit masking.

### 9. Differences for UnifiedSimEnv

| Feature | GeneralSimEnv | UnifiedSimEnv |
|---------|---------------|---------------|
| Action mask | Not in info | In `info["action_mask"]` |
| Feasibility | From mock_handle_arrival | From spectrum_pipeline |
| State access | engine_props dict | NetworkState object |
| Allocation | engine_obj.handle_arrival | adapter.apply_action |
| Paths | paths_matrix | list[PathOption] |

### 10. Behavioral Parity Requirements

For parity validation (P4.4), ensure:

1. Same observation features (source, dest, holding_time, path features)
2. Same reward values for same outcomes
3. Same termination logic (all requests processed)
4. Same seeding produces same request sequence

Intentional differences:
1. Action mask now explicit (improves learning)
2. Feasibility from real pipeline (more accurate)
3. Allocation via orchestrator (unified code path)

## Verification

- [ ] All initialization steps documented
- [ ] reset() flow is clear
- [ ] step() flow is clear
- [ ] Observation space matches legacy exactly (for parity)
- [ ] Differences are intentional and documented

## Next Task

Proceed to **P4.2.b** to design the UnifiedSimEnv class.
