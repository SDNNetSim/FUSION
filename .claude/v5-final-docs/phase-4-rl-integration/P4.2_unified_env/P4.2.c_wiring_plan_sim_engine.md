# Task ID: P4.2.c - Wiring Plan: SimulationEngine Integration

**Sub-phase:** P4.2
**Scope:** Phase 4 - RL Integration only
**Task type:** wiring-plan

## Purpose

Plan the integration between `UnifiedSimEnv` and `SimulationEngine`, including required modifications to the engine to support RL episode lifecycle.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.2_unified_env/P4.2.b_design_unified_env.md`
- `fusion/core/simulation.py` (SimulationEngine class)
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.index.md`

## Outputs

### 1. Integration Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      UnifiedSimEnv                          │
│  - Manages episode lifecycle (reset, step)                  │
│  - Builds observations from domain objects                  │
│  - Returns Gymnasium-compliant tuples                       │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      │ owns
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                   SimulationEngine                          │
│  - Owns NetworkState                                        │
│  - Owns request queue                                       │
│  - Manages release events                                   │
└──────────┬─────────────────────┬────────────────────────────┘
           │                     │
           │ creates             │ provides
           ▼                     ▼
┌──────────────────┐   ┌─────────────────────────────────────┐
│  PipelineFactory │   │          NetworkState               │
│  → PipelineSet   │   │  - Spectrum matrices                │
│                  │   │  - Lightpath tracking               │
└────────┬─────────┘   │  - Topology                         │
         │             └─────────────────────────────────────┘
         │ creates
         ▼
┌─────────────────────────────────────────────────────────────┐
│                    SDNOrchestrator                          │
│  - handle_arrival(request, state, forced_path)              │
│  - Exposes routing_pipeline, spectrum_pipeline              │
└─────────────────────────────────────────────────────────────┘
```

### 2. Required SimulationEngine Modifications

#### 2.1 New Method: get_next_request()

```python
def get_next_request(self) -> Request | None:
    """Get the next request to process.

    Returns:
        Next Request object, or None if all requests processed.

    Note:
        This method is idempotent until step() processes the request.
        Multiple calls return the same request.
    """
    if self._request_index >= len(self._requests):
        return None
    return self._requests[self._request_index]
```

#### 2.2 New Method: process_releases_until()

```python
def process_releases_until(self, time: float) -> None:
    """Process all release events due before given time.

    Args:
        time: Process releases with depart_time < time

    This method:
    1. Finds all lightpaths with depart_time < time
    2. Releases spectrum for each
    3. Updates NetworkState
    """
    while self._release_queue and self._release_queue[0].depart_time < time:
        release_event = heapq.heappop(self._release_queue)
        self._process_release(release_event)
```

#### 2.3 New Method: record_allocation_result()

```python
def record_allocation_result(
    self,
    request: Request,
    result: AllocationResult,
) -> None:
    """Record allocation result for statistics.

    Args:
        request: Request that was processed
        result: Allocation result from orchestrator

    Updates:
    - Request status tracking
    - Statistics counters (success, blocked)
    - If success, schedules release event
    """
    if result.success:
        self._stats.record_success(request)
        self._schedule_release(request, result)
    else:
        self._stats.record_block(request, result.block_reason)

    self._request_index += 1
```

#### 2.4 New Property: num_requests

```python
@property
def num_requests(self) -> int:
    """Total number of requests in this episode."""
    return len(self._requests)
```

#### 2.5 Modified: init_iteration()

```python
def init_iteration(self, seed: int) -> None:
    """Initialize for new iteration/episode.

    Args:
        seed: Random seed for reproducibility

    Resets:
    - Random number generator
    - Request queue
    - Release queue
    - Network state
    - Statistics
    """
    self._rng = np.random.default_rng(seed)
    self._requests = []
    self._release_queue = []
    self._request_index = 0
    self._network_state.reset()
    self._stats.reset()
```

### 3. Request Queue Management

```python
class SimulationEngine:
    """Request queue for RL mode."""

    def __init__(self, config: SimulationConfig):
        self._requests: list[Request] = []
        self._request_index: int = 0
        self._release_queue: list[ReleaseEvent] = []

    def generate_requests(self) -> None:
        """Generate all requests for episode.

        Creates Request objects and stores in self._requests.
        Sorted by arrive_time.
        """
        self._requests = []
        for i in range(self._config.num_requests):
            req = self._generate_single_request(i)
            self._requests.append(req)
        self._requests.sort(key=lambda r: r.arrive_time)

    def get_next_request(self) -> Request | None:
        """Get next unprocessed request."""
        if self._request_index >= len(self._requests):
            return None
        return self._requests[self._request_index]
```

### 4. Release Event Management

```python
@dataclass
class ReleaseEvent:
    """Event for lightpath release."""
    depart_time: float
    lightpath_id: str
    request_id: int

    def __lt__(self, other: "ReleaseEvent") -> bool:
        return self.depart_time < other.depart_time


class SimulationEngine:
    """Release queue management."""

    def _schedule_release(self, request: Request, result: AllocationResult) -> None:
        """Schedule release event after successful allocation."""
        event = ReleaseEvent(
            depart_time=request.depart_time,
            lightpath_id=result.lightpath_id,
            request_id=request.id,
        )
        heapq.heappush(self._release_queue, event)

    def _process_release(self, event: ReleaseEvent) -> None:
        """Process a single release event."""
        self._orchestrator.release(event.lightpath_id, self._network_state)
        self._stats.record_release(event)

    def process_releases_until(self, time: float) -> None:
        """Process all releases due before given time."""
        while self._release_queue and self._release_queue[0].depart_time < time:
            event = heapq.heappop(self._release_queue)
            self._process_release(event)
```

### 5. NetworkState Reset

```python
class NetworkState:
    """Reset method for new episodes."""

    def reset(self) -> None:
        """Reset network state for new episode.

        Clears:
        - Spectrum allocations
        - Active lightpaths
        - Link utilization

        Preserves:
        - Topology structure
        - Configuration
        """
        self._clear_spectrum()
        self._active_lightpaths.clear()
```

### 6. Initialization Sequence

```python
# In UnifiedSimEnv.__init__()

# 1. Create engine (does NOT initialize iteration yet)
self._engine = SimulationEngine(config)

# 2. Create pipeline set (reusable across episodes)
pipeline_set = PipelineFactory.create_all(config)

# 3. Create orchestrator with pipelines
self._orchestrator = SDNOrchestrator(pipeline_set, config)

# 4. Create adapter with orchestrator reference
self._adapter = RLSimulationAdapter(self._orchestrator, config)

# 5. Engine needs orchestrator reference for releases
self._engine.set_orchestrator(self._orchestrator)
```

### 7. Reset Sequence

```python
# In UnifiedSimEnv.reset()

# 1. Initialize engine with seed
self._engine.init_iteration(seed=seed)

# 2. Create topology (populates NetworkState.topology)
self._engine.create_topology()

# 3. Generate requests (fills request queue)
self._engine.generate_requests()

# 4. Get first request
self._current_request = self._engine.get_next_request()

# 5. Get path options (uses adapter → orchestrator → pipelines)
self._current_options = self._adapter.get_path_options(
    self._current_request,
    self._engine.network_state,
)
```

### 8. Step Sequence

```python
# In UnifiedSimEnv.step(action)

# 1. Apply action (adapter → orchestrator.handle_arrival)
result = self._adapter.apply_action(
    action, self._current_request, self._engine.network_state, self._current_options
)

# 2. Record result (updates stats, schedules release if success)
self._engine.record_allocation_result(self._current_request, result)

# 3. Get next request
next_request = self._engine.get_next_request()

# 4. Process releases up to next request's arrival
if next_request is not None:
    self._engine.process_releases_until(next_request.arrive_time)
    self._current_request = next_request
    self._current_options = self._adapter.get_path_options(...)
```

### 9. Wiring Verification Tests

```python
def test_engine_provides_requests():
    """Engine provides requests in arrival order."""
    env = UnifiedSimEnv(config)
    env.reset(seed=42)

    prev_time = 0.0
    for _ in range(10):
        req = env._engine.get_next_request()
        assert req.arrive_time >= prev_time
        prev_time = req.arrive_time
        env.step(0)


def test_releases_processed_correctly():
    """Releases are processed before next arrival."""
    env = UnifiedSimEnv(config)
    env.reset(seed=42)

    # Process several requests
    for _ in range(50):
        env.step(0)

    # Some lightpaths should have been released
    # (if holding times are short enough)
    # Check spectrum is partially free


def test_seed_determinism():
    """Same seed produces same episode."""
    env1 = UnifiedSimEnv(config)
    env2 = UnifiedSimEnv(config)

    obs1, _ = env1.reset(seed=123)
    obs2, _ = env2.reset(seed=123)

    # First observation should match
    for key in obs1:
        assert np.allclose(obs1[key], obs2[key])

    # Same actions should produce same rewards
    for _ in range(20):
        _, r1, _, _, _ = env1.step(0)
        _, r2, _, _, _ = env2.step(0)
        assert r1 == r2
```

## Verification

- [ ] SimulationEngine has get_next_request() method
- [ ] SimulationEngine has process_releases_until() method
- [ ] SimulationEngine has record_allocation_result() method
- [ ] NetworkState has reset() method
- [ ] Releases are processed at correct times
- [ ] Seeding is deterministic end-to-end
- [ ] All wiring tests pass

## Next Task

Proceed to **P4.2.d** to design action masking integration.
