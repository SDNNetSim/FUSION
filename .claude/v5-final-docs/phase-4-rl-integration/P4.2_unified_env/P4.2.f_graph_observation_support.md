# Task ID: P4.2.f - Graph Observation Support

**Sub-phase:** P4.2
**Scope:** Phase 4 - RL Integration only
**Task type:** design
**Priority:** High (blocks GNN-based policy migration)

## Purpose

Extend `UnifiedSimEnv` to support graph-structured observations required by GNN-based feature extractors (Graphormer, PathGNN, PathGNNCached).

## Context

Legacy `GeneralSimEnv` supports graph observations via `obs_*_graph` configuration:
```python
# From fusion/modules/rl/utils/observation_space.py
if include_graph:
    obs_space_dict.update({
        "x": spaces.Box(...),         # Node features
        "edge_index": spaces.Box(...), # Edge connectivity
        "edge_attr": spaces.Box(...),  # Edge attributes
        "path_masks": spaces.Box(...), # Path-to-edge mappings
    })
```

These are consumed by:
- `fusion/modules/rl/feat_extrs/graphormer.py`
- `fusion/modules/rl/feat_extrs/path_gnn.py`
- `fusion/modules/rl/feat_extrs/path_gnn_cached.py`

## Outputs

### 1. Graph Observation Configuration

Add graph observation mode to `SimulationConfig`:

```python
@dataclass
class RLConfig:
    """RL-specific configuration."""

    # Observation space configuration
    obs_space: str = "obs_7"  # obs_1 through obs_8
    include_graph: bool = False  # Enable graph observations

    # Graph feature dimensions
    node_feature_dim: int = 4
    edge_feature_dim: int = 2
```

### 2. Graph Observation Builder

Add to `UnifiedSimEnv`:

```python
class UnifiedSimEnv(gym.Env):
    """Extended with graph observation support."""

    def __init__(
        self,
        config: "SimulationConfig",
        render_mode: str | None = None,
    ) -> None:
        super().__init__()
        self._config = config
        self._include_graph = config.rl.include_graph

        # ... existing init ...

        # Initialize graph structures if needed
        if self._include_graph:
            self._init_graph_structures()

    def _init_graph_structures(self) -> None:
        """Initialize static graph structures from topology."""
        from fusion.modules.rl.utils.topology import convert_networkx_topo

        topology = self._engine.topology
        self._edge_index, self._edge_attr, self._node_features, _ = (
            convert_networkx_topo(topology, as_directed=True)
        )

        self._num_edges = self._edge_index.shape[1]
        self._path_encoder = PathEncoder(
            edge_index=self._edge_index,
            num_nodes=self._config.num_nodes,
        )

    def _setup_spaces(self) -> None:
        """Initialize observation and action spaces."""
        # Base observation space
        obs_space_dict = self._get_base_obs_space()

        # Add graph observations if enabled
        if self._include_graph:
            obs_space_dict.update(self._get_graph_obs_space())

        self.observation_space = spaces.Dict(obs_space_dict)
        self.action_space = spaces.Discrete(self._config.k_paths)

    def _get_base_obs_space(self) -> dict[str, spaces.Space]:
        """Get base observation space based on obs_space config."""
        from fusion.modules.rl.args.observation_args import OBS_DICT

        num_nodes = self._config.num_nodes
        k_paths = self._config.k_paths
        max_slots = self._config.spectral_slots

        obs_key = self._config.rl.obs_space
        obs_features = OBS_DICT.get(obs_key, OBS_DICT["obs_7"])

        feature_space_map = {
            "source": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(num_nodes,), dtype=np.float32
            ),
            "destination": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(num_nodes,), dtype=np.float32
            ),
            "request_bandwidth": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(self._num_bandwidth_classes,), dtype=np.float32
            ),
            "holding_time": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(1,), dtype=np.float32
            ),
            "slots_needed": lambda: spaces.Box(
                low=-1.0, high=float(max_slots), shape=(k_paths,), dtype=np.float32
            ),
            "path_lengths": lambda: spaces.Box(
                low=0.0, high=float(num_nodes), shape=(k_paths,), dtype=np.float32
            ),
            "paths_cong": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(k_paths,), dtype=np.float32
            ),
            "congestion": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(k_paths,), dtype=np.float32
            ),
            "available_slots": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(k_paths,), dtype=np.float32
            ),
            "is_feasible": lambda: spaces.Box(
                low=0.0, high=1.0, shape=(k_paths,), dtype=np.float32
            ),
        }

        return {
            feature: space_fn()
            for feature, space_fn in feature_space_map.items()
            if feature in obs_features
        }

    def _get_graph_obs_space(self) -> dict[str, spaces.Space]:
        """Get graph observation space components."""
        num_nodes = self._config.num_nodes
        num_edges = self._num_edges
        k_paths = self._config.k_paths
        node_dim = self._config.rl.node_feature_dim
        edge_dim = self._config.rl.edge_feature_dim

        return {
            "x": spaces.Box(
                low=-np.inf,
                high=np.inf,
                shape=(num_nodes, node_dim),
                dtype=np.float32,
            ),
            "edge_index": spaces.Box(
                low=0,
                high=num_nodes - 1,
                shape=(2, num_edges),
                dtype=np.int64,
            ),
            "edge_attr": spaces.Box(
                low=-np.inf,
                high=np.inf,
                shape=(num_edges, edge_dim),
                dtype=np.float32,
            ),
            "path_masks": spaces.Box(
                low=0.0,
                high=1.0,
                shape=(k_paths, num_edges),
                dtype=np.float32,
            ),
        }

    def _build_observation(self) -> dict[str, np.ndarray]:
        """Build observation dict from current state."""
        if self._current_request is None:
            return self._zero_observation()

        # Build base observation
        obs = self._adapter.build_observation(
            request=self._current_request,
            options=self._current_options,
            network_state=self._engine.network_state,
        )

        # Add graph observations if enabled
        if self._include_graph:
            obs.update(self._build_graph_observation())

        return obs

    def _build_graph_observation(self) -> dict[str, np.ndarray]:
        """Build graph-structured observation components."""
        # Node features: current utilization per node
        x = self._compute_node_features()

        # Edge attributes: current utilization per edge
        edge_attr = self._compute_edge_features()

        # Path masks: binary masks showing which edges each path uses
        path_masks = self._compute_path_masks()

        return {
            "x": x,
            "edge_index": self._edge_index,
            "edge_attr": edge_attr,
            "path_masks": path_masks,
        }

    def _compute_node_features(self) -> np.ndarray:
        """Compute node feature matrix.

        Features per node:
        - Degree (normalized)
        - Average incident link utilization
        - Is source (binary)
        - Is destination (binary)
        """
        num_nodes = self._config.num_nodes
        node_dim = self._config.rl.node_feature_dim
        x = np.zeros((num_nodes, node_dim), dtype=np.float32)

        topology = self._engine.topology
        network_state = self._engine.network_state

        for i in range(num_nodes):
            node_id = str(i)

            # Degree (normalized by max degree)
            degree = topology.degree(node_id)
            max_degree = max(dict(topology.degree()).values())
            x[i, 0] = degree / max_degree if max_degree > 0 else 0

            # Average incident link utilization
            neighbors = list(topology.neighbors(node_id))
            if neighbors:
                utils = [
                    network_state.get_link_utilization(node_id, n)
                    for n in neighbors
                ]
                x[i, 1] = np.mean(utils)

            # Is source/destination for current request
            if self._current_request is not None:
                x[i, 2] = 1.0 if i == self._current_request.source else 0.0
                x[i, 3] = 1.0 if i == self._current_request.destination else 0.0

        return x

    def _compute_edge_features(self) -> np.ndarray:
        """Compute edge feature matrix.

        Features per edge:
        - Link utilization
        - Link weight (normalized)
        """
        num_edges = self._num_edges
        edge_dim = self._config.rl.edge_feature_dim
        edge_attr = np.zeros((num_edges, edge_dim), dtype=np.float32)

        network_state = self._engine.network_state
        topology = self._engine.topology

        # Get max weight for normalization
        weights = [d.get("weight", 1.0) for _, _, d in topology.edges(data=True)]
        max_weight = max(weights) if weights else 1.0

        for e in range(num_edges):
            src_idx = int(self._edge_index[0, e])
            dst_idx = int(self._edge_index[1, e])
            src = str(src_idx)
            dst = str(dst_idx)

            # Utilization
            edge_attr[e, 0] = network_state.get_link_utilization(src, dst)

            # Normalized weight
            edge_data = topology.get_edge_data(src, dst, default={})
            weight = edge_data.get("weight", 1.0)
            edge_attr[e, 1] = weight / max_weight

        return edge_attr

    def _compute_path_masks(self) -> np.ndarray:
        """Compute path-to-edge masks.

        Returns binary matrix [k_paths, num_edges] where 1 indicates
        the edge is used by the path.
        """
        k_paths = self._config.k_paths
        num_edges = self._num_edges
        path_masks = np.zeros((k_paths, num_edges), dtype=np.float32)

        for i, opt in enumerate(self._current_options):
            if i >= k_paths:
                break
            path_masks[i] = self._path_encoder.encode_path(opt.path)

        return path_masks


class PathEncoder:
    """Encodes paths as edge masks."""

    def __init__(self, edge_index: np.ndarray, num_nodes: int) -> None:
        """Initialize path encoder.

        Args:
            edge_index: [2, num_edges] edge index array
            num_nodes: Number of nodes in graph
        """
        self._edge_index = edge_index
        self._num_edges = edge_index.shape[1]

        # Build edge lookup: (src, dst) -> edge_index
        self._edge_lookup: dict[tuple[int, int], int] = {}
        for e in range(self._num_edges):
            src = int(edge_index[0, e])
            dst = int(edge_index[1, e])
            self._edge_lookup[(src, dst)] = e

    def encode_path(self, path: tuple[str, ...]) -> np.ndarray:
        """Encode path as binary edge mask.

        Args:
            path: Tuple of node IDs as strings

        Returns:
            Binary array [num_edges] with 1s for used edges
        """
        mask = np.zeros(self._num_edges, dtype=np.float32)

        for i in range(len(path) - 1):
            src = int(path[i])
            dst = int(path[i + 1])

            # Check both directions (for undirected interpretation)
            if (src, dst) in self._edge_lookup:
                mask[self._edge_lookup[(src, dst)]] = 1.0
            elif (dst, src) in self._edge_lookup:
                mask[self._edge_lookup[(dst, src)]] = 1.0

        return mask
```

### 3. Configurable Observation Space

Update `UnifiedSimEnv` to support obs_1 through obs_8:

```python
def _get_observation_features(self) -> list[str]:
    """Get list of features for configured observation space."""
    from fusion.modules.rl.args.observation_args import OBS_DICT

    obs_key = self._config.rl.obs_space
    if obs_key.endswith("_graph"):
        obs_key = obs_key.replace("_graph", "")

    return OBS_DICT.get(obs_key, OBS_DICT["obs_7"])
```

### 4. Graph-Aware Wrapper

For SB3 integration with graph observations:

```python
class GraphObsWrapper(gym.Wrapper):
    """Wrapper that flattens graph observations for standard SB3 policies.

    Use this when using standard MLP policies with graph-enabled environments.
    For GNN policies, use the unwrapped environment directly.
    """

    def __init__(self, env: gym.Env) -> None:
        super().__init__(env)
        self._setup_flat_space()

    def _setup_flat_space(self) -> None:
        """Create flattened observation space."""
        orig_space = self.env.observation_space

        # Calculate flat size
        flat_size = 0
        for key, space in orig_space.spaces.items():
            if key in ("x", "edge_index", "edge_attr", "path_masks"):
                # Flatten graph components
                flat_size += np.prod(space.shape)
            else:
                flat_size += np.prod(space.shape)

        self.observation_space = spaces.Box(
            low=-np.inf,
            high=np.inf,
            shape=(flat_size,),
            dtype=np.float32,
        )

    def reset(self, **kwargs):
        obs, info = self.env.reset(**kwargs)
        return self._flatten_obs(obs), info

    def step(self, action):
        obs, reward, term, trunc, info = self.env.step(action)
        return self._flatten_obs(obs), reward, term, trunc, info

    def _flatten_obs(self, obs: dict[str, np.ndarray]) -> np.ndarray:
        """Flatten observation dict to vector."""
        parts = []
        for key in sorted(obs.keys()):
            parts.append(obs[key].flatten())
        return np.concatenate(parts)
```

### 5. Usage Examples

#### Standard (no graph):
```python
config = SimulationConfig.from_file("config.ini")
config.rl.obs_space = "obs_7"
config.rl.include_graph = False

env = UnifiedSimEnv(config)
model = PPO("MultiInputPolicy", env)
```

#### With graph observations (GNN policy):
```python
config = SimulationConfig.from_file("config.ini")
config.rl.obs_space = "obs_7"
config.rl.include_graph = True

env = UnifiedSimEnv(config)
# Use custom GNN policy
model = PPO(GNNPolicy, env)
```

#### With graph observations (flattened for MLP):
```python
config = SimulationConfig.from_file("config.ini")
config.rl.include_graph = True

env = UnifiedSimEnv(config)
env = GraphObsWrapper(env)  # Flatten for MLP
model = PPO("MlpPolicy", env)
```

### 6. Compatibility with Legacy Feature Extractors

The graph observations are compatible with:

| Feature Extractor | Compatible | Notes |
|-------------------|------------|-------|
| `Graphormer` | Yes | Uses x, edge_index, edge_attr |
| `PathGNN` | Yes | Uses x, edge_index, path_masks |
| `PathGNNCached` | Yes | Same as PathGNN with caching |
| Standard MLP | Via wrapper | Use GraphObsWrapper |

## Verification

- [ ] Graph observation space correctly defined
- [ ] Node features computed correctly
- [ ] Edge features computed correctly
- [ ] Path masks encode paths correctly
- [ ] Observation shapes match legacy env
- [ ] GNN feature extractors work with new env
- [ ] GraphObsWrapper flattens correctly

## Next Task

Proceed to **P4.2.g: Configurable Observation Space Selection**.
