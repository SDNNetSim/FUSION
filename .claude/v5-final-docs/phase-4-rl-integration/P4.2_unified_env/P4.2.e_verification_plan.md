# Task ID: P4.2.e - Verification Plan: UnifiedSimEnv

**Sub-phase:** P4.2
**Scope:** Phase 4 - RL Integration only
**Task type:** verification-plan

## Purpose

Define comprehensive tests for `UnifiedSimEnv` to ensure Gymnasium compliance, correct behavior, and proper integration with the V4 simulation stack.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.2_unified_env/P4.2.b_design_unified_env.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.2_unified_env/P4.2.c_wiring_plan_sim_engine.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.2_unified_env/P4.2.d_action_masking_design.md`
- `.claude/v4-docs/testing/phase_4_testing.md`

## Outputs

### 1. Test File Structure

```
fusion/tests/rl/
├── __init__.py
├── conftest.py                    # Shared fixtures (extended)
├── test_pathoption.py             # From P4.1
├── test_adapter.py                # From P4.1
├── test_unified_env.py            # Environment tests
├── test_unified_env_spaces.py     # Space validation tests
├── test_unified_env_episode.py    # Episode lifecycle tests
├── test_action_mask_wrapper.py    # Wrapper tests
└── test_gymnasium_compliance.py   # Gymnasium checker tests
```

### 2. Extended Fixtures (conftest.py)

```python
import pytest
import numpy as np
from unittest.mock import Mock

from fusion.rl.environments import UnifiedSimEnv
from fusion.rl.adapter import RLSimulationAdapter


@pytest.fixture
def env_config():
    """Create test configuration."""
    config = Mock()
    config.num_nodes = 14
    config.k_paths = 3
    config.spectral_slots = 320
    config.max_holding_time = 100.0
    config.num_requests = 100
    config.rl_success_reward = 1.0
    config.rl_block_penalty = -1.0
    config.rl_grooming_bonus = 0.1
    config.rl_slicing_penalty = -0.05
    config.rl_bandwidth_weighted = False
    return config


@pytest.fixture
def env(env_config):
    """Create UnifiedSimEnv instance."""
    return UnifiedSimEnv(env_config)


@pytest.fixture
def reset_env(env):
    """Environment after reset."""
    env.reset(seed=42)
    return env
```

### 3. Gymnasium Compliance Tests (test_gymnasium_compliance.py)

```python
import pytest
from gymnasium.utils.env_checker import check_env

from fusion.rl.environments import UnifiedSimEnv


class TestGymnasiumCompliance:
    """Tests for Gymnasium API compliance."""

    def test_env_checker_passes(self, env):
        """Environment should pass gymnasium env_checker."""
        # This runs comprehensive checks on the environment
        check_env(env, warn=True, skip_render_check=True)

    def test_has_observation_space(self, env):
        """Environment must have observation_space."""
        assert hasattr(env, 'observation_space')
        assert env.observation_space is not None

    def test_has_action_space(self, env):
        """Environment must have action_space."""
        assert hasattr(env, 'action_space')
        assert env.action_space is not None

    def test_reset_returns_tuple(self, env):
        """reset() must return (obs, info) tuple."""
        result = env.reset(seed=42)
        assert isinstance(result, tuple)
        assert len(result) == 2

    def test_reset_obs_matches_space(self, env):
        """reset() observation must match observation_space."""
        obs, _ = env.reset(seed=42)
        assert env.observation_space.contains(obs)

    def test_step_returns_5_tuple(self, reset_env):
        """step() must return 5-tuple."""
        result = reset_env.step(0)
        assert isinstance(result, tuple)
        assert len(result) == 5

    def test_step_obs_matches_space(self, reset_env):
        """step() observation must match observation_space."""
        obs, _, _, _, _ = reset_env.step(0)
        assert reset_env.observation_space.contains(obs)

    def test_step_reward_is_float(self, reset_env):
        """step() reward must be numeric."""
        _, reward, _, _, _ = reset_env.step(0)
        assert isinstance(reward, (int, float))

    def test_step_terminated_is_bool(self, reset_env):
        """step() terminated must be bool."""
        _, _, terminated, _, _ = reset_env.step(0)
        assert isinstance(terminated, bool)

    def test_step_truncated_is_bool(self, reset_env):
        """step() truncated must be bool."""
        _, _, _, truncated, _ = reset_env.step(0)
        assert isinstance(truncated, bool)

    def test_step_info_is_dict(self, reset_env):
        """step() info must be dict."""
        _, _, _, _, info = reset_env.step(0)
        assert isinstance(info, dict)
```

### 4. Observation Space Tests (test_unified_env_spaces.py)

```python
import pytest
import numpy as np
from gymnasium import spaces


class TestObservationSpace:
    """Tests for observation space definition."""

    def test_observation_space_is_dict(self, env):
        """Observation space should be Dict."""
        assert isinstance(env.observation_space, spaces.Dict)

    def test_observation_space_keys(self, env):
        """Observation space should have expected keys."""
        expected_keys = {
            "source", "destination", "holding_time",
            "slots_needed", "path_lengths", "congestion",
            "available_slots", "is_feasible"
        }
        assert set(env.observation_space.spaces.keys()) == expected_keys

    def test_source_shape(self, env, env_config):
        """Source should be one-hot of num_nodes."""
        space = env.observation_space["source"]
        assert space.shape == (env_config.num_nodes,)

    def test_destination_shape(self, env, env_config):
        """Destination should be one-hot of num_nodes."""
        space = env.observation_space["destination"]
        assert space.shape == (env_config.num_nodes,)

    def test_path_features_shape(self, env, env_config):
        """Path features should have shape (k_paths,)."""
        for key in ["slots_needed", "path_lengths", "congestion",
                    "available_slots", "is_feasible"]:
            space = env.observation_space[key]
            assert space.shape == (env_config.k_paths,), f"Failed for {key}"


class TestActionSpace:
    """Tests for action space definition."""

    def test_action_space_is_discrete(self, env):
        """Action space should be Discrete."""
        assert isinstance(env.action_space, spaces.Discrete)

    def test_action_space_size(self, env, env_config):
        """Action space size should be k_paths."""
        assert env.action_space.n == env_config.k_paths
```

### 5. Episode Lifecycle Tests (test_unified_env_episode.py)

```python
import pytest
import numpy as np


class TestEpisodeReset:
    """Tests for episode reset behavior."""

    def test_reset_returns_observation(self, env):
        """reset() should return valid observation."""
        obs, info = env.reset(seed=42)
        assert obs is not None
        assert all(key in obs for key in env.observation_space.spaces)

    def test_reset_returns_action_mask(self, env):
        """reset() info should contain action_mask."""
        _, info = env.reset(seed=42)
        assert "action_mask" in info
        assert isinstance(info["action_mask"], np.ndarray)

    def test_reset_with_seed_is_deterministic(self, env):
        """Same seed should produce same observation."""
        obs1, _ = env.reset(seed=123)
        obs2, _ = env.reset(seed=123)

        for key in obs1:
            assert np.allclose(obs1[key], obs2[key])

    def test_different_seeds_produce_different_obs(self, env):
        """Different seeds should produce different observations."""
        obs1, _ = env.reset(seed=1)
        obs2, _ = env.reset(seed=999)

        # At least source or destination should differ
        different = (
            not np.allclose(obs1["source"], obs2["source"]) or
            not np.allclose(obs1["destination"], obs2["destination"])
        )
        assert different


class TestEpisodeStep:
    """Tests for episode step behavior."""

    def test_step_advances_episode(self, reset_env):
        """step() should advance to next request."""
        _, info1 = reset_env.reset(seed=42)
        initial_idx = info1["request_index"]

        reset_env.step(0)
        info2 = reset_env._build_info()

        assert info2["request_index"] == initial_idx + 1

    def test_step_returns_reward(self, reset_env):
        """step() should return non-zero reward."""
        _, reward, _, _, _ = reset_env.step(0)
        assert reward != 0  # Either success (+) or failure (-)

    def test_episode_terminates(self, env, env_config):
        """Episode should terminate after all requests."""
        env.reset(seed=42)

        for i in range(env_config.num_requests):
            _, _, terminated, _, _ = env.step(0)
            if i < env_config.num_requests - 1:
                assert not terminated
            else:
                assert terminated

    def test_step_without_reset_raises(self, env):
        """step() before reset() should raise."""
        with pytest.raises(RuntimeError):
            env.step(0)


class TestEpisodeSeeding:
    """Tests for seeding and reproducibility."""

    def test_same_seed_same_rewards(self, env):
        """Same seed and actions should produce same rewards."""
        env.reset(seed=42)
        rewards1 = [env.step(0)[1] for _ in range(10)]

        env.reset(seed=42)
        rewards2 = [env.step(0)[1] for _ in range(10)]

        assert rewards1 == rewards2

    def test_seed_affects_request_sequence(self, env):
        """Different seeds should produce different request sequences."""
        env.reset(seed=1)
        obs1, _ = env.reset(seed=1)

        env.reset(seed=2)
        obs2, _ = env.reset(seed=2)

        # Observations should differ (different requests)
        assert not np.allclose(obs1["source"], obs2["source"]) or \
               not np.allclose(obs1["destination"], obs2["destination"])
```

### 6. Action Mask Tests (test_unified_env.py)

```python
import pytest
import numpy as np


class TestActionMasking:
    """Tests for action masking behavior."""

    def test_action_mask_shape(self, reset_env, env_config):
        """Action mask should have shape (k_paths,)."""
        _, info = reset_env.reset(seed=42)
        mask = info["action_mask"]
        assert mask.shape == (env_config.k_paths,)

    def test_action_mask_is_boolean(self, reset_env):
        """Action mask should be boolean array."""
        _, info = reset_env.reset(seed=42)
        assert info["action_mask"].dtype == bool

    def test_action_mask_matches_is_feasible(self, reset_env):
        """Action mask should match is_feasible observation."""
        obs, info = reset_env.reset(seed=42)
        mask = info["action_mask"]
        is_feas = obs["is_feasible"]

        assert np.allclose(mask.astype(float), is_feas)

    def test_action_mask_updated_after_step(self, reset_env):
        """Action mask should update after step."""
        _, info1 = reset_env.reset(seed=42)
        mask1 = info1["action_mask"].copy()

        _, _, _, _, info2 = reset_env.step(0)
        mask2 = info2["action_mask"]

        # Masks may or may not differ, but should be valid
        assert mask2.shape == mask1.shape

    def test_valid_action_succeeds(self, reset_env):
        """Selecting valid action should not raise."""
        _, info = reset_env.reset(seed=42)
        mask = info["action_mask"]

        valid_actions = np.where(mask)[0]
        if len(valid_actions) > 0:
            # Should not raise
            reset_env.step(valid_actions[0])
```

### 7. ActionMaskWrapper Tests (test_action_mask_wrapper.py)

```python
import pytest
import numpy as np

from fusion.rl.environments import UnifiedSimEnv, ActionMaskWrapper


class TestActionMaskWrapper:
    """Tests for ActionMaskWrapper."""

    @pytest.fixture
    def wrapped_env(self, env_config):
        env = UnifiedSimEnv(env_config)
        return ActionMaskWrapper(env)

    def test_wrapper_preserves_spaces(self, wrapped_env, env):
        """Wrapper should preserve observation and action spaces."""
        assert wrapped_env.observation_space == env.observation_space
        assert wrapped_env.action_space == env.action_space

    def test_action_masks_before_reset_raises(self, wrapped_env):
        """action_masks() before reset should raise."""
        with pytest.raises(RuntimeError):
            wrapped_env.action_masks()

    def test_action_masks_after_reset(self, wrapped_env):
        """action_masks() after reset should return mask."""
        wrapped_env.reset(seed=42)
        mask = wrapped_env.action_masks()
        assert isinstance(mask, np.ndarray)
        assert mask.dtype == bool

    def test_action_masks_matches_info(self, wrapped_env):
        """action_masks() should match info['action_mask']."""
        _, info = wrapped_env.reset(seed=42)
        cached = wrapped_env.action_masks()
        assert np.array_equal(cached, info["action_mask"])

    def test_action_masks_updated_after_step(self, wrapped_env):
        """action_masks() should update after step."""
        wrapped_env.reset(seed=42)
        _, _, _, _, info = wrapped_env.step(0)
        cached = wrapped_env.action_masks()
        assert np.array_equal(cached, info["action_mask"])
```

### 8. Integration Tests

```python
class TestV4StackIntegration:
    """Tests for V4 simulation stack integration."""

    def test_uses_real_adapter(self, reset_env):
        """Environment should use RLSimulationAdapter."""
        assert hasattr(reset_env, 'adapter')
        assert isinstance(reset_env.adapter, RLSimulationAdapter)

    def test_network_state_changes_on_allocation(self, reset_env):
        """Successful allocation should change network state."""
        _, info = reset_env.reset(seed=42)

        # Get initial state snapshot
        initial_util = reset_env.network_state.get_total_utilization()

        # Do many steps to get at least one success
        for _ in range(20):
            mask = info["action_mask"]
            if mask.any():
                action = np.where(mask)[0][0]
                _, _, _, _, info = reset_env.step(action)

        # Utilization should have changed
        final_util = reset_env.network_state.get_total_utilization()
        assert final_util != initial_util
```

### 9. Coverage Requirements

| Module | Target Coverage |
|--------|-----------------|
| `fusion/rl/environments/unified_env.py` | >= 90% |
| `fusion/rl/environments/wrappers.py` | >= 90% |
| Total `fusion/rl/` | >= 80% |

### 10. Test Commands

```bash
# Run all P4.2 tests
pytest fusion/tests/rl/test_unified_env*.py fusion/tests/rl/test_gymnasium*.py -v

# Run with coverage
pytest fusion/tests/rl/ --cov=fusion/rl --cov-report=term-missing

# Run gymnasium compliance specifically
pytest fusion/tests/rl/test_gymnasium_compliance.py -v
```

## Verification Checklist

- [ ] Gymnasium env_checker passes
- [ ] Observation space tests pass
- [ ] Action space tests pass
- [ ] Episode lifecycle tests pass
- [ ] Action masking tests pass
- [ ] ActionMaskWrapper tests pass
- [ ] V4 integration tests pass
- [ ] Coverage >= 80%
- [ ] All tests pass with `make test-new`

## Next Sub-Phase

After P4.2 verification passes, proceed to **P4.3: Migrate Existing RL Experiments**.
