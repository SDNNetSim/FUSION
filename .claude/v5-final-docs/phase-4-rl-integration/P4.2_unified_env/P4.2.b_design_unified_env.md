# Task ID: P4.2.b - Design UnifiedSimEnv Class

**Sub-phase:** P4.2
**Scope:** Phase 4 - RL Integration only
**Task type:** design

## Purpose

Design the complete `UnifiedSimEnv` Gymnasium environment class that uses the V4 simulation stack through `RLSimulationAdapter`.

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.2_unified_env/P4.2.shared_context_env_requirements.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.2_unified_env/P4.2.a_context_extraction_general_sim_env.md`
- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.c_design_adapter_api.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.index.md`

## Outputs

### 1. UnifiedSimEnv Class Definition

Create `fusion/rl/environments/unified_env.py`:

```python
"""Unified RL environment using V4 simulation stack."""

from typing import Any, SupportsFloat
import gymnasium as gym
from gymnasium import spaces
import numpy as np

from fusion.core.simulation import SimulationEngine
from fusion.core.orchestrator import SDNOrchestrator
from fusion.core.pipeline_factory import PipelineFactory
from fusion.rl.adapter import RLSimulationAdapter, PathOption


class UnifiedSimEnv(gym.Env):
    """Gymnasium environment for optical network RSA using V4 simulation.

    This environment provides RL agents with access to the optical network
    routing and spectrum assignment problem. Unlike the legacy GeneralSimEnv,
    this environment uses the V4 simulation stack through RLSimulationAdapter,
    ensuring identical behavior between RL and non-RL simulations.

    Key Features:
    - Uses same pipelines as non-RL simulation (no code duplication)
    - Action masking via info["action_mask"] for SB3 MaskablePPO
    - Deterministic seeding for reproducibility
    - Gymnasium-compliant interface

    Observation Space:
        Dict with:
        - source: One-hot encoded source node
        - destination: One-hot encoded destination node
        - holding_time: Normalized request holding time
        - slots_needed: Spectrum slots needed per path
        - path_lengths: Hop count per path
        - congestion: Congestion metric per path
        - available_slots: Available spectrum ratio per path
        - is_feasible: Binary feasibility per path

    Action Space:
        Discrete(k_paths) - select which candidate path to use

    Example:
        config = SimulationConfig.from_file("config.ini")
        env = UnifiedSimEnv(config)

        obs, info = env.reset(seed=42)
        mask = info["action_mask"]

        action = select_valid_action(mask)
        obs, reward, terminated, truncated, info = env.step(action)
    """

    metadata = {"render_modes": []}

    def __init__(
        self,
        config: "SimulationConfig",
        render_mode: str | None = None,
    ) -> None:
        """Initialize the environment.

        Args:
            config: Simulation configuration
            render_mode: Rendering mode (not used, for Gymnasium compatibility)
        """
        super().__init__()

        self._config = config
        self.render_mode = render_mode

        # Create V4 simulation components
        self._engine = SimulationEngine(config)
        pipeline_set = PipelineFactory.create_all(config)
        self._orchestrator = SDNOrchestrator(pipeline_set, config)
        self._adapter = RLSimulationAdapter(self._orchestrator, config)

        # Episode state (set during reset)
        self._current_request: "Request | None" = None
        self._current_options: list[PathOption] = []
        self._request_index: int = 0
        self._total_requests: int = 0

        # Define spaces
        self._setup_spaces()

    def _setup_spaces(self) -> None:
        """Initialize observation and action spaces."""
        num_nodes = self._config.num_nodes
        k_paths = self._config.k_paths
        max_slots = self._config.spectral_slots

        self.observation_space = spaces.Dict({
            "source": spaces.Box(
                low=0.0, high=1.0, shape=(num_nodes,), dtype=np.float32
            ),
            "destination": spaces.Box(
                low=0.0, high=1.0, shape=(num_nodes,), dtype=np.float32
            ),
            "holding_time": spaces.Box(
                low=0.0, high=1.0, shape=(1,), dtype=np.float32
            ),
            "slots_needed": spaces.Box(
                low=-1.0, high=float(max_slots), shape=(k_paths,), dtype=np.float32
            ),
            "path_lengths": spaces.Box(
                low=0.0, high=float(num_nodes), shape=(k_paths,), dtype=np.float32
            ),
            "congestion": spaces.Box(
                low=0.0, high=1.0, shape=(k_paths,), dtype=np.float32
            ),
            "available_slots": spaces.Box(
                low=0.0, high=1.0, shape=(k_paths,), dtype=np.float32
            ),
            "is_feasible": spaces.Box(
                low=0.0, high=1.0, shape=(k_paths,), dtype=np.float32
            ),
        })

        self.action_space = spaces.Discrete(k_paths)

    def reset(
        self,
        *,
        seed: int | None = None,
        options: dict[str, Any] | None = None,
    ) -> tuple[dict[str, np.ndarray], dict[str, Any]]:
        """Reset the environment for a new episode.

        Args:
            seed: Random seed for reproducibility
            options: Additional options (unused)

        Returns:
            observation: Initial observation dict
            info: Info dict with action_mask
        """
        super().reset(seed=seed)

        # Initialize simulation with seed
        episode_seed = seed if seed is not None else 0
        self._engine.init_iteration(seed=episode_seed)
        self._engine.create_topology()
        self._engine.generate_requests()

        # Get request count
        self._total_requests = self._engine.num_requests
        self._request_index = 0

        # Get first request
        self._current_request = self._engine.get_next_request()
        if self._current_request is None:
            raise RuntimeError("No requests generated")

        # Get path options for first request
        self._current_options = self._adapter.get_path_options(
            self._current_request,
            self._engine.network_state,
        )

        # Build observation and info
        obs = self._build_observation()
        info = self._build_info()

        return obs, info

    def step(
        self,
        action: int,
    ) -> tuple[dict[str, np.ndarray], SupportsFloat, bool, bool, dict[str, Any]]:
        """Execute action and advance simulation.

        Args:
            action: Selected path index (0 to k_paths-1)

        Returns:
            observation: New observation dict
            reward: Scalar reward
            terminated: True if episode ended normally
            truncated: True if episode ended abnormally (always False)
            info: Info dict with action_mask
        """
        if self._current_request is None:
            raise RuntimeError("Must call reset() before step()")

        # Apply action via adapter
        result = self._adapter.apply_action(
            action=action,
            request=self._current_request,
            network_state=self._engine.network_state,
            options=self._current_options,
        )

        # Compute reward
        reward = self._adapter.compute_reward(result, self._current_request)

        # Record statistics
        self._engine.record_allocation_result(self._current_request, result)

        # Advance to next request
        self._request_index += 1

        # Process any releases due before next request
        if self._request_index < self._total_requests:
            next_request = self._engine.get_next_request()
            if next_request is not None:
                self._engine.process_releases_until(next_request.arrive_time)
                self._current_request = next_request
                self._current_options = self._adapter.get_path_options(
                    self._current_request,
                    self._engine.network_state,
                )
            else:
                self._current_request = None
                self._current_options = []

        # Check termination
        terminated = self._request_index >= self._total_requests

        # Build observation (may be dummy if terminated)
        obs = self._build_observation()
        info = self._build_info()

        return obs, float(reward), terminated, False, info

    def _build_observation(self) -> dict[str, np.ndarray]:
        """Build observation dict from current state.

        Returns:
            Observation dict matching observation_space
        """
        if self._current_request is None:
            # Terminal state - return zeros
            return self._zero_observation()

        return self._adapter.build_observation(
            request=self._current_request,
            options=self._current_options,
            network_state=self._engine.network_state,
        )

    def _build_info(self) -> dict[str, Any]:
        """Build info dict with action mask.

        Returns:
            Info dict with action_mask key
        """
        if self._current_request is None:
            # Terminal state - all actions masked
            mask = np.zeros(self._config.k_paths, dtype=bool)
        else:
            mask = self._adapter.get_action_mask(self._current_options)

        return {
            "action_mask": mask,
            "request_index": self._request_index,
            "total_requests": self._total_requests,
        }

    def _zero_observation(self) -> dict[str, np.ndarray]:
        """Return zero-filled observation for terminal state."""
        k = self._config.k_paths
        n = self._config.num_nodes

        return {
            "source": np.zeros(n, dtype=np.float32),
            "destination": np.zeros(n, dtype=np.float32),
            "holding_time": np.zeros(1, dtype=np.float32),
            "slots_needed": np.full(k, -1.0, dtype=np.float32),
            "path_lengths": np.zeros(k, dtype=np.float32),
            "congestion": np.zeros(k, dtype=np.float32),
            "available_slots": np.zeros(k, dtype=np.float32),
            "is_feasible": np.zeros(k, dtype=np.float32),
        }

    def render(self) -> None:
        """Render the environment (not implemented)."""
        pass

    def close(self) -> None:
        """Clean up resources."""
        pass

    # --- Properties for testing and debugging ---

    @property
    def current_request(self) -> "Request | None":
        """Current request being processed."""
        return self._current_request

    @property
    def network_state(self) -> "NetworkState":
        """Current network state."""
        return self._engine.network_state

    @property
    def adapter(self) -> RLSimulationAdapter:
        """RL simulation adapter."""
        return self._adapter
```

### 2. Package Init

Create `fusion/rl/environments/__init__.py`:

```python
"""RL environment implementations."""

from fusion.rl.environments.unified_env import UnifiedSimEnv
from fusion.rl.environments.wrappers import ActionMaskWrapper

__all__ = [
    "UnifiedSimEnv",
    "ActionMaskWrapper",
]
```

### 3. Type Annotations

Ensure these types are available:

```python
from typing import TypeAlias

ObsType: TypeAlias = dict[str, np.ndarray]
ActType: TypeAlias = int
InfoType: TypeAlias = dict[str, Any]
```

### 4. Configuration Requirements

`SimulationConfig` must provide:

```python
class SimulationConfig:
    num_nodes: int          # Number of network nodes
    k_paths: int            # Number of candidate paths
    spectral_slots: int     # Total spectrum slots per link
    max_holding_time: float # For normalization
    rl_success_reward: float
    rl_block_penalty: float
    rl_grooming_bonus: float
    rl_slicing_penalty: float
    rl_bandwidth_weighted: bool
```

### 5. SimulationEngine Requirements

`SimulationEngine` must provide these methods:

```python
class SimulationEngine:
    def init_iteration(self, seed: int) -> None: ...
    def create_topology(self) -> None: ...
    def generate_requests(self) -> None: ...
    def get_next_request(self) -> Request | None: ...
    def process_releases_until(self, time: float) -> None: ...
    def record_allocation_result(self, request: Request, result: AllocationResult) -> None: ...

    @property
    def num_requests(self) -> int: ...

    @property
    def network_state(self) -> NetworkState: ...
```

### 6. Design Decisions

| Decision | Rationale |
|----------|-----------|
| Pre-compute options in reset/step | Avoid recomputation in observation building |
| Store current_options | Needed for apply_action |
| Zero observation at terminal | Gymnasium compliance |
| Action mask always in info | SB3 MaskablePPO requirement |
| No truncation | Optical network episodes have natural end |

## Verification

- [ ] Class compiles without errors
- [ ] observation_space matches Gymnasium spec
- [ ] action_space is Discrete(k_paths)
- [ ] reset() returns (obs, info) with action_mask
- [ ] step() returns 5-tuple with action_mask in info
- [ ] Seeding is deterministic

## Next Task

Proceed to **P4.2.c** to plan wiring with SimulationEngine.
