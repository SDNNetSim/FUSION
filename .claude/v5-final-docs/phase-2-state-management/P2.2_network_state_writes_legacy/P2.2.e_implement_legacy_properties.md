# Task ID: P2.2.e - Implement Legacy Compatibility Properties

**Sub-phase:** P2.2
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement the legacy compatibility properties `network_spectrum_dict` and `lightpath_status_dict` on `NetworkState`.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.c_design_legacy_compat_properties.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.shared_context_lightpath_spectrum_shapes.md`
- `fusion/domain/network_state.py` (current state after P2.2.d)

## Outputs

### 1. Add Legacy Properties to NetworkState

Append these properties to the `NetworkState` class after the write methods:

```python
    # -------------------------------------------------------------------------
    # Legacy Compatibility Properties (P2.2)
    # WARNING: These properties are TEMPORARY MIGRATION SHIMS.
    # They will be removed in Phase 5.
    # -------------------------------------------------------------------------

    @property
    def network_spectrum_dict(self) -> dict[tuple[str, str], dict[str, Any]]:
        """
        Legacy compatibility: Returns spectrum state in sdn_props format.

        WARNING: This property is a TEMPORARY MIGRATION SHIM.
        It will be removed in Phase 5.

        Returns:
            Dictionary mapping link tuples to link state dicts.
            Format matches sdn_props.network_spectrum_dict exactly.

        Notes:
            - Both (u,v) and (v,u) return the SAME dict object
            - cores_matrix arrays are direct references (not copies)
            - Edge attributes from topology are included

        LEGACY_COMPAT: Phase 5 Removal Checklist
        Before removing this property, verify:
        [ ] All spectrum reads use NetworkState.is_spectrum_available()
        [ ] All spectrum writes use NetworkState.create_lightpath()
        [ ] No direct numpy array access outside NetworkState
        [ ] run_comparison.py passes without this property
        [ ] grep 'network_spectrum_dict' returns only this definition
        """
        result: dict[tuple[str, str], dict[str, Any]] = {}
        seen: set[frozenset[str]] = set()

        for link, link_spectrum in self._spectrum.items():
            # Avoid duplicate processing for bidirectional links
            link_set = frozenset(link)
            if link_set in seen:
                # Add reverse direction pointing to same dict
                reverse = (link[1], link[0])
                if link in result and reverse not in result:
                    result[reverse] = result[link]
                continue
            seen.add(link_set)

            # Build legacy format dict
            u, v = link
            link_dict: dict[str, Any] = {
                "cores_matrix": link_spectrum.cores_matrix,  # Direct reference
                "usage_count": link_spectrum.usage_count,
                "throughput": link_spectrum.throughput,
                "link_num": link_spectrum.link_num,
            }

            # Add edge attributes from topology
            if self._topology.has_edge(u, v):
                edge_data = self._topology.edges[u, v]
                for attr in ["length", "dispersion", "attenuation", "fiber_type"]:
                    if attr in edge_data:
                        link_dict[attr] = edge_data[attr]

            # Both directions point to same dict
            result[(u, v)] = link_dict
            result[(v, u)] = link_dict

        return result

    @property
    def lightpath_status_dict(self) -> dict[tuple[str, str], dict[int, dict[str, Any]]]:
        """
        Legacy compatibility: Returns lightpath state in sdn_props format.

        WARNING: This property is a TEMPORARY MIGRATION SHIM.
        It will be removed in Phase 5.

        Returns:
            Dictionary mapping sorted endpoint tuples to lightpath dicts.
            Format matches sdn_props.lightpath_status_dict exactly.

        Notes:
            - Keys are SORTED tuples: ("A", "C") not ("C", "A")
            - Bandwidth values are float (legacy format)
            - time_bw_usage is empty dict by default
            - Rebuilds dict on each access (not cached)

        LEGACY_COMPAT: Phase 5 Removal Checklist
        Before removing this property, verify:
        [ ] Grooming uses NetworkState.get_lightpaths_with_capacity()
        [ ] Statistics use NetworkState.iter_lightpaths()
        [ ] No manual sorted tuple key construction
        [ ] run_comparison.py passes without this property
        [ ] grep 'lightpath_status_dict' returns only this definition
        """
        result: dict[tuple[str, str], dict[int, dict[str, Any]]] = {}

        for lp_id, lp in self._lightpaths.items():
            # Key is SORTED tuple
            sorted_endpoints = sorted([lp.source, lp.destination])
            key: tuple[str, str] = (sorted_endpoints[0], sorted_endpoints[1])

            # Initialize group if needed
            if key not in result:
                result[key] = {}

            # Build legacy format entry
            result[key][lp_id] = {
                "path": lp.path,
                "lightpath_bandwidth": float(lp.total_bandwidth_gbps),
                "remaining_bandwidth": float(lp.remaining_bandwidth_gbps),
                "band": lp.band,
                "core": lp.core,
                "start_slot": lp.start_slot,
                "end_slot": lp.end_slot,
                "modulation": lp.modulation,
                "requests_dict": {
                    req_id: float(bw)
                    for req_id, bw in lp.request_allocations.items()
                },
                "time_bw_usage": {},  # Empty by default
                "is_degraded": lp.is_degraded,
            }

        return result
```

### 2. Add Required Import

Ensure `Any` is imported at top of file:

```python
from typing import TYPE_CHECKING, Any, Iterator
```

## Verification Commands

```bash
# Type checking
mypy fusion/domain/network_state.py --strict

# Linting
ruff check fusion/domain/network_state.py

# Legacy format verification test
python -c "
import networkx as nx
from fusion.domain.network_state import NetworkState

class MockConfig:
    band_list = ('c',)
    band_slots = {'c': 320}
    cores_per_link = 1
    guard_slots = 1

G = nx.Graph()
G.add_edge('A', 'B', length=100.0)
G.add_edge('B', 'C', length=150.0)

state = NetworkState(G, MockConfig())

# Test network_spectrum_dict
nsd = state.network_spectrum_dict
assert ('A', 'B') in nsd
assert ('B', 'A') in nsd
assert nsd[('A', 'B')] is nsd[('B', 'A')], 'Bidirectional must be same object'
assert 'cores_matrix' in nsd[('A', 'B')]
assert 'usage_count' in nsd[('A', 'B')]
print('network_spectrum_dict format OK')

# Test lightpath_status_dict (empty)
lsd = state.lightpath_status_dict
assert lsd == {}, 'Should be empty initially'
print('lightpath_status_dict empty OK')

# Create lightpath and test again
lp = state.create_lightpath(
    path=['C', 'B', 'A'],  # C -> A direction
    start_slot=0,
    end_slot=12,
    core=0,
    band='c',
    modulation='QPSK',
    bandwidth_gbps=100,
    path_weight_km=250.0,
    guard_slots=2,
)

lsd = state.lightpath_status_dict

# Key should be sorted: ('A', 'C'), not ('C', 'A')
assert ('A', 'C') in lsd, 'Key should be sorted tuple'
assert ('C', 'A') not in lsd, 'Unsorted key should not exist'

entry = lsd[('A', 'C')][lp.lightpath_id]
assert entry['path'] == ['C', 'B', 'A']
assert entry['lightpath_bandwidth'] == 100.0
assert isinstance(entry['lightpath_bandwidth'], float)
assert entry['requests_dict'] == {}
assert entry['time_bw_usage'] == {}
print('lightpath_status_dict with lightpath OK')

print('Legacy properties smoke test passed')
"
```

## Important Notes

### Bidirectional Link Handling

The `network_spectrum_dict` implementation ensures:
1. Each unique link is processed once
2. Both `(u,v)` and `(v,u)` entries point to the **same** dict object
3. Modifying one affects the other (matches legacy behavior)

### Sorted Tuple Keys

The `lightpath_status_dict` uses **sorted** tuples as keys:
- Lightpath from C to A gets key `("A", "C")`
- This matches legacy behavior where lookups use sorted endpoints

### Type Conversions

- Bandwidth: `int -> float` (legacy uses float)
- requests_dict values: `int -> float`

### No Caching

Both properties rebuild their dicts on each access. This ensures:
- Lightpath changes (grooming) are immediately visible
- Spectrum changes are reflected
- No stale data issues

## Testing Notes

Full testing of legacy format compatibility should include:
1. Comparing output with actual `sdn_props` during simulation
2. Verifying round-trip: create through NetworkState, read via legacy property
3. Checking edge attribute propagation

## Next Task

After implementing legacy properties, proceed to `P2.2.f_verify_write_methods.md`.
