# Task ID: P2.2.a - Map Legacy Structures

**Sub-phase:** P2.2
**Scope:** Phase 2 - State Management only
**Task type:** context-extraction

## Purpose

Create a detailed field-by-field mapping between legacy `sdn_props` structures and the new `NetworkState`/`Lightpath` classes. This mapping ensures legacy compatibility properties return exactly the right format.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.shared_context_lightpath_spectrum_shapes.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.3_lightpath_wrapper/P1.3.index.md`
- `fusion/core/properties.py` (SDNProps definition, lines 330-410)

## Outputs

### 1. lightpath_status_dict Field Mapping Table

| Legacy Field | Source | Type Conversion | Notes |
|--------------|--------|-----------------|-------|
| Key (sorted tuple) | `tuple(sorted([lp.source, lp.destination]))` | N/A | Key generation |
| `path` | `lp.path` | `list[str]` direct | No conversion |
| `lightpath_bandwidth` | `lp.total_bandwidth_gbps` | `int -> float` | Cast to float |
| `remaining_bandwidth` | `lp.remaining_bandwidth_gbps` | `int -> float` | Cast to float |
| `band` | `lp.band` | `str` direct | No conversion |
| `core` | `lp.core` | `int` direct | No conversion |
| `start_slot` | `lp.start_slot` | `int` direct | No conversion |
| `end_slot` | `lp.end_slot` | `int` direct | No conversion |
| `modulation` | `lp.modulation` | `str` direct | No conversion |
| `requests_dict` | `lp.request_allocations` | `dict[int,int] -> dict[int,float]` | Cast values to float |
| `time_bw_usage` | Computed | `dict[float, float]` | Empty dict by default |
| `is_degraded` | `lp.is_degraded` | `bool` direct | No conversion |

### 2. network_spectrum_dict Field Mapping Table

| Legacy Field | Source | Type Conversion | Notes |
|--------------|--------|-----------------|-------|
| Key | `(link[0], link[1])` | `tuple[str, str]` | Both directions |
| `cores_matrix` | `link_spectrum.cores_matrix` | Direct reference | Same arrays |
| `usage_count` | `link_spectrum.usage_count` | `int` direct | No conversion |
| `throughput` | `link_spectrum.throughput` | `float` direct | No conversion |
| `link_num` | `link_spectrum.link_num` | `int` direct | No conversion |
| `length` | `topology.edges[link]["length"]` | `float` direct | From edge data |
| `dispersion` | `topology.edges[link]["dispersion"]` | `float` direct | Optional |
| `attenuation` | `topology.edges[link]["attenuation"]` | `float` direct | Optional |

### 3. Grouping Logic for lightpath_status_dict

```python
def build_lightpath_status_dict(
    lightpaths: dict[int, Lightpath]
) -> dict[tuple[str, str], dict[int, dict[str, Any]]]:
    """
    Group lightpaths by sorted endpoint tuple.

    Logic:
    1. For each lightpath, compute sorted (src, dst) key
    2. Group lightpaths under their endpoint key
    3. For each lightpath, create legacy dict entry
    """
    result: dict[tuple[str, str], dict[int, dict[str, Any]]] = {}

    for lp_id, lp in lightpaths.items():
        # Key is sorted tuple
        key = tuple(sorted([lp.source, lp.destination]))

        # Initialize group if needed
        if key not in result:
            result[key] = {}

        # Add lightpath entry
        result[key][lp_id] = {
            "path": lp.path,
            "lightpath_bandwidth": float(lp.total_bandwidth_gbps),
            "remaining_bandwidth": float(lp.remaining_bandwidth_gbps),
            "band": lp.band,
            "core": lp.core,
            "start_slot": lp.start_slot,
            "end_slot": lp.end_slot,
            "modulation": lp.modulation,
            "requests_dict": {k: float(v) for k, v in lp.request_allocations.items()},
            "time_bw_usage": {},
            "is_degraded": lp.is_degraded,
        }

    return result
```

### 4. Link Dictionary Construction

```python
def build_network_spectrum_dict(
    spectrum: dict[tuple[str, str], LinkSpectrum],
    topology: nx.Graph,
) -> dict[tuple[str, str], dict[str, Any]]:
    """
    Build legacy network_spectrum_dict from NetworkState data.

    Logic:
    1. For each unique link (avoid duplicates from bidirectional)
    2. Get LinkSpectrum and edge attributes
    3. Build legacy dict format
    4. Add both direction keys pointing to same dict
    """
    result: dict[tuple[str, str], dict[str, Any]] = {}
    seen_links: set[frozenset[str]] = set()

    for link, link_spectrum in spectrum.items():
        # Avoid processing same link twice
        link_set = frozenset(link)
        if link_set in seen_links:
            continue
        seen_links.add(link_set)

        # Get edge attributes
        u, v = link
        edge_data = topology.edges[u, v] if topology.has_edge(u, v) else {}

        # Build legacy dict
        link_dict: dict[str, Any] = {
            "cores_matrix": link_spectrum.cores_matrix,
            "usage_count": link_spectrum.usage_count,
            "throughput": link_spectrum.throughput,
            "link_num": link_spectrum.link_num,
        }

        # Add edge attributes
        for attr in ["length", "dispersion", "attenuation", "fiber_type"]:
            if attr in edge_data:
                link_dict[attr] = edge_data[attr]

        # Both directions point to same dict
        result[(u, v)] = link_dict
        result[(v, u)] = link_dict

    return result
```

### 5. Edge Cases

| Case | Legacy Behavior | Implementation |
|------|-----------------|----------------|
| Empty lightpaths | Returns `{}` | Return empty dict |
| No edge attributes | Missing keys in dict | Only include present attributes |
| Single-node "path" | Should not happen | Validate in create_lightpath |
| Negative lightpath_id | Guard bands | Never in lightpath_status_dict |

### 6. Verification Queries

After implementation, verify with:

```python
# Compare legacy and new formats
legacy = sdn_props.lightpath_status_dict
new = network_state.lightpath_status_dict

for key in legacy:
    assert key in new, f"Missing key: {key}"
    for lp_id in legacy[key]:
        assert lp_id in new[key], f"Missing lightpath: {lp_id}"
        for field in legacy[key][lp_id]:
            legacy_val = legacy[key][lp_id][field]
            new_val = new[key][lp_id][field]
            assert legacy_val == new_val, f"Mismatch: {field}"
```

## Execution Notes

This is a **read-only analysis task**. Document the exact mappings needed for implementation in P2.2.c through P2.2.e.

Pay special attention to:
1. Type conversions (int to float for bandwidth)
2. Key generation (sorted tuples for lightpath_status_dict)
3. Bidirectional references (same dict object for both directions)
4. Optional fields (edge attributes may not exist)

## Next Task

After completing mapping analysis, proceed to `P2.2.b_design_write_methods.md`.
