# Task ID: P2.2.c - Design Legacy Compatibility Properties

**Sub-phase:** P2.2
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the legacy compatibility properties that allow existing code to access network state in the old `sdn_props` format during migration.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.shared_context_lightpath_spectrum_shapes.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.a_map_legacy_structures.md`

## Outputs

### 1. network_spectrum_dict Property Specification

```python
@property
def network_spectrum_dict(self) -> dict[tuple[str, str], dict[str, Any]]:
    """
    Legacy compatibility: Returns spectrum state in sdn_props format.

    WARNING: This property is a TEMPORARY MIGRATION SHIM.
    It will be removed in Phase 5.

    Returns:
        Dictionary mapping link tuples to link state dicts.
        Format matches sdn_props.network_spectrum_dict exactly:
        {
            (node1, node2): {
                "cores_matrix": {band: np.ndarray, ...},
                "usage_count": int,
                "throughput": float,
                "link_num": int,
                "length": float,  # From topology if present
                ...
            }
        }

    Notes:
        - Both (u,v) and (v,u) return the SAME dict object
        - cores_matrix arrays are direct references (not copies)
        - Modifying returned arrays WILL affect NetworkState
        - Edge attributes from topology are included

    LEGACY_COMPAT: Phase 5 Removal Checklist
    Before removing this property, verify:
    [ ] All spectrum reads use NetworkState.is_spectrum_available()
    [ ] All spectrum writes use NetworkState.create_lightpath()
    [ ] No direct numpy array access outside NetworkState
    [ ] run_comparison.py passes without this property
    [ ] grep 'network_spectrum_dict' returns only this definition
    """
```

### 2. lightpath_status_dict Property Specification

```python
@property
def lightpath_status_dict(self) -> dict[tuple[str, str], dict[int, dict[str, Any]]]:
    """
    Legacy compatibility: Returns lightpath state in sdn_props format.

    WARNING: This property is a TEMPORARY MIGRATION SHIM.
    It will be removed in Phase 5.

    Returns:
        Dictionary mapping sorted endpoint tuples to lightpath dicts.
        Format matches sdn_props.lightpath_status_dict exactly:
        {
            (src, dst): {  # SORTED tuple key
                lightpath_id: {
                    "path": list[str],
                    "lightpath_bandwidth": float,
                    "remaining_bandwidth": float,
                    "band": str,
                    "core": int,
                    "start_slot": int,
                    "end_slot": int,
                    "modulation": str,
                    "requests_dict": dict[int, float],
                    "time_bw_usage": dict,
                    "is_degraded": bool,
                }
            }
        }

    Notes:
        - Keys are SORTED tuples: ("A", "C") not ("C", "A")
        - Bandwidth values are float (legacy format)
        - time_bw_usage is empty dict by default
        - This builds a NEW dict on each access (not cached)

    LEGACY_COMPAT: Phase 5 Removal Checklist
    Before removing this property, verify:
    [ ] Grooming uses NetworkState.get_lightpaths_with_capacity()
    [ ] Statistics use NetworkState.iter_lightpaths()
    [ ] No manual sorted tuple key construction
    [ ] run_comparison.py passes without this property
    [ ] grep 'lightpath_status_dict' returns only this definition
    """
```

### 3. Implementation Strategy

#### network_spectrum_dict Implementation

```python
@property
def network_spectrum_dict(self) -> dict[tuple[str, str], dict[str, Any]]:
    # LEGACY_COMPAT: Phase 5 Removal - See docstring for checklist

    result: dict[tuple[str, str], dict[str, Any]] = {}
    seen: set[frozenset[str]] = set()

    for link, link_spectrum in self._spectrum.items():
        # Avoid duplicate processing
        link_set = frozenset(link)
        if link_set in seen:
            # Just add reverse direction pointing to same dict
            reverse = (link[1], link[0])
            if reverse not in result:
                result[reverse] = result[link]
            continue
        seen.add(link_set)

        # Build legacy format dict
        u, v = link
        link_dict: dict[str, Any] = {
            "cores_matrix": link_spectrum.cores_matrix,  # Direct reference
            "usage_count": link_spectrum.usage_count,
            "throughput": link_spectrum.throughput,
            "link_num": link_spectrum.link_num,
        }

        # Add edge attributes from topology
        if self._topology.has_edge(u, v):
            edge_data = self._topology.edges[u, v]
            for attr in ["length", "dispersion", "attenuation", "fiber_type"]:
                if attr in edge_data:
                    link_dict[attr] = edge_data[attr]

        # Both directions point to same dict
        result[link] = link_dict
        result[(v, u)] = link_dict

    return result
```

#### lightpath_status_dict Implementation

```python
@property
def lightpath_status_dict(self) -> dict[tuple[str, str], dict[int, dict[str, Any]]]:
    # LEGACY_COMPAT: Phase 5 Removal - See docstring for checklist

    result: dict[tuple[str, str], dict[int, dict[str, Any]]] = {}

    for lp_id, lp in self._lightpaths.items():
        # Key is SORTED tuple
        key = tuple(sorted([lp.source, lp.destination]))
        # Type assertion for mypy
        key = (key[0], key[1])

        # Initialize group if needed
        if key not in result:
            result[key] = {}

        # Build legacy format entry
        result[key][lp_id] = {
            "path": lp.path,
            "lightpath_bandwidth": float(lp.total_bandwidth_gbps),
            "remaining_bandwidth": float(lp.remaining_bandwidth_gbps),
            "band": lp.band,
            "core": lp.core,
            "start_slot": lp.start_slot,
            "end_slot": lp.end_slot,
            "modulation": lp.modulation,
            "requests_dict": {
                req_id: float(bw)
                for req_id, bw in lp.request_allocations.items()
            },
            "time_bw_usage": {},  # Empty by default
            "is_degraded": lp.is_degraded,
        }

    return result
```

### 4. Caching Considerations

**network_spectrum_dict:**
- Could cache since structure rarely changes
- But arrays are mutable, so callers see updates
- Decision: **No caching** - build on access for simplicity

**lightpath_status_dict:**
- Must NOT cache - lightpaths change frequently
- Bandwidth values change during grooming
- Decision: **Always rebuild** on access

### 5. Performance Notes

| Property | Cost | Frequency |
|----------|------|-----------|
| `network_spectrum_dict` | O(links) | Rarely accessed in new code |
| `lightpath_status_dict` | O(lightpaths) | May be called frequently during grooming |

For Phase 2, performance is acceptable. Legacy callers will migrate to direct methods in later phases.

### 6. Testing Requirements

```python
def test_network_spectrum_dict_bidirectional():
    """Both directions return same dict object."""
    state = NetworkState(topology, config)
    nsd = state.network_spectrum_dict

    assert nsd[("A", "B")] is nsd[("B", "A")]

def test_network_spectrum_dict_arrays_shared():
    """Arrays are direct references, not copies."""
    state = NetworkState(topology, config)
    nsd = state.network_spectrum_dict

    # Modify through one reference
    nsd[("A", "B")]["cores_matrix"]["c"][0, 0] = 99

    # Visible through other reference
    assert nsd[("B", "A")]["cores_matrix"]["c"][0, 0] == 99

    # Also visible in NetworkState
    ls = state.get_link_spectrum(("A", "B"))
    assert ls.cores_matrix["c"][0, 0] == 99

def test_lightpath_status_dict_sorted_keys():
    """Keys are sorted tuples regardless of lightpath direction."""
    state = NetworkState(topology, config)

    # Create lightpath from C to A
    lp = state.create_lightpath(
        path=["C", "B", "A"],  # C -> A direction
        ...
    )

    lsd = state.lightpath_status_dict

    # Key should be ("A", "C"), not ("C", "A")
    assert ("A", "C") in lsd
    assert ("C", "A") not in lsd

def test_lightpath_status_dict_float_bandwidth():
    """Bandwidth values are float, not int."""
    state = NetworkState(topology, config)
    lp = state.create_lightpath(bandwidth_gbps=100, ...)

    lsd = state.lightpath_status_dict
    key = tuple(sorted([lp.source, lp.destination]))

    entry = lsd[key][lp.lightpath_id]
    assert isinstance(entry["lightpath_bandwidth"], float)
    assert entry["lightpath_bandwidth"] == 100.0
```

### 7. Migration Path Documentation

Include in module docstring:

```python
"""
Legacy Compatibility Properties
===============================

These properties exist ONLY for migration compatibility with existing
code that accesses sdn_props.network_spectrum_dict and
sdn_props.lightpath_status_dict.

Migration Path:
1. Phase 2: Properties added to NetworkState
2. Phase 3: Adapters use NetworkState directly
3. Phase 4: Most legacy code migrated
4. Phase 5: Properties removed, all code uses NetworkState methods

Replacement Methods:
- network_spectrum_dict[link] -> state.get_link_spectrum(link)
- network_spectrum_dict[link]["cores_matrix"] -> link_spectrum.cores_matrix
- lightpath_status_dict[key][id] -> state.get_lightpath(id)
- lightpath_status_dict[key].values() -> state.get_lightpaths_between(src, dst)
"""
```

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.2.e.

Key considerations:
1. Exact format matching is critical for compatibility
2. Document removal path clearly in code
3. Include removal checklist in docstrings
4. Test bidirectional and sorted key behaviors

## Next Task

After completing this design, proceed to `P2.2.d_implement_write_methods.md`.
