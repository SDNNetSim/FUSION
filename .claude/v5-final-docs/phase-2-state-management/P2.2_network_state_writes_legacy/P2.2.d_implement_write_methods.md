# Task ID: P2.2.d - Implement Write Methods

**Sub-phase:** P2.2
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement `create_lightpath()` and `release_lightpath()` methods on `NetworkState`, including internal helpers.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.b_design_write_methods.md`
- `fusion/domain/network_state.py` (current state after P2.1)
- `fusion/domain/lightpath.py` (Phase 1 Lightpath class)

## Outputs

### 1. Update network_state.py Imports

Add to existing imports at top of file:

```python
if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.lightpath import Lightpath

# For runtime import (needed for Lightpath creation)
# Place after TYPE_CHECKING block
from fusion.domain.lightpath import Lightpath as LightpathClass
```

### 2. Add Write Methods to NetworkState

Append these methods to the `NetworkState` class:

```python
    # -------------------------------------------------------------------------
    # Write Methods (P2.2)
    # -------------------------------------------------------------------------

    def create_lightpath(
        self,
        path: list[str],
        start_slot: int,
        end_slot: int,
        core: int,
        band: str,
        modulation: str,
        bandwidth_gbps: int,
        path_weight_km: float,
        guard_slots: int = 0,
        *,
        backup_path: list[str] | None = None,
        backup_start_slot: int | None = None,
        backup_end_slot: int | None = None,
        backup_core: int | None = None,
        backup_band: str | None = None,
        snr_db: float | None = None,
        xt_cost: float | None = None,
    ) -> Lightpath:
        """
        Create and register a new lightpath, allocating spectrum.

        Args:
            path: Ordered list of node IDs (minimum 2 nodes)
            start_slot: First spectrum slot (inclusive)
            end_slot: Last spectrum slot (exclusive, includes guard slots)
            core: Core index for allocation
            band: Band identifier ("c", "l", "s")
            modulation: Modulation format name
            bandwidth_gbps: Total lightpath capacity
            path_weight_km: Path length/weight in kilometers
            guard_slots: Number of guard band slots at end (default 0)
            backup_path: Optional backup path for 1+1 protection
            backup_start_slot: Backup path start slot
            backup_end_slot: Backup path end slot
            backup_core: Backup path core index
            backup_band: Backup path band
            snr_db: Measured SNR value (optional)
            xt_cost: Crosstalk cost (optional)

        Returns:
            Newly created Lightpath with assigned lightpath_id

        Raises:
            ValueError: If parameters are invalid or spectrum unavailable
            KeyError: If any link in path doesn't exist in topology
        """
        # Validate parameters
        self._validate_create_lightpath_params(
            path=path,
            start_slot=start_slot,
            end_slot=end_slot,
            bandwidth_gbps=bandwidth_gbps,
            backup_path=backup_path,
            backup_start_slot=backup_start_slot,
            backup_end_slot=backup_end_slot,
            backup_core=backup_core,
            backup_band=backup_band,
        )

        # Check primary path spectrum availability
        if not self.is_spectrum_available(path, start_slot, end_slot, core, band):
            msg = f"Spectrum [{start_slot}:{end_slot}] not available on primary path"
            raise ValueError(msg)

        # Check backup path spectrum availability (if protected)
        is_protected = backup_path is not None
        if is_protected:
            assert backup_start_slot is not None
            assert backup_end_slot is not None
            assert backup_core is not None
            assert backup_band is not None

            if not self.is_spectrum_available(
                backup_path, backup_start_slot, backup_end_slot, backup_core, backup_band
            ):
                msg = f"Spectrum [{backup_start_slot}:{backup_end_slot}] not available on backup path"
                raise ValueError(msg)

        # Allocate primary path spectrum
        lightpath_id = self._next_lightpath_id
        self._allocate_spectrum_on_path(
            path=path,
            start_slot=start_slot,
            end_slot=end_slot,
            core=core,
            band=band,
            lightpath_id=lightpath_id,
            guard_slots=guard_slots,
        )

        # Allocate backup path spectrum (if protected)
        if is_protected:
            self._allocate_spectrum_on_path(
                path=backup_path,  # type: ignore[arg-type]
                start_slot=backup_start_slot,  # type: ignore[arg-type]
                end_slot=backup_end_slot,  # type: ignore[arg-type]
                core=backup_core,  # type: ignore[arg-type]
                band=backup_band,  # type: ignore[arg-type]
                lightpath_id=lightpath_id,
                guard_slots=guard_slots,
            )

        # Create Lightpath object
        # Note: Lightpath stores data slot range (excludes guard slots)
        data_end_slot = end_slot - guard_slots
        backup_data_end_slot = (
            backup_end_slot - guard_slots if backup_end_slot is not None else None
        )

        lightpath = LightpathClass(
            lightpath_id=lightpath_id,
            path=path,
            start_slot=start_slot,
            end_slot=data_end_slot,
            core=core,
            band=band,
            modulation=modulation,
            total_bandwidth_gbps=bandwidth_gbps,
            remaining_bandwidth_gbps=bandwidth_gbps,
            path_weight_km=path_weight_km,
            request_allocations={},
            snr_db=snr_db,
            xt_cost=xt_cost,
            is_degraded=False,
            backup_path=backup_path,
            backup_start_slot=backup_start_slot,
            backup_end_slot=backup_data_end_slot,
            backup_core=backup_core,
            backup_band=backup_band,
            is_protected=is_protected,
            active_path="primary",
        )

        # Register lightpath
        self._lightpaths[lightpath_id] = lightpath
        self._next_lightpath_id += 1

        return lightpath

    def release_lightpath(self, lightpath_id: int) -> bool:
        """
        Release a lightpath and free its spectrum.

        Args:
            lightpath_id: ID of lightpath to release

        Returns:
            True if lightpath was found and released, False if not found
        """
        lightpath = self._lightpaths.get(lightpath_id)
        if lightpath is None:
            return False

        # Calculate actual end slot (including guard bands)
        # Guard slots = total allocated - data slots
        primary_end_with_guards = lightpath.end_slot + self._config.guard_slots

        # Release primary path spectrum
        self._release_spectrum_on_path(
            path=lightpath.path,
            start_slot=lightpath.start_slot,
            end_slot=primary_end_with_guards,
            core=lightpath.core,
            band=lightpath.band,
        )

        # Release backup path spectrum (if protected)
        if lightpath.is_protected and lightpath.backup_path is not None:
            assert lightpath.backup_start_slot is not None
            assert lightpath.backup_end_slot is not None
            assert lightpath.backup_core is not None
            assert lightpath.backup_band is not None

            backup_end_with_guards = lightpath.backup_end_slot + self._config.guard_slots
            self._release_spectrum_on_path(
                path=lightpath.backup_path,
                start_slot=lightpath.backup_start_slot,
                end_slot=backup_end_with_guards,
                core=lightpath.backup_core,
                band=lightpath.backup_band,
            )

        # Remove from registry
        del self._lightpaths[lightpath_id]

        return True

    # -------------------------------------------------------------------------
    # Private Helpers for Write Methods
    # -------------------------------------------------------------------------

    def _validate_create_lightpath_params(
        self,
        *,
        path: list[str],
        start_slot: int,
        end_slot: int,
        bandwidth_gbps: int,
        backup_path: list[str] | None,
        backup_start_slot: int | None,
        backup_end_slot: int | None,
        backup_core: int | None,
        backup_band: str | None,
    ) -> None:
        """Validate create_lightpath parameters."""
        if len(path) < 2:
            msg = "Path must have at least 2 nodes"
            raise ValueError(msg)

        if start_slot >= end_slot:
            msg = f"Invalid slot range: start={start_slot} >= end={end_slot}"
            raise ValueError(msg)

        if bandwidth_gbps <= 0:
            msg = f"Bandwidth must be positive, got {bandwidth_gbps}"
            raise ValueError(msg)

        # Protection validation: all or nothing
        protection_fields = [backup_path, backup_start_slot, backup_end_slot, backup_core, backup_band]
        has_any_protection = any(f is not None for f in protection_fields)
        has_all_protection = all(f is not None for f in protection_fields)

        if has_any_protection and not has_all_protection:
            msg = "Incomplete protection specification: provide all backup fields or none"
            raise ValueError(msg)

        if backup_path is not None and len(backup_path) < 2:
            msg = "Backup path must have at least 2 nodes"
            raise ValueError(msg)

    def _allocate_spectrum_on_path(
        self,
        path: list[str],
        start_slot: int,
        end_slot: int,
        core: int,
        band: str,
        lightpath_id: int,
        guard_slots: int = 0,
    ) -> None:
        """
        Allocate spectrum range on all links in path.

        Assumes spectrum availability has already been verified.
        """
        for link in self._get_path_links(path):
            link_spectrum = self.get_link_spectrum(link)
            link_spectrum.allocate_range(
                start_slot=start_slot,
                end_slot=end_slot,
                core=core,
                band=band,
                lightpath_id=lightpath_id,
                guard_slots=guard_slots,
            )

    def _release_spectrum_on_path(
        self,
        path: list[str],
        start_slot: int,
        end_slot: int,
        core: int,
        band: str,
    ) -> None:
        """Release spectrum range on all links in path."""
        for link in self._get_path_links(path):
            link_spectrum = self.get_link_spectrum(link)
            link_spectrum.release_range(
                start_slot=start_slot,
                end_slot=end_slot,
                core=core,
                band=band,
            )
```

### 3. Update __init__.py Exports

Ensure `fusion/domain/__init__.py` exports everything:

```python
from fusion.domain.network_state import LinkSpectrum, NetworkState

__all__ = [
    # ... existing ...
    "LinkSpectrum",
    "NetworkState",
]
```

## Verification Commands

```bash
# Type checking
mypy fusion/domain/network_state.py --strict

# Linting
ruff check fusion/domain/network_state.py

# Smoke test
python -c "
import networkx as nx
from fusion.domain.network_state import NetworkState

class MockConfig:
    band_list = ('c',)
    band_slots = {'c': 320}
    cores_per_link = 1
    guard_slots = 1

G = nx.Graph()
G.add_edge('A', 'B', length=100.0)
G.add_edge('B', 'C', length=150.0)

state = NetworkState(G, MockConfig())

# Create lightpath
lp = state.create_lightpath(
    path=['A', 'B', 'C'],
    start_slot=0,
    end_slot=12,
    core=0,
    band='c',
    modulation='QPSK',
    bandwidth_gbps=100,
    path_weight_km=250.0,
    guard_slots=2,
)

print(f'Created lightpath {lp.lightpath_id}')
assert state.lightpath_count == 1
assert not state.is_spectrum_available(['A', 'B', 'C'], 0, 12, 0, 'c')

# Release lightpath
success = state.release_lightpath(lp.lightpath_id)
assert success
assert state.lightpath_count == 0
assert state.is_spectrum_available(['A', 'B', 'C'], 0, 12, 0, 'c')

print('Write methods smoke test passed')
"
```

## Important Notes

1. **Guard Slots Handling**: The `end_slot` parameter includes guard slots. Lightpath stores `end_slot - guard_slots` as its data range.

2. **Type Assertions**: The `assert` statements for protection fields help mypy understand that values are not None after the validation check.

3. **Import Strategy**: `LightpathClass` is imported at module level (not in TYPE_CHECKING) because we need to instantiate it.

## Next Task

After implementing write methods, proceed to `P2.2.e_implement_legacy_properties.md`.
