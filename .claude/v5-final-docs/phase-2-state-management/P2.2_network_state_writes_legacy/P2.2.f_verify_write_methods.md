# Task ID: P2.2.f - Verify Write Methods and Legacy Properties

**Sub-phase:** P2.2
**Scope:** Phase 2 - State Management only
**Task type:** verification-plan

## Purpose

Define comprehensive tests for write methods and legacy compatibility properties to ensure correct behavior.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.d_implement_write_methods.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.e_implement_legacy_properties.md`
- `fusion/domain/network_state.py` (complete implementation)
- `fusion/tests/domain/test_network_state.py` (P2.1 tests)

## Outputs

### 1. Add Write Method Tests

Append to `fusion/tests/domain/test_network_state.py`:

```python
# =============================================================================
# P2.2 Tests - Write Methods
# =============================================================================

class TestCreateLightpath:
    """Tests for create_lightpath method."""

    def test_create_simple_lightpath(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Test creating a basic lightpath."""
        state = NetworkState(simple_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=100.0,
        )

        assert lp.lightpath_id == 1
        assert lp.path == ["A", "B"]
        assert lp.start_slot == 0
        assert lp.end_slot == 10
        assert state.lightpath_count == 1
        assert state.get_lightpath(1) is lp

    def test_create_lightpath_allocates_spectrum(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Creating a lightpath should allocate spectrum."""
        state = NetworkState(simple_topology, simple_config)

        state.create_lightpath(
            path=["A", "B"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=100.0,
        )

        # Spectrum should be occupied
        assert not state.is_spectrum_available(["A", "B"], 0, 10, 0, "c")
        # Adjacent slots should still be free
        assert state.is_spectrum_available(["A", "B"], 10, 20, 0, "c")

    def test_create_lightpath_with_guard_band(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Guard band slots should be allocated with negative ID."""
        state = NetworkState(simple_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B"],
            start_slot=0,
            end_slot=12,  # 10 data + 2 guard
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=100.0,
            guard_slots=2,
        )

        # Lightpath end_slot should be data slots only
        assert lp.end_slot == 10  # 12 - 2 guard slots

        # Verify spectrum allocation
        ls = state.get_link_spectrum(("A", "B"))
        spectrum = ls.cores_matrix["c"]

        # Data slots should have positive ID
        assert all(spectrum[0, i] == 1 for i in range(10))
        # Guard slots should have negative ID
        assert all(spectrum[0, i] == -1 for i in range(10, 12))

    def test_create_lightpath_increments_id(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Each lightpath should get unique incrementing ID."""
        state = NetworkState(simple_topology, simple_config)

        lp1 = state.create_lightpath(
            path=["A", "B"], start_slot=0, end_slot=10, core=0, band="c",
            modulation="QPSK", bandwidth_gbps=100, path_weight_km=100.0,
        )
        lp2 = state.create_lightpath(
            path=["A", "B"], start_slot=10, end_slot=20, core=0, band="c",
            modulation="QPSK", bandwidth_gbps=100, path_weight_km=100.0,
        )

        assert lp1.lightpath_id == 1
        assert lp2.lightpath_id == 2
        assert state.next_lightpath_id == 3

    def test_create_lightpath_multi_hop(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Lightpath across multiple links should allocate on all links."""
        state = NetworkState(simple_topology, simple_config)

        state.create_lightpath(
            path=["A", "B", "C"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=250.0,
        )

        # Both links should be occupied
        assert not state.is_spectrum_available(["A", "B"], 0, 10, 0, "c")
        assert not state.is_spectrum_available(["B", "C"], 0, 10, 0, "c")

    def test_create_lightpath_fails_if_spectrum_unavailable(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Creating overlapping lightpath should fail."""
        state = NetworkState(simple_topology, simple_config)

        state.create_lightpath(
            path=["A", "B"], start_slot=0, end_slot=10, core=0, band="c",
            modulation="QPSK", bandwidth_gbps=100, path_weight_km=100.0,
        )

        with pytest.raises(ValueError, match="not available"):
            state.create_lightpath(
                path=["A", "B"], start_slot=5, end_slot=15, core=0, band="c",
                modulation="QPSK", bandwidth_gbps=100, path_weight_km=100.0,
            )

    def test_create_lightpath_validation_errors(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Invalid parameters should raise ValueError."""
        state = NetworkState(simple_topology, simple_config)

        # Path too short
        with pytest.raises(ValueError, match="at least 2 nodes"):
            state.create_lightpath(
                path=["A"], start_slot=0, end_slot=10, core=0, band="c",
                modulation="QPSK", bandwidth_gbps=100, path_weight_km=100.0,
            )

        # Invalid slot range
        with pytest.raises(ValueError, match="Invalid slot range"):
            state.create_lightpath(
                path=["A", "B"], start_slot=10, end_slot=5, core=0, band="c",
                modulation="QPSK", bandwidth_gbps=100, path_weight_km=100.0,
            )

        # Zero bandwidth
        with pytest.raises(ValueError, match="Bandwidth must be positive"):
            state.create_lightpath(
                path=["A", "B"], start_slot=0, end_slot=10, core=0, band="c",
                modulation="QPSK", bandwidth_gbps=0, path_weight_km=100.0,
            )


class TestCreateProtectedLightpath:
    """Tests for creating lightpaths with 1+1 protection."""

    def test_create_protected_lightpath(
        self,
        ring_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Test creating lightpath with backup path."""
        state = NetworkState(ring_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B", "C"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=200.0,
            backup_path=["A", "D", "C"],
            backup_start_slot=0,
            backup_end_slot=10,
            backup_core=0,
            backup_band="c",
        )

        assert lp.is_protected
        assert lp.backup_path == ["A", "D", "C"]

        # Both paths should have spectrum allocated
        assert not state.is_spectrum_available(["A", "B", "C"], 0, 10, 0, "c")
        assert not state.is_spectrum_available(["A", "D", "C"], 0, 10, 0, "c")

    def test_incomplete_protection_fails(
        self,
        ring_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Partial protection specification should fail."""
        state = NetworkState(ring_topology, simple_config)

        with pytest.raises(ValueError, match="Incomplete protection"):
            state.create_lightpath(
                path=["A", "B", "C"],
                start_slot=0,
                end_slot=10,
                core=0,
                band="c",
                modulation="QPSK",
                bandwidth_gbps=100,
                path_weight_km=200.0,
                backup_path=["A", "D", "C"],
                # Missing other backup fields
            )


class TestReleaseLightpath:
    """Tests for release_lightpath method."""

    def test_release_frees_spectrum(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Releasing lightpath should free spectrum."""
        simple_config.guard_slots = 2
        state = NetworkState(simple_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B"],
            start_slot=0,
            end_slot=12,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=100.0,
            guard_slots=2,
        )

        success = state.release_lightpath(lp.lightpath_id)

        assert success
        assert state.lightpath_count == 0
        assert state.get_lightpath(lp.lightpath_id) is None
        assert state.is_spectrum_available(["A", "B"], 0, 12, 0, "c")

    def test_release_nonexistent_returns_false(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Releasing non-existent lightpath should return False."""
        state = NetworkState(simple_topology, simple_config)

        success = state.release_lightpath(999)

        assert not success

    def test_release_protected_lightpath(
        self,
        ring_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Releasing protected lightpath should free both paths."""
        simple_config.guard_slots = 0
        state = NetworkState(ring_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B", "C"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=200.0,
            backup_path=["A", "D", "C"],
            backup_start_slot=0,
            backup_end_slot=10,
            backup_core=0,
            backup_band="c",
        )

        state.release_lightpath(lp.lightpath_id)

        # Both paths should be free
        assert state.is_spectrum_available(["A", "B", "C"], 0, 10, 0, "c")
        assert state.is_spectrum_available(["A", "D", "C"], 0, 10, 0, "c")


# =============================================================================
# P2.2 Tests - Legacy Compatibility Properties
# =============================================================================

class TestNetworkSpectrumDictProperty:
    """Tests for network_spectrum_dict legacy property."""

    def test_contains_all_links(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Should contain entries for all links."""
        state = NetworkState(simple_topology, simple_config)
        nsd = state.network_spectrum_dict

        assert ("A", "B") in nsd
        assert ("B", "A") in nsd
        assert ("B", "C") in nsd
        assert ("C", "B") in nsd

    def test_bidirectional_same_object(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Both directions should reference same dict object."""
        state = NetworkState(simple_topology, simple_config)
        nsd = state.network_spectrum_dict

        assert nsd[("A", "B")] is nsd[("B", "A")]

    def test_contains_required_fields(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Each entry should have required legacy fields."""
        state = NetworkState(simple_topology, simple_config)
        nsd = state.network_spectrum_dict

        entry = nsd[("A", "B")]
        assert "cores_matrix" in entry
        assert "usage_count" in entry
        assert "throughput" in entry
        assert "link_num" in entry

    def test_cores_matrix_direct_reference(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """cores_matrix should be direct reference to LinkSpectrum arrays."""
        state = NetworkState(simple_topology, simple_config)
        nsd = state.network_spectrum_dict

        ls = state.get_link_spectrum(("A", "B"))
        assert nsd[("A", "B")]["cores_matrix"] is ls.cores_matrix

    def test_includes_edge_attributes(
        self,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Edge attributes from topology should be included."""
        G = nx.Graph()
        G.add_edge("A", "B", length=100.0, dispersion=16.0)

        state = NetworkState(G, simple_config)
        nsd = state.network_spectrum_dict

        assert nsd[("A", "B")]["length"] == 100.0
        assert nsd[("A", "B")]["dispersion"] == 16.0


class TestLightpathStatusDictProperty:
    """Tests for lightpath_status_dict legacy property."""

    def test_empty_when_no_lightpaths(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Should be empty dict when no lightpaths exist."""
        state = NetworkState(simple_topology, simple_config)

        assert state.lightpath_status_dict == {}

    def test_sorted_tuple_key(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Keys should be sorted endpoint tuples."""
        state = NetworkState(simple_topology, simple_config)

        # Create lightpath from C to A (reverse alphabetical)
        state.create_lightpath(
            path=["C", "B", "A"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=250.0,
        )

        lsd = state.lightpath_status_dict

        # Key should be sorted: ("A", "C")
        assert ("A", "C") in lsd
        assert ("C", "A") not in lsd

    def test_contains_required_fields(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Each lightpath entry should have required legacy fields."""
        state = NetworkState(simple_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=100.0,
        )

        lsd = state.lightpath_status_dict
        entry = lsd[("A", "B")][lp.lightpath_id]

        assert entry["path"] == ["A", "B"]
        assert entry["lightpath_bandwidth"] == 100.0
        assert entry["remaining_bandwidth"] == 100.0
        assert entry["band"] == "c"
        assert entry["core"] == 0
        assert entry["modulation"] == "QPSK"
        assert entry["requests_dict"] == {}
        assert entry["time_bw_usage"] == {}
        assert entry["is_degraded"] is False

    def test_bandwidth_values_are_float(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Bandwidth values should be float (legacy format)."""
        state = NetworkState(simple_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=100.0,
        )

        lsd = state.lightpath_status_dict
        entry = lsd[("A", "B")][lp.lightpath_id]

        assert isinstance(entry["lightpath_bandwidth"], float)
        assert isinstance(entry["remaining_bandwidth"], float)

    def test_reflects_lightpath_changes(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Property should reflect current lightpath state."""
        state = NetworkState(simple_topology, simple_config)

        lp = state.create_lightpath(
            path=["A", "B"],
            start_slot=0,
            end_slot=10,
            core=0,
            band="c",
            modulation="QPSK",
            bandwidth_gbps=100,
            path_weight_km=100.0,
        )

        # Modify lightpath directly (simulating grooming)
        lp.allocate_bandwidth(request_id=1, bandwidth_gbps=25)

        lsd = state.lightpath_status_dict
        entry = lsd[("A", "B")][lp.lightpath_id]

        assert entry["remaining_bandwidth"] == 75.0
        assert entry["requests_dict"] == {1: 25.0}
```

### 2. Update MockSimulationConfig

Add `guard_slots` field to the fixture:

```python
class MockSimulationConfig:
    """Mock config for testing without full SimulationConfig dependency."""

    def __init__(
        self,
        band_list: tuple[str, ...] = ("c",),
        band_slots: dict[str, int] | None = None,
        cores_per_link: int = 1,
        guard_slots: int = 0,
    ) -> None:
        self.band_list = band_list
        self.band_slots = band_slots or {"c": 320}
        self.cores_per_link = cores_per_link
        self.guard_slots = guard_slots
```

### 3. Run Tests

```bash
# Run all NetworkState tests
pytest fusion/tests/domain/test_network_state.py -v --cov=fusion/domain/network_state --cov-report=term-missing

# Expected coverage: 90%+
```

## Verification Checklist

After running tests, verify:

- [ ] All P2.1 tests still pass (no regressions)
- [ ] All P2.2 tests pass
- [ ] Coverage >= 90% for `fusion/domain/network_state.py`
- [ ] `mypy fusion/domain/network_state.py --strict` passes
- [ ] `ruff check fusion/domain/network_state.py` passes
- [ ] Legacy properties match expected format exactly

## Exit Criteria for P2.2

P2.2 is complete when:

1. Write methods (`create_lightpath`, `release_lightpath`) implemented and tested
2. Legacy properties (`network_spectrum_dict`, `lightpath_status_dict`) implemented
3. All tests pass with 90%+ coverage
4. Legacy property format verified to match `sdn_props`

## Next Sub-phase

After P2.2 verification passes, proceed to [P2.3 Pipeline Protocols](../P2.3_pipeline_protocols/P2.3.index.md).
