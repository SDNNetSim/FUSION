# P2.2 Shared Context: Lightpath and Spectrum Shapes

## Purpose

This document defines the exact data structures for legacy `lightpath_status_dict` and `network_spectrum_dict` entries. Reference this when implementing legacy compatibility properties.

## Source Files

| File | Structure | Location |
|------|-----------|----------|
| `fusion/core/properties.py` | SDNProps definitions | Lines 333-404 |
| `fusion/core/spectrum_assignment.py` | _update_lightpath_status | Line 687 |
| `fusion/core/sdn_controller.py` | _release_lightpath_resources | Line 150 |

---

## lightpath_status_dict Entry Structure

### Key Format

```python
# Key is a SORTED tuple of source and destination
def get_key(src: str, dst: str) -> tuple[str, str]:
    return tuple(sorted([src, dst]))

# Example: lightpath from "C" to "A" has key ("A", "C")
```

### Value Structure (nested dicts)

```python
lightpath_status_dict: dict[tuple[str, str], dict[int, dict[str, Any]]]

# Structure:
{
    ("node_a", "node_b"): {  # Sorted endpoint tuple
        lightpath_id_1: {
            # Required fields
            "path": ["A", "B", "C"],         # list[str] - ordered node sequence
            "lightpath_bandwidth": 100.0,    # float - total capacity in Gbps
            "remaining_bandwidth": 75.0,     # float - available capacity
            "band": "c",                     # str - band identifier
            "core": 0,                       # int - core index
            "start_slot": 10,                # int - first allocated slot
            "end_slot": 18,                  # int - last slot (exclusive)
            "modulation": "QPSK",            # str - modulation format

            # Grooming tracking
            "requests_dict": {               # dict[int, float]
                request_id_1: 25.0,          # bandwidth allocated to this request
                request_id_2: 0.0,           # request released but entry remains
            },

            # Utilization tracking
            "time_bw_usage": {               # dict - bandwidth over time
                timestamp_1: bandwidth_1,
                timestamp_2: bandwidth_2,
            },

            # Quality flags
            "is_degraded": False,            # bool - SNR degradation flag

            # Additional fields (from Gap Analysis P2.0)
            "mod_format": "QPSK",            # str - alternate key for modulation
            "path_weight": 250.0,            # float - path distance in km
            "snr_cost": 12.5,                # float | None - SNR at allocation
            "xt_cost": 0.001,                # float | None - crosstalk cost
        },
        lightpath_id_2: { ... },
    },
    ("node_c", "node_d"): { ... },
}
```

### Field Mapping to Phase 1 Lightpath

| Legacy Field | Lightpath Field | Notes |
|--------------|-----------------|-------|
| `path` | `path` | Direct mapping |
| `lightpath_bandwidth` | `total_bandwidth_gbps` | Legacy uses float |
| `remaining_bandwidth` | `remaining_bandwidth_gbps` | Legacy uses float |
| `band` | `band` | Direct mapping |
| `core` | `core` | Direct mapping |
| `start_slot` | `start_slot` | Direct mapping |
| `end_slot` | `end_slot` | Direct mapping |
| `modulation` | `modulation` | Direct mapping |
| `mod_format` | `modulation` | Alternate key, same value |
| `requests_dict` | `request_allocations` | Legacy uses float values |
| `is_degraded` | `is_degraded` | Direct mapping |
| `time_bw_usage` | `time_utilization` | Dict[float, float] |
| `path_weight` | `path_weight_km` | Path distance in km |
| `snr_cost` | `snr_db` | SNR value at allocation |
| `xt_cost` | `xt_cost` | Crosstalk cost value |

---

## network_spectrum_dict Entry Structure

### Key Format

```python
# Key is (source, destination) tuple - NOT sorted
# Both directions exist: (A, B) and (B, A) point to SAME dict object
link_key: tuple[str, str]
```

### Value Structure

```python
network_spectrum_dict: dict[tuple[str, str], dict[str, Any]]

# Structure:
{
    ("node_a", "node_b"): {
        # Spectrum arrays
        "cores_matrix": {
            "c": np.ndarray,  # shape: (cores_per_link, num_slots_c_band)
            "l": np.ndarray,  # shape: (cores_per_link, num_slots_l_band)
            # ... additional bands if configured
        },

        # Usage statistics
        "usage_count": 5,         # int - number of active allocations
        "throughput": 500.0,      # float - cumulative Gbps served

        # Link identification
        "link_num": 0,            # int - link index

        # Physical parameters (from topology edge attributes)
        "length": 100.0,          # float - link length in km
        "dispersion": 16.0,       # float - dispersion parameter
        "attenuation": 0.2,       # float - fiber loss in dB/km
        "fiber_type": "SMF",      # str - fiber type
        # ... additional edge attributes
    },
    ("node_b", "node_a"): <same dict object as above>,
}
```

### Spectrum Array Values

```python
# cores_matrix[band][core, slot] values:
# - 0: Slot is free
# - Positive int: Data slot occupied by lightpath with that ID
# - Negative int: Guard band slot for lightpath with abs(value) ID

# Example for lightpath_id=5 with 8 data slots and 2 guard slots:
# cores_matrix["c"][0, 10:18] = 5    # Data slots
# cores_matrix["c"][0, 18:20] = -5   # Guard band slots
```

### Field Mapping to LinkSpectrum

| Legacy Field | LinkSpectrum Field | Notes |
|--------------|-------------------|-------|
| `cores_matrix` | `cores_matrix` | Direct mapping |
| `usage_count` | `usage_count` | Direct mapping |
| `throughput` | `throughput` | Direct mapping |
| `link_num` | `link_num` | Direct mapping |
| `length` | `length_km` | Renamed for clarity |
| Physical params | *not in LinkSpectrum* | From topology edges |

---

## Conversion Examples

### Creating Legacy lightpath_status_dict Entry

```python
def lightpath_to_legacy_dict(lp: Lightpath) -> dict[str, Any]:
    """Convert Phase 1 Lightpath to legacy dict format."""
    return {
        "path": lp.path,
        "lightpath_bandwidth": float(lp.total_bandwidth_gbps),
        "remaining_bandwidth": float(lp.remaining_bandwidth_gbps),
        "band": lp.band,
        "core": lp.core,
        "start_slot": lp.start_slot,
        "end_slot": lp.end_slot,
        "modulation": lp.modulation,
        "requests_dict": {
            req_id: float(bw)
            for req_id, bw in lp.request_allocations.items()
        },
        "time_bw_usage": {},  # Empty by default, populated during simulation
        "is_degraded": lp.is_degraded,
    }
```

### Creating Legacy network_spectrum_dict Entry

```python
def link_spectrum_to_legacy_dict(
    ls: LinkSpectrum,
    edge_data: dict[str, Any],
) -> dict[str, Any]:
    """Convert LinkSpectrum to legacy dict format."""
    result: dict[str, Any] = {
        "cores_matrix": ls.cores_matrix,  # Direct reference (same arrays)
        "usage_count": ls.usage_count,
        "throughput": ls.throughput,
        "link_num": ls.link_num,
    }
    # Copy edge attributes for physical parameters
    for key in ["length", "dispersion", "attenuation", "fiber_type"]:
        if key in edge_data:
            result[key] = edge_data[key]
    return result
```

---

## Critical Implementation Notes

### Sorted Tuple Keys

```python
# CORRECT - always sort for lightpath_status_dict keys
key = tuple(sorted([source, destination]))

# WRONG - unsorted keys will cause lookup failures
key = (source, destination)  # Only works if source < destination
```

### Bidirectional Link References

```python
# Both directions MUST point to same dict object
# This ensures spectrum updates are seen from both directions

network_spectrum_dict[("A", "B")] = link_dict
network_spectrum_dict[("B", "A")] = link_dict  # Same object, not copy
```

### Float vs Int for Bandwidth

```python
# Legacy uses float for bandwidth values
"lightpath_bandwidth": 100.0  # float
"remaining_bandwidth": 75.0   # float

# Phase 1 Lightpath uses int
total_bandwidth_gbps: int
remaining_bandwidth_gbps: int

# Conversion: Always convert to float for legacy format
"lightpath_bandwidth": float(lightpath.total_bandwidth_gbps)
```

---

## References

- Original: `.claude/v4-docs/migration/phase_2_state_management.md`
- SDNProps: `fusion/core/properties.py:333-404`
- Update logic: `fusion/core/spectrum_assignment.py:687`
- Release logic: `fusion/core/sdn_controller.py:150`
