# Task ID: P2.2.b - Design Write Methods

**Sub-phase:** P2.2
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the `create_lightpath()` and `release_lightpath()` methods for `NetworkState`, including internal helpers for spectrum allocation.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.c_design_network_state_core.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.3_lightpath_wrapper/P1.3.index.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.2_network_state_writes_legacy/P2.2.shared_context_lightpath_spectrum_shapes.md`

## Outputs

### 1. create_lightpath Method Specification

```python
def create_lightpath(
    self,
    path: list[str],
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
    modulation: str,
    bandwidth_gbps: int,
    path_weight_km: float,
    guard_slots: int = 0,
    *,
    # Protection fields (1+1)
    backup_path: list[str] | None = None,
    backup_start_slot: int | None = None,
    backup_end_slot: int | None = None,
    backup_core: int | None = None,
    backup_band: str | None = None,
    # Quality metrics
    snr_db: float | None = None,
    xt_cost: float | None = None,
) -> Lightpath:
    """
    Create and register a new lightpath, allocating spectrum.

    This method:
    1. Validates all parameters
    2. Verifies spectrum is available on all path links
    3. Allocates spectrum on all path links (with guard bands)
    4. Creates Lightpath object with assigned ID
    5. Registers lightpath in internal registry
    6. Optionally allocates backup path spectrum (for 1+1 protection)
    7. Returns the new Lightpath

    Args:
        path: Ordered list of node IDs (minimum 2 nodes)
        start_slot: First spectrum slot (inclusive)
        end_slot: Last spectrum slot (exclusive, includes guard slots)
        core: Core index for allocation
        band: Band identifier ("c", "l", "s")
        modulation: Modulation format name
        bandwidth_gbps: Total lightpath capacity
        path_weight_km: Path length/weight in kilometers
        guard_slots: Number of guard band slots at end (default 0)
        backup_path: Optional backup path for 1+1 protection
        backup_start_slot: Backup path start slot
        backup_end_slot: Backup path end slot
        backup_core: Backup path core index
        backup_band: Backup path band
        snr_db: Measured SNR value (optional)
        xt_cost: Crosstalk cost (optional)

    Returns:
        Newly created Lightpath with assigned lightpath_id

    Raises:
        ValueError: If path has fewer than 2 nodes
        ValueError: If spectrum range is invalid (start >= end)
        ValueError: If bandwidth_gbps <= 0
        ValueError: If spectrum is not available on all path links
        ValueError: If protection specified but incomplete (missing backup fields)
        KeyError: If any link in path doesn't exist in topology

    Side Effects:
        - Allocates spectrum on all links in path
        - Increments internal lightpath ID counter
        - Registers lightpath in internal registry
        - If protected: allocates backup path spectrum

    Thread Safety:
        Not thread-safe. Assumes single-threaded simulation.

    Example:
        >>> lp = state.create_lightpath(
        ...     path=["A", "B", "C"],
        ...     start_slot=0,
        ...     end_slot=12,
        ...     core=0,
        ...     band="c",
        ...     modulation="QPSK",
        ...     bandwidth_gbps=100,
        ...     path_weight_km=250.0,
        ...     guard_slots=2,
        ... )
        >>> print(lp.lightpath_id)  # Newly assigned ID
        1
    """
```

### 2. release_lightpath Method Specification

```python
def release_lightpath(self, lightpath_id: int) -> bool:
    """
    Release a lightpath and free its spectrum.

    This method:
    1. Looks up lightpath by ID
    2. Releases spectrum on all path links
    3. Releases backup path spectrum (if protected)
    4. Removes lightpath from registry

    Args:
        lightpath_id: ID of lightpath to release

    Returns:
        True if lightpath was found and released, False if not found

    Side Effects:
        - Frees spectrum slots on all links in path
        - Frees backup path spectrum (if protected)
        - Removes lightpath from registry
        - Does NOT decrement lightpath ID counter (IDs are never reused)

    Thread Safety:
        Not thread-safe. Assumes single-threaded simulation.

    Example:
        >>> success = state.release_lightpath(1)
        >>> print(success)
        True
        >>> state.get_lightpath(1)
        None
    """
```

### 3. Internal Helper: _allocate_spectrum_on_path

```python
def _allocate_spectrum_on_path(
    self,
    path: list[str],
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
    lightpath_id: int,
    guard_slots: int = 0,
) -> None:
    """
    Allocate spectrum range on all links in path.

    Args:
        path: Ordered list of node IDs
        start_slot: First slot (inclusive)
        end_slot: Last slot (exclusive)
        core: Core index
        band: Band identifier
        lightpath_id: ID to mark slots with
        guard_slots: Number of guard band slots

    Raises:
        ValueError: If spectrum not available on any link

    Note:
        Validates availability before any allocation to ensure
        atomic success/failure (no partial allocations).
    """
```

### 4. Internal Helper: _release_spectrum_on_path

```python
def _release_spectrum_on_path(
    self,
    path: list[str],
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
) -> None:
    """
    Release spectrum range on all links in path.

    Args:
        path: Ordered list of node IDs
        start_slot: First slot (inclusive)
        end_slot: Last slot (exclusive)
        core: Core index
        band: Band identifier

    Note:
        Always succeeds even if slots were already free.
    """
```

### 5. Validation Rules

| Parameter | Validation | Error |
|-----------|------------|-------|
| `path` | `len(path) >= 2` | "Path must have at least 2 nodes" |
| `start_slot, end_slot` | `start_slot < end_slot` | "Invalid slot range" |
| `bandwidth_gbps` | `bandwidth_gbps > 0` | "Bandwidth must be positive" |
| Spectrum availability | Check all links | "Spectrum not available on link X" |
| Protection fields | All or none | "Incomplete protection specification" |
| Links exist | All links in topology | KeyError from get_link_spectrum |

### 6. Atomicity Considerations

**create_lightpath must be atomic:**
- If validation fails, no state is changed
- If spectrum check fails, no allocation happens
- All links allocated together (no partial allocation)

**Implementation approach:**
1. Validate all parameters first
2. Check spectrum availability on ALL links before allocating any
3. If any link fails, raise error immediately
4. Only after all checks pass, perform allocations

```python
def create_lightpath(self, ...):
    # 1. Parameter validation
    self._validate_create_params(path, start_slot, end_slot, ...)

    # 2. Spectrum availability check (all links)
    if not self.is_spectrum_available(path, start_slot, end_slot, core, band):
        msg = "Spectrum not available on path"
        raise ValueError(msg)

    # 3. If protected, also check backup path
    if backup_path is not None:
        if not self.is_spectrum_available(backup_path, backup_start_slot, ...):
            msg = "Spectrum not available on backup path"
            raise ValueError(msg)

    # 4. Now safe to allocate (all checks passed)
    self._allocate_spectrum_on_path(path, ...)
    if backup_path is not None:
        self._allocate_spectrum_on_path(backup_path, ...)

    # 5. Create and register lightpath
    lightpath = Lightpath(...)
    self._lightpaths[lightpath.lightpath_id] = lightpath

    return lightpath
```

### 7. Lightpath Object Creation

```python
# Create Lightpath using Phase 1 class
lightpath = Lightpath(
    lightpath_id=self._next_lightpath_id,
    path=path,
    start_slot=start_slot,
    end_slot=end_slot - guard_slots,  # Lightpath stores data slots only
    core=core,
    band=band,
    modulation=modulation,
    total_bandwidth_gbps=bandwidth_gbps,
    remaining_bandwidth_gbps=bandwidth_gbps,  # Initially full capacity
    path_weight_km=path_weight_km,
    request_allocations={},  # Empty initially
    snr_db=snr_db,
    xt_cost=xt_cost,
    is_degraded=False,
    # Protection fields
    backup_path=backup_path,
    backup_start_slot=backup_start_slot,
    backup_end_slot=backup_end_slot - guard_slots if backup_end_slot else None,
    backup_core=backup_core,
    backup_band=backup_band,
    is_protected=backup_path is not None,
    active_path="primary",
)

# Increment counter AFTER successful creation
self._next_lightpath_id += 1
```

### 8. Design Decisions

| Decision | Rationale |
|----------|-----------|
| Guard slots included in end_slot | Matches legacy behavior where end_slot includes guards |
| Atomic validation before allocation | Prevents partial state corruption |
| IDs never reused | Simplifies debugging, matches legacy |
| Lightpath stores data slot count | `num_slots` property excludes guard bands |
| All-or-nothing protection | Partial protection makes no sense |

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.2.d.

Key considerations:
1. Match legacy allocation behavior exactly
2. Support 1+1 protection (backup path)
3. Atomic operations (all-or-nothing)
4. Clear error messages for debugging

---

## 9. Guard Band Encoding Convention

**Critical**: Guard bands use negative lightpath IDs to distinguish from data slots.

### Spectrum Layout

```
Slot Index:   10  11  12  13  14  15  16  17  18  19
              |<------- data slots ------->|<guard>|
Value:        42  42  42  42  42  42  42  42  -42   0

lightpath_id = 42
start_slot = 10
end_slot = 19 (exclusive, total range)
guard_slots = 1
data_slots = end_slot - start_slot - guard_slots = 8
```

### Allocation Logic

```python
def _allocate_spectrum_on_path(
    self,
    path: list[str],
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
    lightpath_id: int,
    guard_slots: int = 0,
) -> None:
    """
    Allocate spectrum with guard band handling.
    """
    # Calculate slot boundaries
    data_end = end_slot - guard_slots
    guard_start = data_end
    guard_end = end_slot

    for u, v in zip(path, path[1:], strict=False):
        spectrum = self._spectrum[(u, v)]
        cores_matrix = spectrum.cores_matrix[band][core]

        # Mark data slots with positive lightpath_id
        cores_matrix[start_slot:data_end] = lightpath_id

        # Mark guard slots with NEGATIVE lightpath_id
        if guard_slots > 0:
            cores_matrix[guard_start:guard_end] = -lightpath_id

        # Bidirectional allocation
        reverse_spectrum = self._spectrum[(v, u)]
        reverse_matrix = reverse_spectrum.cores_matrix[band][core]
        reverse_matrix[start_slot:data_end] = lightpath_id
        if guard_slots > 0:
            reverse_matrix[guard_start:guard_end] = -lightpath_id

        # Increment usage count
        spectrum.usage_count += 1
```

### Release Logic

```python
def _release_spectrum_on_path(
    self,
    path: list[str],
    lightpath_id: int,
) -> None:
    """
    Release spectrum by finding and clearing both data and guard slots.

    Uses the lightpath_id to find slots, not stored slot indices,
    making this robust against state inconsistencies.
    """
    for u, v in zip(path, path[1:], strict=False):
        spectrum = self._spectrum[(u, v)]

        for band_name, cores in spectrum.cores_matrix.items():
            for core_idx in range(len(cores)):
                array = cores[core_idx]

                # Clear data slots (positive ID)
                data_mask = (array == lightpath_id)
                array[data_mask] = 0

                # Clear guard slots (negative ID)
                guard_mask = (array == -lightpath_id)
                array[guard_mask] = 0

        # Same for reverse direction
        reverse_spectrum = self._spectrum[(v, u)]
        for band_name, cores in reverse_spectrum.cores_matrix.items():
            for core_idx in range(len(cores)):
                array = cores[core_idx]
                array[array == lightpath_id] = 0
                array[array == -lightpath_id] = 0
```

---

## 10. Protected Lightpath Allocation (1+1)

### Single Lightpath, Two Paths

For 1+1 protection, a single logical lightpath allocates spectrum on both primary and backup paths. The same lightpath_id marks both paths.

```python
def create_protected_lightpath(
    self,
    # Primary path parameters
    primary_path: list[str],
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
    # Backup path parameters
    backup_path: list[str],
    backup_start_slot: int | None = None,  # If None, use same as primary
    backup_end_slot: int | None = None,
    backup_core: int | None = None,
    backup_band: str | None = None,
    # Common parameters
    modulation: str,
    bandwidth_gbps: int,
    path_weight_km: float,
    backup_weight_km: float,
    guard_slots: int = 0,
    snr_db: float | None = None,
    xt_cost: float | None = None,
) -> Lightpath:
    """
    Create 1+1 protected lightpath.

    Default behavior: Use SAME spectrum allocation on backup path.
    Override: Specify backup_start_slot etc. for different allocation.
    """
    # Default backup spectrum to match primary
    backup_start = backup_start_slot if backup_start_slot is not None else start_slot
    backup_end = backup_end_slot if backup_end_slot is not None else end_slot
    backup_c = backup_core if backup_core is not None else core
    backup_b = backup_band if backup_band is not None else band

    # Validate both paths have spectrum available
    if not self.is_spectrum_available(primary_path, start_slot, end_slot, core, band):
        raise ValueError("Primary path spectrum not available")
    if not self.is_spectrum_available(backup_path, backup_start, backup_end, backup_c, backup_b):
        raise ValueError("Backup path spectrum not available")

    # Generate single ID for both paths
    lp_id = self._next_lightpath_id
    self._next_lightpath_id += 1

    # Allocate on primary path
    self._allocate_spectrum_on_path(
        primary_path, start_slot, end_slot, core, band, lp_id, guard_slots
    )

    # Allocate on backup path with SAME lightpath_id
    self._allocate_spectrum_on_path(
        backup_path, backup_start, backup_end, backup_c, backup_b, lp_id, guard_slots
    )

    # Create lightpath with protection info
    lightpath = Lightpath(
        lightpath_id=lp_id,
        path=primary_path,
        backup_path=backup_path,
        is_protected=True,
        # ... other fields
    )

    self._lightpaths[lp_id] = lightpath
    return lightpath
```

### Release Behavior

When releasing a protected lightpath, both paths must be cleared:

```python
def release_lightpath(self, lightpath_id: int) -> bool:
    lp = self._lightpaths.get(lightpath_id)
    if lp is None:
        return False

    # Release primary path spectrum
    self._release_spectrum_on_path(lp.path, lightpath_id)

    # Release backup path spectrum if protected
    if lp.is_protected and lp.backup_path:
        self._release_spectrum_on_path(lp.backup_path, lightpath_id)

    del self._lightpaths[lightpath_id]
    return True
```

---

## 11. Bandwidth Management Methods

### Grooming: Allocate Bandwidth to Request

```python
def allocate_request_bandwidth(
    self,
    lightpath_id: int,
    request_id: int,
    bandwidth_gbps: int,
    arrival_time: float | None = None,
) -> None:
    """
    Allocate bandwidth on existing lightpath to a request.

    Used by grooming to share lightpath capacity among requests.

    Raises:
        KeyError: If lightpath not found
        ValueError: If insufficient remaining bandwidth
    """
    lp = self._lightpaths[lightpath_id]

    if lp.remaining_bandwidth_gbps < bandwidth_gbps:
        raise ValueError(
            f"Insufficient bandwidth: need {bandwidth_gbps}, "
            f"have {lp.remaining_bandwidth_gbps}"
        )

    lp.remaining_bandwidth_gbps -= bandwidth_gbps
    lp.request_allocations[request_id] = bandwidth_gbps

    # Track utilization over time
    if arrival_time is not None:
        utilization = 1 - (lp.remaining_bandwidth_gbps / lp.total_bandwidth_gbps)
        lp.time_utilization[arrival_time] = utilization * 100
```

### Grooming: Release Request Bandwidth

```python
def release_request_bandwidth(
    self,
    lightpath_id: int,
    request_id: int,
    departure_time: float | None = None,
) -> int:
    """
    Release bandwidth allocated to a request.

    Returns the bandwidth that was released.

    Raises:
        KeyError: If lightpath or request not found
    """
    lp = self._lightpaths[lightpath_id]

    if request_id not in lp.request_allocations:
        raise KeyError(f"Request {request_id} not found in lightpath {lightpath_id}")

    bandwidth = lp.request_allocations.pop(request_id)
    lp.remaining_bandwidth_gbps += bandwidth

    # Track utilization
    if departure_time is not None:
        utilization = 1 - (lp.remaining_bandwidth_gbps / lp.total_bandwidth_gbps)
        lp.time_utilization[departure_time] = utilization * 100

    return bandwidth
```

---

## 12. Usage Count Semantics

**Legacy Behavior**: `usage_count` increments once per link-allocation, not per lightpath.

```python
# Path [A, B, C] traverses 2 links
# usage_count on (A,B) increases by 1
# usage_count on (B,C) increases by 1
# Total increment across network: 2

# (u,v) and (v,u) share the same dict object in legacy code
# So increment to one affects both directions
```

**NetworkState Implementation**:

```python
def _allocate_spectrum_on_path(self, path, ...):
    for u, v in zip(path, path[1:]):
        # ... allocation ...

        # Increment usage count (only once per link pair)
        spectrum = self._spectrum[(u, v)]
        spectrum.usage_count += 1
        # Note: (v, u) may or may not be same object
        # For consistency, only increment forward direction
```

---

## Next Task

After completing this design, proceed to `P2.2.c_design_legacy_compat_properties.md`.
