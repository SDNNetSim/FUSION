# Task ID: P2.4.b - Implement RoutingAdapter

**Sub-phase:** P2.4
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement `RoutingAdapter` that wraps the legacy `Routing` class to satisfy the `RoutingPipeline` protocol.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.a_design_adapter_pattern.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.shared_context_legacy_impls.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.b_design_routing_protocol.md`

## Outputs

### 1. Create Package Structure

```bash
mkdir -p fusion/core/adapters
touch fusion/core/adapters/__init__.py
```

### 2. Create fusion/core/adapters/__init__.py

```python
"""
Legacy adapters for FUSION simulation.

This package provides adapter classes that wrap legacy implementations
to satisfy the new pipeline protocols, enabling gradual migration.

ADAPTERS: These classes are TEMPORARY MIGRATION LAYERS.
They will be replaced with clean implementations in Phase 4.

Phase: P2.4 - Legacy Adapters
"""

from fusion.core.adapters.routing_adapter import RoutingAdapter
from fusion.core.adapters.spectrum_adapter import SpectrumAdapter
from fusion.core.adapters.grooming_adapter import GroomingAdapter
from fusion.core.adapters.snr_adapter import SNRAdapter

__all__ = [
    "RoutingAdapter",
    "SpectrumAdapter",
    "GroomingAdapter",
    "SNRAdapter",
]
```

### 3. Create fusion/core/adapters/routing_adapter.py

```python
"""
RoutingAdapter - Adapts legacy Routing class to RoutingPipeline protocol.

ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
It will be replaced with a clean implementation in Phase 4.

Phase: P2.4 - Legacy Adapters
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

from fusion.interfaces.pipelines import RoutingPipeline

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.results import RouteResult

logger = logging.getLogger(__name__)


@dataclass
class RoutePropsProxy:
    """
    Proxy for RouteProps to capture legacy routing output.

    Used internally by RoutingAdapter to collect results from legacy code.
    """

    paths_matrix: list[list[str]] = field(default_factory=list)
    weights_list: list[float] = field(default_factory=list)
    modulation_formats_matrix: list[list[str]] = field(default_factory=list)

    def to_route_result(self, strategy_name: str = "legacy") -> RouteResult:
        """Convert captured output to Phase 1 RouteResult."""
        from fusion.domain.results import RouteResult

        if not self.paths_matrix:
            return RouteResult.empty(strategy_name)

        return RouteResult(
            paths=tuple(tuple(p) for p in self.paths_matrix),
            weights_km=tuple(self.weights_list),
            modulations=tuple(tuple(m) for m in self.modulation_formats_matrix),
            strategy_name=strategy_name,
        )


@dataclass
class SDNPropsProxy:
    """
    Minimal proxy for SDNProps to satisfy legacy Routing class.

    Only implements attributes that Routing.get_route() actually reads.
    """

    topology: Any  # nx.Graph
    network_spectrum_dict: dict[tuple[str, str], dict[str, Any]] = field(
        default_factory=dict
    )
    lightpath_status_dict: dict[tuple[str, str], dict[int, dict[str, Any]]] = field(
        default_factory=dict
    )

    @classmethod
    def from_network_state(cls, network_state: NetworkState) -> SDNPropsProxy:
        """Create proxy from NetworkState using its legacy properties."""
        return cls(
            topology=network_state.topology,
            network_spectrum_dict=network_state.network_spectrum_dict,
            lightpath_status_dict=network_state.lightpath_status_dict,
        )


class RoutingAdapter(RoutingPipeline):
    """
    Adapts legacy Routing class to RoutingPipeline protocol.

    ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
    It will be replaced with a clean implementation in Phase 4.

    The adapter:
    1. Receives Phase 1 objects (NetworkState, config)
    2. Creates proxy objects for legacy code
    3. Calls legacy Routing.get_route()
    4. Converts route_props to RouteResult

    Removal Checklist:
    [ ] Clean RoutingPipeline implementation exists
    [ ] All callers migrated to clean implementation
    [ ] run_comparison.py passes without this adapter
    [ ] grep 'RoutingAdapter' returns only this definition

    Example:
        >>> config = SimulationConfig.from_engine_props(engine_props)
        >>> adapter = RoutingAdapter(config)
        >>> result = adapter.find_routes("A", "B", 100, network_state)
        >>> print(result.paths)
    """

    def __init__(self, config: SimulationConfig) -> None:
        """
        Initialize adapter with configuration.

        Args:
            config: SimulationConfig for creating legacy engine_props

        Note:
            Does NOT store NetworkState - receives per-call
        """
        self._config = config
        self._engine_props = config.to_engine_props()

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        """
        Find candidate routes between source and destination.

        Args:
            source: Source node identifier
            destination: Destination node identifier
            bandwidth_gbps: Required bandwidth
            network_state: Current network state
            forced_path: Optional forced path (from grooming)

        Returns:
            RouteResult containing paths, weights, and modulations
        """
        from fusion.domain.results import RouteResult

        # Handle forced path (from partial grooming)
        if forced_path is not None:
            return self._handle_forced_path(forced_path, network_state)

        try:
            # Create proxies for legacy code
            sdn_props = SDNPropsProxy.from_network_state(network_state)
            route_props = RoutePropsProxy()

            # Import and instantiate legacy Routing
            from fusion.core.routing import Routing

            legacy_routing = Routing(
                engine_props=self._engine_props,
                sdn_props=sdn_props,
                route_props=route_props,
            )

            # Call legacy method
            legacy_routing.get_route(
                source=source,
                destination=destination,
                request_bandwidth=float(bandwidth_gbps),
            )

            # Convert to Phase 1 result
            strategy_name = self._engine_props.get("route_method", "legacy")
            return route_props.to_route_result(strategy_name)

        except Exception as e:
            logger.warning(f"RoutingAdapter.find_routes failed: {e}")
            return RouteResult.empty("legacy_error")

    def _handle_forced_path(
        self,
        forced_path: list[str],
        network_state: NetworkState,
    ) -> RouteResult:
        """
        Handle forced path case (from partial grooming).

        When grooming partially succeeds, it specifies a forced path
        for the new lightpath that must be co-located with groomed traffic.
        """
        from fusion.domain.results import RouteResult

        # Calculate path weight
        weight = self._calculate_path_weight(forced_path, network_state)

        # Get modulation formats for this path length
        modulations = self._get_modulations_for_weight(weight)

        return RouteResult(
            paths=(tuple(forced_path),),
            weights_km=(weight,),
            modulations=(modulations,),
            strategy_name="forced",
        )

    def _calculate_path_weight(
        self,
        path: list[str],
        network_state: NetworkState,
    ) -> float:
        """Calculate total path weight (distance) in km."""
        total = 0.0
        topology = network_state.topology

        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            if topology.has_edge(u, v):
                edge_data = topology.edges[u, v]
                total += edge_data.get("length", edge_data.get("weight", 0.0))

        return total

    def _get_modulations_for_weight(self, weight_km: float) -> tuple[str, ...]:
        """Get valid modulation formats for given path weight."""
        modulations = []
        mod_formats = self._config.modulation_formats

        for mod_name, mod_info in mod_formats.items():
            max_reach = mod_info.get("max_reach_km", float("inf"))
            if weight_km <= max_reach:
                modulations.append(mod_name)

        # Sort by efficiency (higher order first)
        return tuple(sorted(modulations, reverse=True))
```

## Verification Commands

```bash
# Type checking
mypy fusion/core/adapters/routing_adapter.py --strict

# Linting
ruff check fusion/core/adapters/routing_adapter.py

# Smoke test (requires Phase 1 and P2.1-P2.2 complete)
python -c "
from fusion.core.adapters.routing_adapter import RoutingAdapter
print('RoutingAdapter imported successfully')
"
```

## Important Notes

### Legacy Import Inside Method

The legacy `Routing` class is imported inside `find_routes()`:
```python
from fusion.core.routing import Routing
```

This avoids circular imports and keeps the adapter lightweight.

### Proxy Objects

Proxy objects are created fresh for each call:
- `SDNPropsProxy` - Wraps NetworkState for legacy read access
- `RoutePropsProxy` - Captures legacy output

### Error Handling

On failure, returns empty `RouteResult` rather than raising:
- Matches legacy behavior (empty result = no routes found)
- Logs warning for debugging

### Forced Path Handling

Special case for partial grooming:
- Grooming returns a forced path
- Adapter uses that path directly
- Calculates weight and modulations

## Next Task

After implementing RoutingAdapter, proceed to `P2.4.c_implement_spectrum_adapter.md`.
