# Task ID: P2.4.e - Verify Adapters

**Sub-phase:** P2.4
**Scope:** Phase 2 - State Management only
**Task type:** verification-plan

## Purpose

Verify that all adapters correctly implement their protocols and produce identical results to legacy code.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.b_implement_routing_adapter.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.c_implement_spectrum_adapter.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.d_implement_grooming_snr_adapters.md`
- `fusion/core/adapters/` (all adapter implementations)

## Outputs

### 1. Create Test Directory

```bash
mkdir -p fusion/tests/adapters
touch fusion/tests/adapters/__init__.py
```

### 2. Create fusion/tests/adapters/test_routing_adapter.py

```python
"""
Tests for RoutingAdapter.

Verifies:
1. Adapter implements RoutingPipeline protocol
2. Results match legacy Routing output
3. Forced path handling works correctly

Phase: P2.4 - Legacy Adapters
"""

from __future__ import annotations

import pytest
import networkx as nx

from fusion.core.adapters.routing_adapter import RoutingAdapter
from fusion.interfaces.pipelines import RoutingPipeline


class MockSimulationConfig:
    """Mock config for testing."""

    def __init__(self) -> None:
        self.k_paths = 3
        self.route_method = "k_shortest_paths"
        self.modulation_formats = {
            "QPSK": {"bits_per_symbol": 2, "max_reach_km": 5000},
            "16-QAM": {"bits_per_symbol": 4, "max_reach_km": 2000},
        }
        self.guard_slots = 1

    def to_engine_props(self) -> dict:
        return {
            "k_paths": self.k_paths,
            "route_method": self.route_method,
            "modulation_formats": self.modulation_formats,
        }


class MockNetworkState:
    """Mock NetworkState for testing."""

    def __init__(self, topology: nx.Graph) -> None:
        self._topology = topology
        self._spectrum: dict = {}
        self._lightpaths: dict = {}

    @property
    def topology(self) -> nx.Graph:
        return self._topology

    @property
    def network_spectrum_dict(self) -> dict:
        return self._spectrum

    @property
    def lightpath_status_dict(self) -> dict:
        return self._lightpaths


@pytest.fixture
def simple_topology() -> nx.Graph:
    """Simple test topology."""
    G = nx.Graph()
    G.add_edge("A", "B", length=100.0)
    G.add_edge("B", "C", length=150.0)
    G.add_edge("A", "C", length=300.0)
    return G


@pytest.fixture
def config() -> MockSimulationConfig:
    return MockSimulationConfig()


@pytest.fixture
def network_state(simple_topology: nx.Graph) -> MockNetworkState:
    return MockNetworkState(simple_topology)


class TestRoutingAdapterProtocol:
    """Test that adapter satisfies protocol."""

    def test_implements_protocol(self, config: MockSimulationConfig) -> None:
        """Adapter should implement RoutingPipeline."""
        adapter = RoutingAdapter(config)
        assert isinstance(adapter, RoutingPipeline)

    def test_has_find_routes_method(self, config: MockSimulationConfig) -> None:
        """Adapter should have find_routes method."""
        adapter = RoutingAdapter(config)
        assert hasattr(adapter, "find_routes")
        assert callable(adapter.find_routes)


class TestRoutingAdapterForcedPath:
    """Test forced path handling."""

    def test_forced_path_returns_single_path(
        self,
        config: MockSimulationConfig,
        network_state: MockNetworkState,
    ) -> None:
        """Forced path should return that path directly."""
        adapter = RoutingAdapter(config)

        result = adapter.find_routes(
            source="A",
            destination="C",
            bandwidth_gbps=100,
            network_state=network_state,
            forced_path=["A", "B", "C"],
        )

        assert len(result.paths) == 1
        assert result.paths[0] == ("A", "B", "C")
        assert result.strategy_name == "forced"

    def test_forced_path_calculates_weight(
        self,
        config: MockSimulationConfig,
        network_state: MockNetworkState,
    ) -> None:
        """Forced path should calculate correct weight."""
        adapter = RoutingAdapter(config)

        result = adapter.find_routes(
            source="A",
            destination="C",
            bandwidth_gbps=100,
            network_state=network_state,
            forced_path=["A", "B", "C"],
        )

        # A-B (100) + B-C (150) = 250
        assert result.weights_km[0] == 250.0


class TestRoutingAdapterErrorHandling:
    """Test error handling."""

    def test_returns_empty_on_error(
        self,
        config: MockSimulationConfig,
    ) -> None:
        """Should return empty result on error, not raise."""
        adapter = RoutingAdapter(config)

        # Create invalid network state
        class BrokenNetworkState:
            @property
            def topology(self):
                raise RuntimeError("Broken!")

        result = adapter.find_routes(
            source="A",
            destination="B",
            bandwidth_gbps=100,
            network_state=BrokenNetworkState(),
        )

        assert len(result.paths) == 0
        assert "error" in result.strategy_name.lower()
```

### 3. Create fusion/tests/adapters/test_spectrum_adapter.py

```python
"""
Tests for SpectrumAdapter.

Phase: P2.4 - Legacy Adapters
"""

from __future__ import annotations

import pytest

from fusion.core.adapters.spectrum_adapter import SpectrumAdapter
from fusion.interfaces.pipelines import SpectrumPipeline


class MockSimulationConfig:
    """Mock config for testing."""

    def __init__(self) -> None:
        self.band_list = ("c",)
        self.band_slots = {"c": 320}
        self.cores_per_link = 1
        self.guard_slots = 1
        self.allocation_method = "first_fit"
        self.modulation_formats = {
            "QPSK": {"bits_per_symbol": 2},
        }

    def to_engine_props(self) -> dict:
        return {
            "band_list": self.band_list,
            "band_slots": self.band_slots,
            "cores_per_link": self.cores_per_link,
            "guard_slots": self.guard_slots,
            "allocation_method": self.allocation_method,
            "modulation_formats": self.modulation_formats,
        }


class TestSpectrumAdapterProtocol:
    """Test that adapter satisfies protocol."""

    def test_implements_protocol(self) -> None:
        """Adapter should implement SpectrumPipeline."""
        config = MockSimulationConfig()
        adapter = SpectrumAdapter(config)
        assert isinstance(adapter, SpectrumPipeline)

    def test_has_find_spectrum_method(self) -> None:
        """Adapter should have find_spectrum method."""
        config = MockSimulationConfig()
        adapter = SpectrumAdapter(config)
        assert hasattr(adapter, "find_spectrum")

    def test_has_find_protected_spectrum_method(self) -> None:
        """Adapter should have find_protected_spectrum method."""
        config = MockSimulationConfig()
        adapter = SpectrumAdapter(config)
        assert hasattr(adapter, "find_protected_spectrum")


class TestSpectrumAdapterSlotsCalculation:
    """Test slots calculation."""

    def test_calculates_slots_needed(self) -> None:
        """Should correctly calculate slots needed."""
        config = MockSimulationConfig()
        adapter = SpectrumAdapter(config)

        # 100 Gbps with QPSK (2 bits/symbol) at 12.5 GHz/slot
        # = 100 / (12.5 * 2) = 4 data slots + 1 guard = 5 total
        slots = adapter._calculate_slots_needed(100, "QPSK")
        assert slots == 5
```

### 4. Create fusion/tests/adapters/test_all_adapters.py

```python
"""
Integration tests for all adapters.

Verifies all adapters can be imported and instantiated.

Phase: P2.4 - Legacy Adapters
"""

from __future__ import annotations

import pytest


class MockSimulationConfig:
    """Minimal mock config for import tests."""

    def __init__(self) -> None:
        self.k_paths = 3
        self.route_method = "k_shortest_paths"
        self.band_list = ("c",)
        self.band_slots = {"c": 320}
        self.cores_per_link = 1
        self.guard_slots = 1
        self.snr_enabled = True
        self.snr_thresholds = {"QPSK": 10.0}
        self.modulation_formats = {"QPSK": {"bits_per_symbol": 2}}
        self.allocation_method = "first_fit"

    def to_engine_props(self) -> dict:
        return vars(self)


class TestAllAdaptersImport:
    """Test that all adapters can be imported."""

    def test_import_routing_adapter(self) -> None:
        from fusion.core.adapters import RoutingAdapter
        assert RoutingAdapter is not None

    def test_import_spectrum_adapter(self) -> None:
        from fusion.core.adapters import SpectrumAdapter
        assert SpectrumAdapter is not None

    def test_import_grooming_adapter(self) -> None:
        from fusion.core.adapters import GroomingAdapter
        assert GroomingAdapter is not None

    def test_import_snr_adapter(self) -> None:
        from fusion.core.adapters import SNRAdapter
        assert SNRAdapter is not None


class TestAllAdaptersInstantiation:
    """Test that all adapters can be instantiated."""

    @pytest.fixture
    def config(self) -> MockSimulationConfig:
        return MockSimulationConfig()

    def test_instantiate_routing_adapter(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import RoutingAdapter
        adapter = RoutingAdapter(config)
        assert adapter is not None

    def test_instantiate_spectrum_adapter(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import SpectrumAdapter
        adapter = SpectrumAdapter(config)
        assert adapter is not None

    def test_instantiate_grooming_adapter(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import GroomingAdapter
        adapter = GroomingAdapter(config)
        assert adapter is not None

    def test_instantiate_snr_adapter(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import SNRAdapter
        adapter = SNRAdapter(config)
        assert adapter is not None


class TestAllAdaptersProtocol:
    """Test that all adapters implement their protocols."""

    @pytest.fixture
    def config(self) -> MockSimulationConfig:
        return MockSimulationConfig()

    def test_routing_implements_protocol(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import RoutingAdapter
        from fusion.interfaces import RoutingPipeline
        adapter = RoutingAdapter(config)
        assert isinstance(adapter, RoutingPipeline)

    def test_spectrum_implements_protocol(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import SpectrumAdapter
        from fusion.interfaces import SpectrumPipeline
        adapter = SpectrumAdapter(config)
        assert isinstance(adapter, SpectrumPipeline)

    def test_grooming_implements_protocol(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import GroomingAdapter
        from fusion.interfaces import GroomingPipeline
        adapter = GroomingAdapter(config)
        assert isinstance(adapter, GroomingPipeline)

    def test_snr_implements_protocol(self, config: MockSimulationConfig) -> None:
        from fusion.core.adapters import SNRAdapter
        from fusion.interfaces import SNRPipeline
        adapter = SNRAdapter(config)
        assert isinstance(adapter, SNRPipeline)
```

### 5. Verification Commands

```bash
# Type checking all adapters
mypy fusion/core/adapters/ --strict

# Linting
ruff check fusion/core/adapters/

# Run adapter tests
pytest fusion/tests/adapters/ -v

# Full verification
pytest fusion/tests/adapters/ -v --cov=fusion/core/adapters --cov-report=term-missing
```

## Verification Checklist

After running tests, verify:

- [ ] All adapters pass `mypy --strict`
- [ ] All adapters pass `ruff check`
- [ ] All adapters implement their protocols (isinstance checks pass)
- [ ] Adapter tests pass
- [ ] Error handling returns appropriate results (not exceptions)
- [ ] Forced path handling works correctly

## Exit Criteria for P2.4

P2.4 is complete when:

1. All four adapters implemented:
   - RoutingAdapter
   - SpectrumAdapter
   - GroomingAdapter
   - SNRAdapter
2. Each adapter implements its protocol
3. All tests pass
4. `mypy --strict` passes
5. `ruff check` passes

## Phase 2 Completion

With P2.4 complete, Phase 2 is finished. The deliverables are:

| Component | Location | Purpose |
|-----------|----------|---------|
| NetworkState | `fusion/domain/network_state.py` | Single source of truth |
| LinkSpectrum | `fusion/domain/network_state.py` | Per-link spectrum |
| Pipeline Protocols | `fusion/interfaces/pipelines.py` | Type-safe interfaces |
| RoutingAdapter | `fusion/core/adapters/routing_adapter.py` | Wraps legacy Routing |
| SpectrumAdapter | `fusion/core/adapters/spectrum_adapter.py` | Wraps legacy SpectrumAssignment |
| GroomingAdapter | `fusion/core/adapters/grooming_adapter.py` | Wraps legacy Grooming |
| SNRAdapter | `fusion/core/adapters/snr_adapter.py` | Wraps legacy SnrMeasurements |

## Next Phase

After Phase 2, proceed to Phase 3: Orchestrator Integration.
