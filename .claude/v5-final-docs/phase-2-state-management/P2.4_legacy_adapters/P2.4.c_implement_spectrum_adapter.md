# Task ID: P2.4.c - Implement SpectrumAdapter

**Sub-phase:** P2.4
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement `SpectrumAdapter` that wraps the legacy `SpectrumAssignment` class to satisfy the `SpectrumPipeline` protocol.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.a_design_adapter_pattern.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.b_implement_routing_adapter.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.c_design_spectrum_protocol.md`

## Outputs

### 1. Create fusion/core/adapters/spectrum_adapter.py

```python
"""
SpectrumAdapter - Adapts legacy SpectrumAssignment to SpectrumPipeline protocol.

ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
It will be replaced with a clean implementation in Phase 4.

Phase: P2.4 - Legacy Adapters
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

from fusion.interfaces.pipelines import SpectrumPipeline

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.results import SpectrumResult

logger = logging.getLogger(__name__)


@dataclass
class SpectrumPropsProxy:
    """
    Proxy for SpectrumProps to capture legacy spectrum assignment output.

    Used internally by SpectrumAdapter to collect results from legacy code.
    """

    is_free: bool = False
    start_slot: int = 0
    end_slot: int = 0
    core_number: int = 0
    current_band: str = "c"
    modulation: str = ""
    slots_needed: int = 0
    snr_db: float = 0.0
    xt_cost: float = 0.0
    lightpath_id: int = 0

    def to_spectrum_result(self) -> SpectrumResult:
        """Convert captured output to Phase 1 SpectrumResult."""
        from fusion.domain.results import SpectrumResult

        if not self.is_free:
            return SpectrumResult.not_found(self.slots_needed)

        return SpectrumResult(
            is_free=True,
            start_slot=self.start_slot,
            end_slot=self.end_slot,
            core=self.core_number,
            band=self.current_band,
            modulation=self.modulation,
            slots_needed=self.slots_needed,
        )


@dataclass
class RoutePropsProxy:
    """Minimal proxy for route_props needed by SpectrumAssignment."""

    paths_matrix: list[list[str]] = field(default_factory=list)
    weights_list: list[float] = field(default_factory=list)
    modulation_formats_matrix: list[list[str]] = field(default_factory=list)


@dataclass
class SDNPropsProxy:
    """
    Minimal proxy for SDNProps to satisfy legacy SpectrumAssignment.

    Implements attributes that SpectrumAssignment actually reads.
    """

    topology: Any  # nx.Graph
    network_spectrum_dict: dict[tuple[str, str], dict[str, Any]] = field(
        default_factory=dict
    )
    lightpath_status_dict: dict[tuple[str, str], dict[int, dict[str, Any]]] = field(
        default_factory=dict
    )
    current_lightpath_id: int = 0

    @classmethod
    def from_network_state(cls, network_state: NetworkState) -> SDNPropsProxy:
        """Create proxy from NetworkState."""
        return cls(
            topology=network_state.topology,
            network_spectrum_dict=network_state.network_spectrum_dict,
            lightpath_status_dict=network_state.lightpath_status_dict,
            current_lightpath_id=network_state.next_lightpath_id,
        )


class SpectrumAdapter(SpectrumPipeline):
    """
    Adapts legacy SpectrumAssignment class to SpectrumPipeline protocol.

    ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
    It will be replaced with a clean implementation in Phase 4.

    The adapter:
    1. Receives Phase 1 objects (NetworkState, path, modulation)
    2. Creates proxy objects for legacy code
    3. Calls legacy SpectrumAssignment.get_spectrum()
    4. Converts spectrum_props to SpectrumResult

    Removal Checklist:
    [ ] Clean SpectrumPipeline implementation exists
    [ ] All callers migrated to clean implementation
    [ ] run_comparison.py passes without this adapter
    [ ] grep 'SpectrumAdapter' returns only this definition

    Example:
        >>> config = SimulationConfig.from_engine_props(engine_props)
        >>> adapter = SpectrumAdapter(config)
        >>> result = adapter.find_spectrum(["A", "B"], "QPSK", 100, network_state)
        >>> if result.is_free:
        ...     print(f"Found spectrum: slots {result.start_slot}-{result.end_slot}")
    """

    def __init__(self, config: SimulationConfig) -> None:
        """
        Initialize adapter with configuration.

        Args:
            config: SimulationConfig for creating legacy engine_props
        """
        self._config = config
        self._engine_props = config.to_engine_props()

    def find_spectrum(
        self,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        """
        Find available spectrum along a path.

        Args:
            path: Ordered list of node IDs
            modulation: Modulation format name
            bandwidth_gbps: Required bandwidth
            network_state: Current network state

        Returns:
            SpectrumResult with slot allocation if found
        """
        from fusion.domain.results import SpectrumResult

        try:
            # Create proxies
            sdn_props = SDNPropsProxy.from_network_state(network_state)
            route_props = RoutePropsProxy(
                paths_matrix=[path],
                modulation_formats_matrix=[[modulation]],
            )
            spectrum_props = SpectrumPropsProxy(modulation=modulation)

            # Import and instantiate legacy SpectrumAssignment
            from fusion.core.spectrum_assignment import SpectrumAssignment

            legacy_spectrum = SpectrumAssignment(
                engine_props=self._engine_props,
                sdn_props=sdn_props,
                route_props=route_props,
                spectrum_props=spectrum_props,
                snr_measurements=None,  # SNR handled separately
            )

            # Call legacy method
            found = legacy_spectrum.get_spectrum(
                path=path,
                modulation=modulation,
                bandwidth=float(bandwidth_gbps),
            )

            # Convert to Phase 1 result
            if found:
                return spectrum_props.to_spectrum_result()
            else:
                slots_needed = self._calculate_slots_needed(bandwidth_gbps, modulation)
                return SpectrumResult.not_found(slots_needed)

        except Exception as e:
            logger.warning(f"SpectrumAdapter.find_spectrum failed: {e}")
            slots_needed = self._calculate_slots_needed(bandwidth_gbps, modulation)
            return SpectrumResult.not_found(slots_needed)

    def find_protected_spectrum(
        self,
        primary_path: list[str],
        backup_path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        """
        Find spectrum for both primary and backup paths (1+1 protection).

        Args:
            primary_path: Primary route node sequence
            backup_path: Backup route node sequence
            modulation: Modulation format name
            bandwidth_gbps: Required bandwidth
            network_state: Current network state

        Returns:
            SpectrumResult with both primary and backup allocations
        """
        from fusion.domain.results import SpectrumResult

        # Find primary spectrum
        primary_result = self.find_spectrum(
            primary_path, modulation, bandwidth_gbps, network_state
        )
        if not primary_result.is_free:
            return primary_result  # Return not_found result

        # Find backup spectrum
        backup_result = self.find_spectrum(
            backup_path, modulation, bandwidth_gbps, network_state
        )
        if not backup_result.is_free:
            return SpectrumResult.not_found(primary_result.slots_needed)

        # Combine into single result with backup info
        return SpectrumResult(
            is_free=True,
            start_slot=primary_result.start_slot,
            end_slot=primary_result.end_slot,
            core=primary_result.core,
            band=primary_result.band,
            modulation=modulation,
            slots_needed=primary_result.slots_needed,
            backup_start_slot=backup_result.start_slot,
            backup_end_slot=backup_result.end_slot,
            backup_core=backup_result.core,
            backup_band=backup_result.band,
        )

    def _calculate_slots_needed(
        self,
        bandwidth_gbps: int,
        modulation: str,
    ) -> int:
        """Calculate spectrum slots needed for bandwidth and modulation."""
        import math

        # Get modulation efficiency
        mod_formats = self._config.modulation_formats
        mod_info = mod_formats.get(modulation, {})
        bits_per_symbol = mod_info.get("bits_per_symbol", 2)  # Default QPSK

        # Standard slot bandwidth
        slot_bandwidth_ghz = 12.5

        # Calculate data slots
        data_slots = math.ceil(bandwidth_gbps / (slot_bandwidth_ghz * bits_per_symbol))

        # Add guard slots
        total_slots = data_slots + self._config.guard_slots

        return total_slots
```

## Verification Commands

```bash
# Type checking
mypy fusion/core/adapters/spectrum_adapter.py --strict

# Linting
ruff check fusion/core/adapters/spectrum_adapter.py

# Smoke test
python -c "
from fusion.core.adapters.spectrum_adapter import SpectrumAdapter
print('SpectrumAdapter imported successfully')
"
```

## Important Notes

### SNR Integration

SNR measurements are handled separately:
- `snr_measurements=None` passed to legacy SpectrumAssignment
- SNR validation done via SNRAdapter after spectrum found

### Protected Spectrum

The `find_protected_spectrum` method:
1. Finds spectrum on primary path
2. Finds spectrum on backup path
3. Combines into single SpectrumResult with backup fields

### Slots Calculation

The adapter includes `_calculate_slots_needed()` for error reporting:
- Used when spectrum not found
- Reports how many slots were needed

## Next Task

After implementing SpectrumAdapter, proceed to `P2.4.d_implement_grooming_snr_adapters.md`.
