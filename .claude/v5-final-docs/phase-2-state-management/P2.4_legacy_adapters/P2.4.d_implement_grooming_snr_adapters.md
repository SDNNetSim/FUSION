# Task ID: P2.4.d - Implement Grooming and SNR Adapters

**Sub-phase:** P2.4
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement `GroomingAdapter` and `SNRAdapter` that wrap their respective legacy classes.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.a_design_adapter_pattern.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.d_design_grooming_snr_slicing_protocols.md`

## Outputs

### 1. Create fusion/core/adapters/grooming_adapter.py

```python
"""
GroomingAdapter - Adapts legacy Grooming class to GroomingPipeline protocol.

ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
It will be replaced with a clean implementation in Phase 4.

Phase: P2.4 - Legacy Adapters
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

from fusion.interfaces.pipelines import GroomingPipeline

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import GroomingResult

logger = logging.getLogger(__name__)


@dataclass
class SDNPropsProxy:
    """
    Proxy for SDNProps to satisfy legacy Grooming class.

    Includes request-specific fields that Grooming reads.
    """

    topology: Any  # nx.Graph
    network_spectrum_dict: dict[tuple[str, str], dict[str, Any]] = field(
        default_factory=dict
    )
    lightpath_status_dict: dict[tuple[str, str], dict[int, dict[str, Any]]] = field(
        default_factory=dict
    )

    # Request-specific fields
    source: str = ""
    destination: str = ""
    bandwidth: float = 0.0
    request_id: int = 0

    @classmethod
    def from_network_state_and_request(
        cls,
        network_state: NetworkState,
        request: Request,
    ) -> SDNPropsProxy:
        """Create proxy from NetworkState and Request."""
        return cls(
            topology=network_state.topology,
            network_spectrum_dict=network_state.network_spectrum_dict,
            lightpath_status_dict=network_state.lightpath_status_dict,
            source=request.source,
            destination=request.destination,
            bandwidth=float(request.bandwidth_gbps),
            request_id=request.request_id,
        )


class GroomingAdapter(GroomingPipeline):
    """
    Adapts legacy Grooming class to GroomingPipeline protocol.

    ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
    It will be replaced with a clean implementation in Phase 4.

    Note: Grooming has SIDE EFFECTS - it modifies lightpath bandwidth.
    The rollback_groom method provides compensation.

    Removal Checklist:
    [ ] Clean GroomingPipeline implementation exists
    [ ] All callers migrated to clean implementation
    [ ] run_comparison.py passes without this adapter
    [ ] grep 'GroomingAdapter' returns only this definition

    Example:
        >>> adapter = GroomingAdapter(config)
        >>> result = adapter.try_groom(request, network_state)
        >>> if result.fully_groomed:
        ...     print("Request fully groomed onto existing lightpaths")
    """

    def __init__(self, config: SimulationConfig) -> None:
        """Initialize adapter with configuration."""
        self._config = config
        self._engine_props = config.to_engine_props()

    def try_groom(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> GroomingResult:
        """
        Attempt to groom request onto existing lightpaths.

        Args:
            request: The request to groom
            network_state: Current network state

        Returns:
            GroomingResult indicating grooming outcome

        Side Effects:
            If grooming succeeds, modifies lightpath bandwidth allocations.
        """
        from fusion.domain.results import GroomingResult

        try:
            # Create proxy with request info
            sdn_props = SDNPropsProxy.from_network_state_and_request(
                network_state, request
            )

            # Import and instantiate legacy Grooming
            from fusion.core.grooming import Grooming

            legacy_grooming = Grooming(
                engine_props=self._engine_props,
                sdn_props=sdn_props,
            )

            # Call legacy method for arrival
            fully_groomed, lightpath_ids, forced_path = legacy_grooming.handle_grooming(
                request_type="arrival"
            )

            # Convert to Phase 1 result
            if fully_groomed:
                return GroomingResult.full(
                    bandwidth_gbps=request.bandwidth_gbps,
                    lightpath_ids=lightpath_ids,
                )
            elif lightpath_ids:
                # Partial grooming
                groomed_bw = self._calculate_groomed_bandwidth(
                    lightpath_ids, request.request_id, network_state
                )
                return GroomingResult.partial(
                    bandwidth_groomed=groomed_bw,
                    remaining=request.bandwidth_gbps - groomed_bw,
                    lightpath_ids=lightpath_ids,
                    forced_path=tuple(forced_path) if forced_path else None,
                )
            else:
                return GroomingResult.no_grooming(request.bandwidth_gbps)

        except Exception as e:
            logger.warning(f"GroomingAdapter.try_groom failed: {e}")
            return GroomingResult.no_grooming(request.bandwidth_gbps)

    def rollback_groom(
        self,
        request: Request,
        lightpath_ids: list[int],
        network_state: NetworkState,
    ) -> None:
        """
        Rollback grooming allocations.

        Args:
            request: The request that was groomed
            lightpath_ids: Lightpath IDs to rollback
            network_state: Current network state

        Side Effects:
            Releases bandwidth from specified lightpaths.
        """
        for lp_id in lightpath_ids:
            lp = network_state.get_lightpath(lp_id)
            if lp is not None:
                lp.release_bandwidth(request.request_id)

    def _calculate_groomed_bandwidth(
        self,
        lightpath_ids: list[int],
        request_id: int,
        network_state: NetworkState,
    ) -> int:
        """Calculate total bandwidth groomed for request."""
        total = 0
        for lp_id in lightpath_ids:
            lp = network_state.get_lightpath(lp_id)
            if lp is not None:
                allocation = lp.get_allocation(request_id)
                if allocation is not None:
                    total += allocation
        return total
```

### 2. Create fusion/core/adapters/snr_adapter.py

```python
"""
SNRAdapter - Adapts legacy SnrMeasurements to SNRPipeline protocol.

ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
It will be replaced with a clean implementation in Phase 4.

Phase: P2.4 - Legacy Adapters
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

from fusion.interfaces.pipelines import SNRPipeline

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.lightpath import Lightpath
    from fusion.domain.network_state import NetworkState
    from fusion.domain.results import SNRResult

logger = logging.getLogger(__name__)


@dataclass
class SDNPropsProxy:
    """Proxy for SDNProps to satisfy legacy SnrMeasurements."""

    topology: Any  # nx.Graph
    network_spectrum_dict: dict[tuple[str, str], dict[str, Any]] = field(
        default_factory=dict
    )

    @classmethod
    def from_network_state(cls, network_state: NetworkState) -> SDNPropsProxy:
        """Create proxy from NetworkState."""
        return cls(
            topology=network_state.topology,
            network_spectrum_dict=network_state.network_spectrum_dict,
        )


@dataclass
class SpectrumPropsProxy:
    """Proxy for SpectrumProps for SNR output."""

    snr_db: float = 0.0
    xt_cost: float = 0.0


class SNRAdapter(SNRPipeline):
    """
    Adapts legacy SnrMeasurements class to SNRPipeline protocol.

    ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
    It will be replaced with a clean implementation in Phase 4.

    The adapter:
    1. Extracts parameters from Lightpath object
    2. Creates proxy objects for legacy code
    3. Calls legacy SnrMeasurements.calculate_snr()
    4. Converts result to SNRResult

    Removal Checklist:
    [ ] Clean SNRPipeline implementation exists
    [ ] All callers migrated to clean implementation
    [ ] run_comparison.py passes without this adapter
    [ ] grep 'SNRAdapter' returns only this definition

    Example:
        >>> adapter = SNRAdapter(config)
        >>> result = adapter.validate(lightpath, network_state)
        >>> if result.passed:
        ...     print(f"SNR: {result.snr_db} dB (margin: {result.margin_db} dB)")
    """

    def __init__(self, config: SimulationConfig) -> None:
        """Initialize adapter with configuration."""
        self._config = config
        self._engine_props = config.to_engine_props()

    def validate(
        self,
        lightpath: Lightpath,
        network_state: NetworkState,
    ) -> SNRResult:
        """
        Validate SNR for a lightpath.

        Args:
            lightpath: The lightpath to validate
            network_state: Current network state

        Returns:
            SNRResult indicating pass/fail and measurements
        """
        from fusion.domain.results import SNRResult

        # Check if SNR is enabled
        if not self._config.snr_enabled:
            return SNRResult.skipped()

        try:
            # Create proxies
            sdn_props = SDNPropsProxy.from_network_state(network_state)
            spectrum_props = SpectrumPropsProxy()

            # Import and instantiate legacy SnrMeasurements
            from fusion.core.snr_measurements import SnrMeasurements

            legacy_snr = SnrMeasurements(
                engine_props=self._engine_props,
                sdn_props=sdn_props,
                spectrum_props=spectrum_props,
            )

            # Call legacy method
            passed, snr_db = legacy_snr.calculate_snr(
                path=lightpath.path,
                modulation=lightpath.modulation,
                start_slot=lightpath.start_slot,
                end_slot=lightpath.end_slot,
                core=lightpath.core,
                band=lightpath.band,
            )

            # Get required SNR threshold
            required_snr = self._config.snr_thresholds.get(
                lightpath.modulation, 10.0
            )

            # Convert to Phase 1 result
            if passed:
                return SNRResult.success(snr_db, required_snr)
            else:
                return SNRResult.failure(
                    snr_db=snr_db,
                    required_snr_db=required_snr,
                    reason="SNR below threshold",
                )

        except Exception as e:
            logger.warning(f"SNRAdapter.validate failed: {e}")
            return SNRResult.failure(
                snr_db=0.0,
                required_snr_db=10.0,
                reason=f"SNR calculation error: {e}",
            )
```

### 3. Update __init__.py

Ensure `fusion/core/adapters/__init__.py` exports all adapters (already done in P2.4.b).

## Verification Commands

```bash
# Type checking
mypy fusion/core/adapters/grooming_adapter.py --strict
mypy fusion/core/adapters/snr_adapter.py --strict

# Linting
ruff check fusion/core/adapters/

# Smoke test
python -c "
from fusion.core.adapters import (
    RoutingAdapter,
    SpectrumAdapter,
    GroomingAdapter,
    SNRAdapter,
)
print('All adapters imported successfully')
"
```

## Important Notes

### Grooming Side Effects

GroomingAdapter is the only adapter with side effects:
- `try_groom()` modifies lightpath bandwidth allocations
- `rollback_groom()` provides compensation on failure
- Side effects happen on the actual Lightpath objects in NetworkState

### SNR Skipping

When SNR is disabled (`snr_enabled=False`), the adapter returns:
```python
SNRResult.skipped()
```

This indicates SNR was not checked, not that it passed/failed.

### Slicing Note

`SlicingPipeline` is not implemented as an adapter in this task because:
1. Slicing is less commonly used
2. Can be added in Phase 3 if needed
3. The protocol is defined, implementation can be added later

## Next Task

After implementing these adapters, proceed to `P2.4.e_verify_adapters.md`.
