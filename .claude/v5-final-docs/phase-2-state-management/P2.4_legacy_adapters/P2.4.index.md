# P2.4 Legacy Adapters - Index

## Sub-phase Overview

**Goal**: Create adapter classes that wrap legacy implementations to satisfy the new pipeline protocols, enabling gradual migration.

**Output**: `fusion/core/adapters/` package with adapter classes

**Dependencies**:
- P2.1-P2.2 complete (NetworkState fully functional)
- P2.3 complete (Pipeline protocols defined)
- Phase 1 complete (All domain and result objects)

## Objectives

1. Create `fusion/core/adapters/` package structure
2. Implement adapter classes for each legacy pipeline:
   - `RoutingAdapter` - Wraps `Routing` class
   - `SpectrumAdapter` - Wraps `SpectrumAssignment` class
   - `GroomingAdapter` - Wraps `Grooming` class
   - `SNRAdapter` - Wraps `SnrMeasurements` class
   - `SlicingAdapter` - Wraps `LightPathSlicingManager` class (from Gap Analysis)
3. Each adapter implements its corresponding protocol
4. Adapters convert between Phase 1 objects and legacy formats
5. Mark adapters as temporary migration components

## Constraints

- Adapters wrap legacy code **without modifying it**
- Legacy algorithms must produce identical results
- All adapters implement pipeline protocols from P2.3
- Adapters must pass `mypy --strict` and `ruff check`
- Clearly marked for removal in later phases
- No changes to files outside `fusion/core/adapters/`

## Micro-tasks

Execute in alphabetical order:

| Task ID | File | Type | Description |
|---------|------|------|-------------|
| P2.4.a | `P2.4.a_design_adapter_pattern.md` | design | Design common adapter patterns |
| P2.4.b | `P2.4.b_implement_routing_adapter.md` | refactor-plan | Implement RoutingAdapter |
| P2.4.c | `P2.4.c_implement_spectrum_adapter.md` | refactor-plan | Implement SpectrumAdapter |
| P2.4.d | `P2.4.d_implement_grooming_snr_adapters.md` | refactor-plan | Implement remaining adapters |
| P2.4.e | `P2.4.e_verify_adapters.md` | verification-plan | Side-by-side comparison tests |

## Shared Context

- `P2.4.shared_context_legacy_impls.md` - Summary of legacy classes to wrap

## File Structure

```
fusion/
└── core/
    └── adapters/
        ├── __init__.py           # Public exports
        ├── routing_adapter.py    # RoutingAdapter
        ├── spectrum_adapter.py   # SpectrumAdapter
        ├── grooming_adapter.py   # GroomingAdapter
        └── snr_adapter.py        # SNRAdapter
```

## Adapter Pattern Overview

Each adapter follows this pattern:

```python
class RoutingAdapter(RoutingPipeline):
    """
    Adapts legacy Routing class to RoutingPipeline protocol.

    ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
    It will be replaced with a clean implementation in Phase 4.

    Removal Checklist:
    [ ] Clean RoutingPipeline implementation exists
    [ ] All callers migrated to clean implementation
    [ ] run_comparison.py passes without this adapter
    [ ] grep 'RoutingAdapter' returns only this definition
    """

    def __init__(self, config: SimulationConfig) -> None:
        # Initialize legacy component
        self._legacy_routing = Routing(...)
        self._config = config

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        # 1. Convert Phase 1 objects to legacy format
        engine_props = self._config.to_engine_props()
        sdn_props = self._create_legacy_sdn_props(network_state)

        # 2. Call legacy implementation
        self._legacy_routing.get_route(source, destination, bandwidth_gbps)

        # 3. Convert result to Phase 1 format
        return RouteResult.from_routing_props(self._legacy_routing.route_props)
```

## Conversion Helpers

Common conversion methods used by adapters:

```python
class AdapterHelpers:
    @staticmethod
    def create_legacy_sdn_props(network_state: NetworkState) -> Any:
        """Create minimal sdn_props proxy for legacy code."""
        # Use network_state.network_spectrum_dict property
        # Use network_state.lightpath_status_dict property
        ...

    @staticmethod
    def create_legacy_engine_props(config: SimulationConfig) -> Any:
        """Create engine_props from SimulationConfig."""
        return config.to_engine_props()
```

## Stateless Adapter Pattern (from Gap Analysis)

**Critical**: Legacy code relies on `sdn_props` being mutated between calls within a single request's event handling. Adapters must handle this by creating fresh state per call:

```python
class RoutingAdapter(RoutingPipeline):
    """
    Stateless adapter pattern - no state carried between calls.

    Each method call:
    1. Creates fresh property objects (route_props, etc.)
    2. Creates a read-only SDNProps proxy from NetworkState
    3. Calls legacy code
    4. Converts results to Phase 1 objects
    5. Discards all intermediate state
    """

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        # CRITICAL: Create FRESH props each call - no state carryover
        route_props = RoutingProps()

        # Create minimal read-only sdn_props proxy
        class SDNPropsProxy:
            """Read-only proxy to NetworkState for legacy compatibility."""

            def __init__(self, ns: NetworkState, src: str, dst: str, bw: int):
                self.topology = ns.topology
                self.source = src
                self.destination = dst
                self.bandwidth = bw
                # Read-only spectrum access (mutations don't persist)
                self.network_spectrum_dict = ns.network_spectrum_dict

        sdn_props = SDNPropsProxy(network_state, source, destination, bandwidth_gbps)

        # Call legacy code
        routing = Routing(
            engine_props=self._config.to_engine_props(),
            sdn_props=sdn_props,
            route_props=route_props,
        )
        routing.get_route()

        # Convert to Phase 1 result - intermediate state is discarded
        return RouteResult(
            paths=route_props.paths_matrix,
            modulations=route_props.modulation_formats_matrix,
            weights_km=route_props.weights_list,
        )
```

### State Isolation Requirements

| Adapter | Legacy State Used | Isolation Pattern |
|---------|------------------|-------------------|
| RoutingAdapter | `route_props`, `sdn_props.topology` | Fresh RouteProps per call, read-only topology |
| SpectrumAdapter | `spectrum_props`, `sdn_props.network_spectrum_dict` | Fresh SpectrumProps per call, read-only spectrum |
| GroomingAdapter | `sdn_props.lightpath_status_dict` | Proxy to NetworkState, mutations via NetworkState methods |
| SNRAdapter | `snr_props`, `spectrum_props` | Fresh props per call, read-only spectrum |
| SlicingAdapter | Combines routing + spectrum | Delegates to other adapters |

### Grooming Adapter - Exception to Stateless Pattern

GroomingAdapter is unique because it MUST mutate NetworkState (allocating bandwidth on lightpaths):

```python
class GroomingAdapter(GroomingPipeline):
    """
    GroomingAdapter is NOT fully stateless - it mutates NetworkState.

    The grooming operation allocates bandwidth on existing lightpaths,
    which requires modifying NetworkState.remaining_bandwidth and
    adding entries to NetworkState.request_allocations.
    """

    def try_groom(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> GroomingResult:
        # Find candidate lightpaths (read-only query)
        candidates = network_state.get_lightpaths_for_od_pair(
            request.source, request.destination
        )

        # Attempt grooming
        groomed_lightpaths = []
        remaining_bw = request.bandwidth_gbps

        for lp in candidates:
            if lp.remaining_bandwidth_gbps > 0 and remaining_bw > 0:
                alloc = min(lp.remaining_bandwidth_gbps, remaining_bw)

                # MUTATION: Allocate bandwidth via NetworkState
                network_state.allocate_request_bandwidth(
                    lightpath_id=lp.id,
                    request_id=request.request_id,
                    bandwidth_gbps=alloc,
                    arrival_time=request.arrive_time,
                )

                groomed_lightpaths.append(lp.id)
                remaining_bw -= alloc

        # Return result
        if remaining_bw == 0:
            return GroomingResult.full(...)
        elif groomed_lightpaths:
            return GroomingResult.partial(...)
        else:
            return GroomingResult.no_grooming_available(...)
```

## Exit Criteria

- [ ] `fusion/core/adapters/` package created
- [ ] All four adapters implemented
- [ ] Each adapter implements its pipeline protocol
- [ ] Adapters produce identical results to legacy code
- [ ] Side-by-side tests pass
- [ ] `mypy --strict` passes on all adapter files
- [ ] `ruff check` passes on all adapter files
- [ ] Removal markers and checklists in all adapter docstrings

## Phase 2 Completion

After P2.4 completes, Phase 2 is complete. The deliverables are:

1. **NetworkState** (`fusion/domain/network_state.py`)
   - Single source of truth for network state
   - Read and write methods
   - Legacy compatibility properties

2. **Pipeline Protocols** (`fusion/interfaces/pipelines.py`)
   - Type-safe interfaces for all pipelines
   - No runtime behavior

3. **Legacy Adapters** (`fusion/core/adapters/`)
   - Wrap existing implementations
   - Satisfy new protocols
   - Enable gradual migration

## Next Phase

After Phase 2 completes, Phase 3 (Orchestrator Integration) begins:
- Wire adapters into simulation engine
- Replace direct legacy calls with adapter calls
- Validate behavior equivalence
