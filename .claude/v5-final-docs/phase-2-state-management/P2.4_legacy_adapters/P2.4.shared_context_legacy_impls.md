# P2.4 Shared Context: Legacy Implementations

## Purpose

This document summarizes the legacy classes that adapters will wrap. Reference this when implementing adapters.

## Source Files

| Legacy Class | File | Purpose |
|--------------|------|---------|
| `Routing` | `fusion/core/routing.py` | Route finding |
| `SpectrumAssignment` | `fusion/core/spectrum_assignment.py` | Spectrum allocation |
| `Grooming` | `fusion/core/grooming.py` | Traffic grooming |
| `SnrMeasurements` | `fusion/core/snr_measurements.py` | SNR calculation |

---

## Routing Class

**Location**: `fusion/core/routing.py`

### Constructor

```python
class Routing:
    def __init__(
        self,
        engine_props: dict,
        sdn_props: SDNProps,
        route_props: RouteProps,
    ) -> None:
        self.engine_props = engine_props
        self.sdn_props = sdn_props
        self.route_props = route_props
```

### Key Method: get_route()

```python
def get_route(
    self,
    source: int | str,
    destination: int | str,
    request_bandwidth: float,
) -> None:
    """
    Find routes from source to destination.

    Reads:
        - self.engine_props (topology, k_paths, route_method)
        - self.sdn_props.topology (NetworkX graph)

    Writes:
        - self.route_props.paths_matrix
        - self.route_props.weights_list
        - self.route_props.modulation_formats_matrix
    """
```

### State Dependencies

| Read | Source | Description |
|------|--------|-------------|
| `topology` | `sdn_props.topology` | Network graph |
| `k_paths` | `engine_props` | Number of paths to find |
| `route_method` | `engine_props` | Routing algorithm name |
| `modulation_formats` | `engine_props` | Valid modulation formats |

| Write | Target | Description |
|-------|--------|-------------|
| `paths_matrix` | `route_props` | List of paths found |
| `weights_list` | `route_props` | Path weights in km |
| `modulation_formats_matrix` | `route_props` | Modulations per path |

---

## SpectrumAssignment Class

**Location**: `fusion/core/spectrum_assignment.py`

### Constructor

```python
class SpectrumAssignment:
    def __init__(
        self,
        engine_props: dict,
        sdn_props: SDNProps,
        route_props: RouteProps,
        spectrum_props: SpectrumProps,
        snr_measurements: SnrMeasurements | None,
    ) -> None:
        self.engine_props = engine_props
        self.sdn_props = sdn_props
        self.route_props = route_props
        self.spectrum_props = spectrum_props
        self.snr_measurements = snr_measurements
```

### Key Method: get_spectrum()

```python
def get_spectrum(
    self,
    path: list[str],
    modulation: str,
    bandwidth: float,
) -> bool:
    """
    Find available spectrum on path.

    Reads:
        - self.sdn_props.network_spectrum_dict (spectrum state)
        - self.engine_props (allocation_method, band_list, etc.)

    Writes:
        - self.spectrum_props.is_free
        - self.spectrum_props.start_slot
        - self.spectrum_props.end_slot
        - self.spectrum_props.core_number
        - self.spectrum_props.current_band

    Returns:
        True if spectrum found, False otherwise
    """
```

### State Dependencies

| Read | Source | Description |
|------|--------|-------------|
| `network_spectrum_dict` | `sdn_props` | Per-link spectrum arrays |
| `allocation_method` | `engine_props` | first_fit, best_fit, etc. |
| `band_list` | `engine_props` | Bands to search |
| `cores_per_link` | `engine_props` | Number of cores |

| Write | Target | Description |
|-------|--------|-------------|
| `is_free` | `spectrum_props` | Whether spectrum found |
| `start_slot` | `spectrum_props` | First slot of allocation |
| `end_slot` | `spectrum_props` | Last slot (exclusive) |
| `core_number` | `spectrum_props` | Core index |
| `current_band` | `spectrum_props` | Band identifier |

---

## Grooming Class

**Location**: `fusion/core/grooming.py`

### Constructor

```python
class Grooming:
    def __init__(
        self,
        engine_props: dict,
        sdn_props: SDNProps,
    ) -> None:
        self.engine_props = engine_props
        self.sdn_props = sdn_props
```

### Key Method: handle_grooming()

```python
def handle_grooming(
    self,
    request_type: str,  # "arrival" or "release"
) -> tuple[bool, list[int], list[str] | None]:
    """
    Handle grooming for request arrival or release.

    For arrival:
        - Search lightpath_status_dict for capacity
        - Allocate bandwidth if found

    For release:
        - Find lightpaths serving request
        - Release bandwidth allocations

    Reads:
        - self.sdn_props.lightpath_status_dict
        - Current request info from sdn_props

    Writes:
        - Lightpath bandwidth allocations (in lightpath_status_dict)

    Returns:
        (is_fully_groomed, lightpath_ids_used, forced_path_or_none)
    """
```

### State Dependencies

| Read | Source | Description |
|------|--------|-------------|
| `lightpath_status_dict` | `sdn_props` | Active lightpaths |
| Request info | `sdn_props` | Source, dest, bandwidth |

| Write | Target | Description |
|-------|--------|-------------|
| `remaining_bandwidth` | lightpath entries | Bandwidth allocation |
| `requests_dict` | lightpath entries | Request tracking |

---

## SnrMeasurements Class

**Location**: `fusion/core/snr_measurements.py`

### Constructor

```python
class SnrMeasurements:
    def __init__(
        self,
        engine_props: dict,
        sdn_props: SDNProps,
        spectrum_props: SpectrumProps,
    ) -> None:
        self.engine_props = engine_props
        self.sdn_props = sdn_props
        self.spectrum_props = spectrum_props
```

### Key Method: calculate_snr()

```python
def calculate_snr(
    self,
    path: list[str],
    modulation: str,
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
) -> tuple[bool, float]:
    """
    Calculate SNR for potential allocation.

    Reads:
        - self.sdn_props.network_spectrum_dict (for interference)
        - self.engine_props (SNR thresholds, physical params)

    Writes:
        - self.spectrum_props.snr_db (optional)

    Returns:
        (passes_threshold, snr_db_value)
    """
```

### State Dependencies

| Read | Source | Description |
|------|--------|-------------|
| `network_spectrum_dict` | `sdn_props` | Current allocations |
| `snr_thresholds` | `engine_props` | Per-modulation thresholds |
| Physical params | `engine_props` | Fiber parameters |

| Write | Target | Description |
|-------|--------|-------------|
| `snr_db` | `spectrum_props` | Calculated SNR |

---

## Property Objects

### RouteProps

```python
@dataclass
class RouteProps:
    paths_matrix: list[list[str]] = field(default_factory=list)
    weights_list: list[float] = field(default_factory=list)
    modulation_formats_matrix: list[list[str]] = field(default_factory=list)
```

### SpectrumProps

```python
@dataclass
class SpectrumProps:
    is_free: bool = False
    start_slot: int = 0
    end_slot: int = 0
    core_number: int = 0
    current_band: str = "c"
    snr_db: float = 0.0
    xt_cost: float = 0.0
```

---

## Adapter Conversion Notes

### engine_props Creation

```python
# From SimulationConfig
engine_props = config.to_engine_props()
```

### sdn_props Access

Use NetworkState legacy properties:
```python
# Instead of sdn_props.network_spectrum_dict
network_state.network_spectrum_dict

# Instead of sdn_props.lightpath_status_dict
network_state.lightpath_status_dict

# Instead of sdn_props.topology
network_state.topology
```

### Result Conversion

```python
# RouteProps -> RouteResult
RouteResult.from_routing_props(route_props)

# SpectrumProps -> SpectrumResult
SpectrumResult(
    is_free=spectrum_props.is_free,
    start_slot=spectrum_props.start_slot,
    end_slot=spectrum_props.end_slot,
    core=spectrum_props.core_number,
    band=spectrum_props.current_band,
    ...
)
```

---

## References

- Routing: `fusion/core/routing.py`
- Spectrum: `fusion/core/spectrum_assignment.py`
- Grooming: `fusion/core/grooming.py`
- SNR: `fusion/core/snr_measurements.py`
- Properties: `fusion/core/properties.py`
