# Task ID: P2.4.a - Design Adapter Pattern

**Sub-phase:** P2.4
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the common adapter pattern and helper utilities that all adapters will use.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.shared_context_legacy_impls.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.index.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.1_domain_scaffolding/P1.1.index.md`

## Outputs

### 1. Common Adapter Pattern

All adapters follow this structure:

```python
from typing import TYPE_CHECKING

from fusion.interfaces.pipelines import SomePipeline

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState


class SomeAdapter(SomePipeline):
    """
    Adapts legacy SomeClass to SomePipeline protocol.

    ADAPTER: This class is a TEMPORARY MIGRATION LAYER.
    It will be replaced with a clean implementation in Phase 4.

    The adapter:
    1. Receives Phase 1 objects (NetworkState, Request, etc.)
    2. Converts to legacy format (engine_props, sdn_props, etc.)
    3. Calls legacy implementation
    4. Converts result to Phase 1 format (RouteResult, etc.)

    Removal Checklist:
    [ ] Clean SomePipeline implementation exists
    [ ] All callers migrated to clean implementation
    [ ] run_comparison.py passes without this adapter
    [ ] grep 'SomeAdapter' returns only this definition
    """

    def __init__(self, config: SimulationConfig) -> None:
        """
        Initialize adapter with configuration.

        Args:
            config: SimulationConfig for creating legacy props

        Note:
            Does NOT store NetworkState - receives per-call
        """
        self._config = config
        self._engine_props = config.to_engine_props()
        self._legacy_component = LegacyClass(self._engine_props, ...)

    def protocol_method(
        self,
        ...,
        network_state: NetworkState,
    ) -> ResultType:
        """
        Protocol method implementation.

        1. Create legacy props from NetworkState
        2. Call legacy method
        3. Convert result to Phase 1 type
        """
        # Step 1: Create legacy sdn_props proxy
        sdn_props = self._create_sdn_props_proxy(network_state)

        # Step 2: Call legacy implementation
        self._legacy_component.legacy_method(...)

        # Step 3: Convert to Phase 1 result
        return ResultType.from_legacy(self._legacy_component.result_props)
```

### 2. SDN Props Proxy

Create a minimal proxy that provides what legacy code needs:

```python
from dataclasses import dataclass, field
from typing import Any

import networkx as nx


@dataclass
class SDNPropsProxy:
    """
    Minimal proxy for SDNProps to satisfy legacy code.

    Uses NetworkState properties instead of actual SDNProps.
    Only implements attributes accessed by legacy code.
    """

    network_spectrum_dict: dict[tuple[str, str], dict[str, Any]]
    lightpath_status_dict: dict[tuple[str, str], dict[int, dict[str, Any]]]
    topology: nx.Graph

    # Request tracking (set per-call)
    source: str = ""
    destination: str = ""
    bandwidth: float = 0.0

    @classmethod
    def from_network_state(
        cls,
        network_state: NetworkState,
    ) -> "SDNPropsProxy":
        """Create proxy from NetworkState."""
        return cls(
            network_spectrum_dict=network_state.network_spectrum_dict,
            lightpath_status_dict=network_state.lightpath_status_dict,
            topology=network_state.topology,
        )
```

### 3. Result Props Proxy

For capturing legacy output:

```python
@dataclass
class RoutePropsProxy:
    """Proxy for RouteProps to capture legacy output."""
    paths_matrix: list[list[str]] = field(default_factory=list)
    weights_list: list[float] = field(default_factory=list)
    modulation_formats_matrix: list[list[str]] = field(default_factory=list)

    def to_route_result(self) -> RouteResult:
        """Convert to Phase 1 RouteResult."""
        if not self.paths_matrix:
            return RouteResult.empty("legacy")

        return RouteResult(
            paths=tuple(tuple(p) for p in self.paths_matrix),
            weights_km=tuple(self.weights_list),
            modulations=tuple(tuple(m) for m in self.modulation_formats_matrix),
            strategy_name="legacy",
        )


@dataclass
class SpectrumPropsProxy:
    """Proxy for SpectrumProps to capture legacy output."""
    is_free: bool = False
    start_slot: int = 0
    end_slot: int = 0
    core_number: int = 0
    current_band: str = "c"
    modulation: str = ""
    slots_needed: int = 0
    snr_db: float = 0.0
    xt_cost: float = 0.0

    def to_spectrum_result(self) -> SpectrumResult:
        """Convert to Phase 1 SpectrumResult."""
        if not self.is_free:
            return SpectrumResult.not_found(self.slots_needed)

        return SpectrumResult(
            is_free=True,
            start_slot=self.start_slot,
            end_slot=self.end_slot,
            core=self.core_number,
            band=self.current_band,
            modulation=self.modulation,
            slots_needed=self.slots_needed,
        )
```

### 4. Adapter Base Class (Optional)

Common functionality can be extracted:

```python
class LegacyAdapterBase:
    """
    Base class for legacy adapters.

    Provides common utilities for converting between Phase 1 and legacy formats.
    """

    _config: SimulationConfig
    _engine_props: dict[str, Any]

    def __init__(self, config: SimulationConfig) -> None:
        self._config = config
        self._engine_props = config.to_engine_props()

    def _create_sdn_props_proxy(
        self,
        network_state: NetworkState,
    ) -> SDNPropsProxy:
        """Create SDNProps proxy from NetworkState."""
        return SDNPropsProxy.from_network_state(network_state)

    def _create_route_props_proxy(self) -> RoutePropsProxy:
        """Create empty RouteProps proxy for capturing output."""
        return RoutePropsProxy()

    def _create_spectrum_props_proxy(self) -> SpectrumPropsProxy:
        """Create empty SpectrumProps proxy for capturing output."""
        return SpectrumPropsProxy()
```

### 5. Design Decisions

| Decision | Rationale |
|----------|-----------|
| Proxy objects instead of actual props | Avoid modifying legacy classes |
| Proxies use NetworkState properties | Leverage P2.2 legacy compatibility |
| Config stored, NetworkState per-call | Config is immutable, state changes |
| to_*_result() on proxies | Clean conversion in one place |
| Optional base class | Reduces code duplication |

### 6. Adapter Lifecycle

```
1. Initialization (once per simulation)
   └── Store config, create engine_props

2. Per-request call
   ├── Receive NetworkState as parameter
   ├── Create sdn_props proxy from NetworkState
   ├── Create result props proxy
   ├── Call legacy method
   ├── Convert props to Phase 1 result
   └── Return result (discard proxies)
```

### 7. Error Handling

```python
def find_routes(self, ..., network_state) -> RouteResult:
    try:
        # Create proxies
        sdn_props = self._create_sdn_props_proxy(network_state)
        route_props = self._create_route_props_proxy()

        # Call legacy
        self._legacy_routing.get_route(source, destination, bandwidth)

        # Convert result
        return route_props.to_route_result()

    except Exception as e:
        # Log error but return empty result (matches legacy behavior)
        logger.warning(f"Routing failed: {e}")
        return RouteResult.empty("legacy_error")
```

### 8. Testing Strategy

Adapters should be tested by comparing results:

```python
def test_adapter_matches_legacy():
    # Setup identical state
    legacy_result = legacy_routing.get_route(...)
    adapter_result = routing_adapter.find_routes(...)

    # Compare
    assert adapter_result.paths == tuple(legacy_result.paths_matrix)
    assert adapter_result.weights_km == tuple(legacy_result.weights_list)
```

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.4.b-d.

Key considerations:
1. Proxies must expose what legacy code reads
2. NetworkState properties provide legacy format data
3. Config is stable, state changes per-call
4. Results converted immediately after legacy call

## Next Task

After completing this design, proceed to `P2.4.b_implement_routing_adapter.md`.
