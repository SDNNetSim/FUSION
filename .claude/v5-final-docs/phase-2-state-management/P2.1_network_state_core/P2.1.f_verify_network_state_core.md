# Task ID: P2.1.f - Verify NetworkState Core

**Sub-phase:** P2.1
**Scope:** Phase 2 - State Management only
**Task type:** verification-plan

## Purpose

Define comprehensive unit tests for `LinkSpectrum` and `NetworkState` read methods to ensure correct behavior before proceeding to P2.2.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.d_implement_link_spectrum.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.e_implement_network_state_reads.md`
- `fusion/domain/network_state.py` (implementation)

## Outputs

### 1. Create Test File

**File**: `fusion/tests/domain/test_network_state.py`

### 2. Test Implementation

```python
"""
Unit tests for NetworkState and LinkSpectrum.

Phase: P2.1 - NetworkState Core
Coverage Target: 90%+
"""

from __future__ import annotations

import numpy as np
import networkx as nx
import pytest

from fusion.domain.network_state import LinkSpectrum, NetworkState


# =============================================================================
# Fixtures
# =============================================================================

class MockSimulationConfig:
    """Mock config for testing without full SimulationConfig dependency."""

    def __init__(
        self,
        band_list: tuple[str, ...] = ("c",),
        band_slots: dict[str, int] | None = None,
        cores_per_link: int = 1,
    ) -> None:
        self.band_list = band_list
        self.band_slots = band_slots or {"c": 320}
        self.cores_per_link = cores_per_link


@pytest.fixture
def simple_config() -> MockSimulationConfig:
    """Single-band, single-core config."""
    return MockSimulationConfig()


@pytest.fixture
def multiband_config() -> MockSimulationConfig:
    """Multi-band config (C+L bands)."""
    return MockSimulationConfig(
        band_list=("c", "l"),
        band_slots={"c": 320, "l": 320},
        cores_per_link=1,
    )


@pytest.fixture
def multicore_config() -> MockSimulationConfig:
    """Multi-core config (7 cores)."""
    return MockSimulationConfig(
        band_list=("c",),
        band_slots={"c": 320},
        cores_per_link=7,
    )


@pytest.fixture
def simple_topology() -> nx.Graph:
    """Simple linear topology: A -- B -- C"""
    G = nx.Graph()
    G.add_edge("A", "B", length=100.0)
    G.add_edge("B", "C", length=150.0)
    return G


@pytest.fixture
def ring_topology() -> nx.Graph:
    """Ring topology: A -- B -- C -- D -- A"""
    G = nx.Graph()
    G.add_edge("A", "B", length=100.0)
    G.add_edge("B", "C", length=100.0)
    G.add_edge("C", "D", length=100.0)
    G.add_edge("D", "A", length=100.0)
    return G


# =============================================================================
# LinkSpectrum Tests
# =============================================================================

class TestLinkSpectrumInit:
    """Tests for LinkSpectrum initialization."""

    def test_from_config_single_band(self, simple_config: MockSimulationConfig) -> None:
        """Test creation with single band config."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)

        assert ls.link == ("A", "B")
        assert "c" in ls.cores_matrix
        assert ls.cores_matrix["c"].shape == (1, 320)
        assert np.all(ls.cores_matrix["c"] == 0)
        assert ls.usage_count == 0

    def test_from_config_multiband(self, multiband_config: MockSimulationConfig) -> None:
        """Test creation with multi-band config."""
        ls = LinkSpectrum.from_config(("A", "B"), multiband_config)

        assert "c" in ls.cores_matrix
        assert "l" in ls.cores_matrix
        assert ls.cores_matrix["c"].shape == (1, 320)
        assert ls.cores_matrix["l"].shape == (1, 320)

    def test_from_config_multicore(self, multicore_config: MockSimulationConfig) -> None:
        """Test creation with multi-core config."""
        ls = LinkSpectrum.from_config(("A", "B"), multicore_config)

        assert ls.cores_matrix["c"].shape == (7, 320)
        assert ls.get_core_count() == 7


class TestLinkSpectrumRangeFree:
    """Tests for is_range_free method."""

    def test_empty_spectrum_is_free(self, simple_config: MockSimulationConfig) -> None:
        """Empty spectrum should report all ranges as free."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)

        assert ls.is_range_free(0, 10, 0, "c")
        assert ls.is_range_free(100, 200, 0, "c")
        assert ls.is_range_free(0, 320, 0, "c")

    def test_occupied_range_not_free(self, simple_config: MockSimulationConfig) -> None:
        """Occupied range should not report as free."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)
        ls.cores_matrix["c"][0, 5:15] = 1  # Manually occupy slots

        assert not ls.is_range_free(0, 10, 0, "c")  # Overlaps
        assert not ls.is_range_free(5, 15, 0, "c")  # Exact match
        assert not ls.is_range_free(10, 20, 0, "c")  # Partial overlap
        assert ls.is_range_free(15, 25, 0, "c")  # After occupied

    def test_invalid_band_raises(self, simple_config: MockSimulationConfig) -> None:
        """Invalid band should raise KeyError."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)

        with pytest.raises(KeyError):
            ls.is_range_free(0, 10, 0, "invalid_band")


class TestLinkSpectrumAllocate:
    """Tests for allocate_range method."""

    def test_simple_allocation(self, simple_config: MockSimulationConfig) -> None:
        """Test basic spectrum allocation."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)
        ls.allocate_range(0, 10, 0, "c", lightpath_id=1)

        assert not ls.is_range_free(0, 10, 0, "c")
        assert np.all(ls.cores_matrix["c"][0, 0:10] == 1)
        assert ls.usage_count == 1

    def test_allocation_with_guard_band(self, simple_config: MockSimulationConfig) -> None:
        """Test allocation with guard band slots."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)
        ls.allocate_range(0, 12, 0, "c", lightpath_id=1, guard_slots=2)

        # Data slots should have positive ID
        assert np.all(ls.cores_matrix["c"][0, 0:10] == 1)
        # Guard slots should have negative ID
        assert np.all(ls.cores_matrix["c"][0, 10:12] == -1)

    def test_allocation_fails_if_not_free(self, simple_config: MockSimulationConfig) -> None:
        """Allocation should fail if range is occupied."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)
        ls.allocate_range(0, 10, 0, "c", lightpath_id=1)

        with pytest.raises(ValueError, match="not free"):
            ls.allocate_range(5, 15, 0, "c", lightpath_id=2)

    def test_allocation_fails_with_invalid_id(self, simple_config: MockSimulationConfig) -> None:
        """Allocation should fail with non-positive lightpath_id."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)

        with pytest.raises(ValueError, match="must be positive"):
            ls.allocate_range(0, 10, 0, "c", lightpath_id=0)

        with pytest.raises(ValueError, match="must be positive"):
            ls.allocate_range(0, 10, 0, "c", lightpath_id=-1)


class TestLinkSpectrumRelease:
    """Tests for release_range method."""

    def test_release_frees_spectrum(self, simple_config: MockSimulationConfig) -> None:
        """Release should free occupied spectrum."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)
        ls.allocate_range(0, 10, 0, "c", lightpath_id=1)
        ls.release_range(0, 10, 0, "c")

        assert ls.is_range_free(0, 10, 0, "c")
        assert np.all(ls.cores_matrix["c"][0, 0:10] == 0)
        assert ls.usage_count == 0

    def test_release_with_guard_band(self, simple_config: MockSimulationConfig) -> None:
        """Release should free both data and guard band slots."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)
        ls.allocate_range(0, 12, 0, "c", lightpath_id=1, guard_slots=2)
        ls.release_range(0, 12, 0, "c")

        assert ls.is_range_free(0, 12, 0, "c")

    def test_usage_count_clamps_to_zero(self, simple_config: MockSimulationConfig) -> None:
        """Usage count should not go negative."""
        ls = LinkSpectrum.from_config(("A", "B"), simple_config)
        ls.release_range(0, 10, 0, "c")  # Release on empty

        assert ls.usage_count == 0


# =============================================================================
# NetworkState Tests
# =============================================================================

class TestNetworkStateInit:
    """Tests for NetworkState initialization."""

    def test_init_simple_topology(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Test initialization with simple topology."""
        state = NetworkState(simple_topology, simple_config)

        assert state.link_count == 2
        assert state.lightpath_count == 0
        assert state.next_lightpath_id == 1

    def test_init_creates_bidirectional_links(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Both directions should reference same LinkSpectrum."""
        state = NetworkState(simple_topology, simple_config)

        ls_ab = state.get_link_spectrum(("A", "B"))
        ls_ba = state.get_link_spectrum(("B", "A"))

        assert ls_ab is ls_ba  # Same object

    def test_init_fails_empty_topology(self, simple_config: MockSimulationConfig) -> None:
        """Initialization should fail with empty topology."""
        empty_graph = nx.Graph()

        with pytest.raises(ValueError, match="at least one edge"):
            NetworkState(empty_graph, simple_config)

    def test_init_fails_empty_bands(self, simple_topology: nx.Graph) -> None:
        """Initialization should fail with no bands."""
        config = MockSimulationConfig(band_list=())

        with pytest.raises(ValueError, match="at least one band"):
            NetworkState(simple_topology, config)


class TestNetworkStateSpectrumAvailable:
    """Tests for is_spectrum_available method."""

    def test_available_on_empty(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Empty network should have all spectrum available."""
        state = NetworkState(simple_topology, simple_config)

        assert state.is_spectrum_available(["A", "B"], 0, 10, 0, "c")
        assert state.is_spectrum_available(["A", "B", "C"], 0, 10, 0, "c")

    def test_not_available_if_occupied(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Occupied spectrum should report not available."""
        state = NetworkState(simple_topology, simple_config)

        # Manually occupy spectrum on one link
        ls = state.get_link_spectrum(("A", "B"))
        ls.allocate_range(5, 15, 0, "c", lightpath_id=1)

        assert not state.is_spectrum_available(["A", "B"], 0, 10, 0, "c")
        assert state.is_spectrum_available(["B", "C"], 0, 10, 0, "c")  # Other link still free

    def test_fails_with_short_path(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Path with < 2 nodes should raise ValueError."""
        state = NetworkState(simple_topology, simple_config)

        with pytest.raises(ValueError, match="at least 2 nodes"):
            state.is_spectrum_available(["A"], 0, 10, 0, "c")

    def test_fails_with_invalid_link(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """Non-existent link should raise KeyError."""
        state = NetworkState(simple_topology, simple_config)

        with pytest.raises(KeyError):
            state.is_spectrum_available(["A", "C"], 0, 10, 0, "c")  # No direct A-C link


class TestNetworkStateFindFirstFit:
    """Tests for find_first_fit method."""

    def test_first_fit_empty_spectrum(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """First fit on empty spectrum should return 0."""
        state = NetworkState(simple_topology, simple_config)

        result = state.find_first_fit(["A", "B"], 10, 0, "c")
        assert result == 0

    def test_first_fit_skips_occupied(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """First fit should skip occupied slots."""
        state = NetworkState(simple_topology, simple_config)

        ls = state.get_link_spectrum(("A", "B"))
        ls.allocate_range(0, 10, 0, "c", lightpath_id=1)

        result = state.find_first_fit(["A", "B"], 10, 0, "c")
        assert result == 10

    def test_first_fit_none_when_full(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """First fit returns None when no space available."""
        state = NetworkState(simple_topology, simple_config)

        # Fill entire spectrum
        ls = state.get_link_spectrum(("A", "B"))
        ls.allocate_range(0, 320, 0, "c", lightpath_id=1)

        result = state.find_first_fit(["A", "B"], 10, 0, "c")
        assert result is None

    def test_first_fit_considers_all_links(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """First fit must find range free on ALL path links."""
        state = NetworkState(simple_topology, simple_config)

        # Occupy different slots on different links
        ls_ab = state.get_link_spectrum(("A", "B"))
        ls_bc = state.get_link_spectrum(("B", "C"))

        ls_ab.allocate_range(0, 10, 0, "c", lightpath_id=1)
        ls_bc.allocate_range(10, 20, 0, "c", lightpath_id=2)

        # First fit for path A-B-C must skip both occupied ranges
        result = state.find_first_fit(["A", "B", "C"], 10, 0, "c")
        assert result == 20


class TestNetworkStateLightpathQueries:
    """Tests for lightpath query methods."""

    def test_get_lightpath_not_found(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """get_lightpath returns None for non-existent ID."""
        state = NetworkState(simple_topology, simple_config)

        assert state.get_lightpath(999) is None

    def test_get_lightpaths_between_empty(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """get_lightpaths_between returns empty list when none exist."""
        state = NetworkState(simple_topology, simple_config)

        result = state.get_lightpaths_between("A", "B")
        assert result == []

    def test_iter_lightpaths_empty(
        self,
        simple_topology: nx.Graph,
        simple_config: MockSimulationConfig,
    ) -> None:
        """iter_lightpaths yields nothing when no lightpaths exist."""
        state = NetworkState(simple_topology, simple_config)

        result = list(state.iter_lightpaths())
        assert result == []


# =============================================================================
# Multi-band and Multi-core Tests
# =============================================================================

class TestMultiBandSupport:
    """Tests for multi-band spectrum support."""

    def test_independent_bands(
        self,
        simple_topology: nx.Graph,
        multiband_config: MockSimulationConfig,
    ) -> None:
        """Each band should have independent spectrum."""
        state = NetworkState(simple_topology, multiband_config)

        ls = state.get_link_spectrum(("A", "B"))
        ls.allocate_range(0, 10, 0, "c", lightpath_id=1)

        # C band occupied, L band still free
        assert not ls.is_range_free(0, 10, 0, "c")
        assert ls.is_range_free(0, 10, 0, "l")


class TestMultiCoreSupport:
    """Tests for multi-core spectrum support."""

    def test_independent_cores(
        self,
        simple_topology: nx.Graph,
        multicore_config: MockSimulationConfig,
    ) -> None:
        """Each core should have independent spectrum."""
        state = NetworkState(simple_topology, multicore_config)

        ls = state.get_link_spectrum(("A", "B"))
        ls.allocate_range(0, 10, 0, "c", lightpath_id=1)  # Core 0

        # Core 0 occupied, other cores still free
        assert not ls.is_range_free(0, 10, 0, "c")
        assert ls.is_range_free(0, 10, 1, "c")
        assert ls.is_range_free(0, 10, 6, "c")
```

### 3. Run Tests

```bash
# Run tests with coverage
pytest fusion/tests/domain/test_network_state.py -v --cov=fusion/domain/network_state --cov-report=term-missing

# Expected coverage: 90%+
```

## Verification Checklist

After running tests, verify:

- [ ] All tests pass
- [ ] Coverage >= 90% for `fusion/domain/network_state.py`
- [ ] `mypy fusion/domain/network_state.py --strict` passes
- [ ] `ruff check fusion/domain/network_state.py` passes
- [ ] No changes needed to other files

## Exit Criteria for P2.1

P2.1 is complete when:

1. `LinkSpectrum` dataclass implemented and tested
2. `NetworkState` with read methods implemented and tested
3. All verification checks pass
4. Coverage >= 90%

## Next Sub-phase

After P2.1 verification passes, proceed to [P2.2 Write Methods + Legacy Compat](../P2.2_network_state_writes_legacy/P2.2.index.md).
