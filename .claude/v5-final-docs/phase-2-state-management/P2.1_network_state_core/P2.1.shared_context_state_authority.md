# P2.1 Shared Context: State Authority Mapping

## Purpose

This document establishes the definitive mapping of where state lives in the legacy codebase and how it maps to the authoritative NetworkState core. This resolves ambiguity about state ownership and ensures all legacy write paths are properly captured.

## References

- Gap Analysis: `P2.0_gap_analysis.md`
- Legacy Source: `fusion/core/properties.py`
- Legacy Source: `fusion/core/sdn_controller.py`
- Legacy Source: `fusion/core/simulation.py`

---

## 1. Legacy State Containers

### 1.1 Primary State Containers

| Container | Class | Location | Scope |
|-----------|-------|----------|-------|
| `engine_props` | `dict[str, Any]` | SimulationEngine | Global configuration |
| `sdn_props` | `SDNProps` | SDNController | Network state + request state |
| `stats_props` | `StatsProps` | SimStats | Statistics aggregation |
| `reqs_status_dict` | `dict[int, dict]` | SimulationEngine | Request tracking |

### 1.2 Property/Result Containers (Per-Call)

| Container | Class | Location | Scope |
|-----------|-------|----------|-------|
| `route_props` | `RoutingProps` | Routing | Routing results |
| `spectrum_props` | `SpectrumProps` | SpectrumAssignment | Spectrum search results |
| `snr_props` | `SNRProps` | SnrMeasurements | SNR parameters |
| `grooming_props` | `GroomingProps` | Grooming | Grooming state |

---

## 2. State Authority Classification

### 2.1 NetworkState-Owned State

These state items are authoritatively managed by NetworkState:

```
+----------------------------------------------+
|              NetworkState Authority           |
+----------------------------------------------+
| Spectrum State                               |
|   - cores_matrix per link/band/core          |
|   - usage_count per link                     |
|   - throughput per link                      |
+----------------------------------------------+
| Lightpath State                              |
|   - Active lightpaths by ID                  |
|   - Lightpath configurations                 |
|   - Bandwidth allocations                    |
|   - Guard band positions                     |
+----------------------------------------------+
| Topology Reference                           |
|   - NetworkX graph (read-only ref)           |
|   - Node/edge metadata                       |
+----------------------------------------------+
| ID Generation                                |
|   - Next lightpath ID counter                |
+----------------------------------------------+
```

### 2.2 SimulationEngine-Owned State

These remain outside NetworkState:

```
+----------------------------------------------+
|          SimulationEngine Authority          |
+----------------------------------------------+
| Request Lifecycle                            |
|   - reqs_dict (request queue)                |
|   - reqs_status_dict (allocation tracking)   |
|   - iteration counter                        |
+----------------------------------------------+
| Controller References                        |
|   - sdn_obj (SDNController)                  |
|   - stats_obj (SimStats)                     |
|   - failure_manager                          |
+----------------------------------------------+
```

### 2.3 Configuration State (engine_props)

```
+----------------------------------------------+
|        Configuration (engine_props)          |
+----------------------------------------------+
| Topology Config                              |
|   - topology_info (initial topology def)     |
|   - band_list                                |
|   - cores_per_link                           |
+----------------------------------------------+
| Algorithm Config                             |
|   - route_method                             |
|   - allocation_method                        |
|   - k_paths                                  |
|   - max_segments                             |
+----------------------------------------------+
| Feature Flags                                |
|   - is_grooming_enabled                      |
|   - dynamic_lps                              |
|   - snr_type                                 |
|   - can_partially_serve                      |
+----------------------------------------------+
```

### 2.4 Statistics State (Out of Scope)

```
+----------------------------------------------+
|          Statistics (stats_props)            |
|              OUT OF SCOPE                    |
+----------------------------------------------+
| Aggregation Data                             |
|   - blocking statistics                      |
|   - resource utilization                     |
|   - performance metrics                      |
+----------------------------------------------+
```

---

## 3. Detailed SDNProps Field Mapping

### 3.1 Fields that Map to NetworkState

```python
# sdn_props.network_spectrum_dict -> NetworkState._spectrum
# Structure: dict[(src, dst), LinkSpectrum]
sdn_props.network_spectrum_dict: {
    (source, dest): {
        "cores_matrix": {band: np.ndarray[cores, slots]},
        "link_num": int,
        "usage_count": int,
        "throughput": float,
    }
}

# sdn_props.lightpath_status_dict -> NetworkState._lightpaths
# Key transformation required (see Section 4)
sdn_props.lightpath_status_dict: {
    (src_dest_tuple): {
        lightpath_id: {
            "path": list[str],
            "lightpath_bandwidth": float,
            "remaining_bandwidth": float,
            "band": str,
            "core": int,
            "start_slot": int,
            "end_slot": int,
            "mod_format": str,
            "requests_dict": dict[int, float],
            "time_bw_usage": dict[float, float],
            "is_degraded": bool,
            "path_weight": float,
            "snr_cost": float | None,
            "xt_cost": float | None,
        }
    }
}

# sdn_props.lightpath_counter -> NetworkState._next_lightpath_id
sdn_props.lightpath_counter: int

# sdn_props.topology -> NetworkState._topology
sdn_props.topology: nx.Graph
```

### 3.2 Fields that Stay in Request Context

```python
# These fields are PER-REQUEST and reset via sdn_props.reset_params()
# They do NOT belong in NetworkState

# Current request info
sdn_props.request_id: int
sdn_props.source: str
sdn_props.destination: str
sdn_props.bandwidth: float
sdn_props.arrive: float
sdn_props.depart: float

# Request allocation tracking (reset per request)
sdn_props.bandwidth_list: list[float]     # Bandwidths allocated per lightpath
sdn_props.modulation_list: list[str]      # Modulations used
sdn_props.core_list: list[int]            # Cores used
sdn_props.band_list: list[str]            # Bands used
sdn_props.start_slot_list: list[int]      # Start slots
sdn_props.end_slot_list: list[int]        # End slots
sdn_props.lightpath_id_list: list[int]    # Lightpaths used/created
sdn_props.lightpath_bandwidth_list: list[float]
sdn_props.was_new_lp_established: list[int]

# Request outcome flags
sdn_props.was_routed: bool
sdn_props.was_groomed: bool
sdn_props.was_partially_groomed: bool
sdn_props.was_partially_routed: bool
sdn_props.is_sliced: bool
sdn_props.block_reason: str
sdn_props.remaining_bw: int | float | str
```

### 3.3 Fields for Failure/Protection (Not in Phase 2)

```python
# These are for failure management, future phase
sdn_props.allocated_requests: dict[int, dict]  # Request ID -> allocation info
sdn_props.primary_path: list[int]
sdn_props.backup_path: list[int]
sdn_props.is_protected: bool
sdn_props.active_path: str
sdn_props.switchover_count: int
```

---

## 4. Key Structure Transformation

### 4.1 Lightpath Indexing Change

**Legacy Structure**:
```python
# Indexed by (source, destination) tuple, then lightpath_id
lightpath_status_dict[(src, dst)][lightpath_id] = {...}
```

**NetworkState Structure**:
```python
# Indexed directly by lightpath_id
_lightpaths[lightpath_id] = Lightpath(
    id=lightpath_id,
    path=[...],
    # ... other fields
)
```

**Transformation**:
```python
def migrate_lightpath_status_dict(
    legacy: dict[tuple, dict[int, dict]]
) -> dict[int, Lightpath]:
    """Transform legacy structure to NetworkState structure."""
    result = {}
    for (src, dst), lightpaths in legacy.items():
        for lp_id, lp_info in lightpaths.items():
            result[lp_id] = Lightpath(
                id=lp_id,
                path=lp_info["path"],
                bandwidth_gbps=int(lp_info["lightpath_bandwidth"]),
                remaining_bandwidth_gbps=int(lp_info["remaining_bandwidth"]),
                band=lp_info["band"],
                core=lp_info["core"],
                start_slot=lp_info["start_slot"],
                end_slot=lp_info["end_slot"],
                modulation=lp_info.get("mod_format", lp_info.get("modulation")),
                guard_slots=1,  # Inferred from slot range
                requests={
                    req_id: int(bw)
                    for req_id, bw in lp_info["requests_dict"].items()
                },
                is_degraded=lp_info.get("is_degraded", False),
            )
    return result
```

### 4.2 Backward-Compatible Lookup

```python
class NetworkState:
    def get_lightpaths_for_od_pair(
        self,
        source: str,
        destination: str,
    ) -> list[Lightpath]:
        """
        Get lightpaths between source and destination.

        Provides legacy-compatible lookup by OD pair.
        """
        # Normalize to sorted tuple for bidirectional lookup
        od_key = tuple(sorted([source, destination]))

        return [
            lp for lp in self._lightpaths.values()
            if tuple(sorted([lp.path[0], lp.path[-1]])) == od_key
        ]
```

---

## 5. State Mutation Boundaries

### 5.1 Read-Only Access Pattern

```python
# Components that only READ NetworkState:
# - Routing algorithms (read topology, spectrum)
# - Spectrum search (read spectrum availability)
# - SNR calculations (read current allocations)
# - Statistics collection (read utilization)

def example_read_pattern(network_state: NetworkState) -> None:
    # Read topology
    graph = network_state.topology

    # Read spectrum (returns copy or view)
    spectrum = network_state.get_link_spectrum(("A", "B"))

    # Read lightpaths
    lps = network_state.get_lightpaths_for_od_pair("A", "Z")

    # NEVER mutate these directly - changes are lost
```

### 5.2 Write Access Pattern

```python
# Components that WRITE NetworkState (via methods only):
# - SDNController.allocate() -> NetworkState.create_lightpath()
# - SDNController.release() -> NetworkState.delete_lightpath()
# - Grooming (bandwidth allocation) -> NetworkState.update_lightpath_bandwidth()

def example_write_pattern(network_state: NetworkState) -> None:
    # Create lightpath (spectrum marked, lightpath registered)
    lp = network_state.create_lightpath(
        path=["A", "B", "C"],
        start_slot=10,
        end_slot=18,
        core=0,
        band="c",
        modulation="QPSK",
        bandwidth_gbps=100,
    )

    # Update bandwidth allocation
    network_state.allocate_bandwidth_to_request(
        lightpath_id=lp.id,
        request_id=42,
        bandwidth_gbps=50,
    )

    # Delete lightpath (spectrum freed, lightpath deregistered)
    network_state.delete_lightpath(lp.id)
```

---

## 6. Legacy Compatibility Layer

### 6.1 network_spectrum_dict Property

```python
class NetworkState:
    @property
    def network_spectrum_dict(
        self,
    ) -> dict[tuple[str, str], dict[str, Any]]:
        """
        Legacy-compatible view of spectrum state.

        Returns a dict matching the legacy structure.
        Mutations through this view are NOT persisted.
        """
        return {
            link: {
                "cores_matrix": spectrum.cores_matrix,
                "link_num": spectrum.link_num,
                "usage_count": spectrum.usage_count,
                "throughput": spectrum.throughput,
            }
            for link, spectrum in self._spectrum.items()
        }
```

### 6.2 lightpath_status_dict Property

```python
class NetworkState:
    @property
    def lightpath_status_dict(
        self,
    ) -> dict[tuple[str, str], dict[int, dict[str, Any]]]:
        """
        Legacy-compatible view of lightpath state.

        Returns a dict matching the legacy structure.
        Mutations through this view are NOT persisted.
        """
        result: dict[tuple[str, str], dict[int, dict]] = {}

        for lp_id, lp in self._lightpaths.items():
            key = tuple(sorted([lp.path[0], lp.path[-1]]))
            if key not in result:
                result[key] = {}

            result[key][lp_id] = {
                "path": lp.path,
                "lightpath_bandwidth": lp.bandwidth_gbps,
                "remaining_bandwidth": lp.remaining_bandwidth_gbps,
                "band": lp.band,
                "core": lp.core,
                "start_slot": lp.start_slot,
                "end_slot": lp.end_slot,
                "mod_format": lp.modulation,
                "requests_dict": dict(lp.requests),
                "time_bw_usage": {},  # Computed on demand
                "is_degraded": lp.is_degraded,
                "path_weight": lp.path_weight_km,
                "snr_cost": lp.snr_cost,
                "xt_cost": lp.xt_cost,
            }

        return result
```

---

## 7. State Isolation for Testing

### 7.1 Snapshot/Restore

```python
class NetworkState:
    def snapshot(self) -> NetworkStateSnapshot:
        """Create an immutable snapshot of current state."""
        return NetworkStateSnapshot(
            spectrum=copy.deepcopy(self._spectrum),
            lightpaths=copy.deepcopy(self._lightpaths),
            next_id=self._next_lightpath_id,
        )

    def restore(self, snapshot: NetworkStateSnapshot) -> None:
        """Restore state from snapshot (for rollback/testing)."""
        self._spectrum = copy.deepcopy(snapshot.spectrum)
        self._lightpaths = copy.deepcopy(snapshot.lightpaths)
        self._next_lightpath_id = snapshot.next_id
```

### 7.2 Test Fixtures

```python
def create_empty_network_state(
    topology: nx.Graph,
    bands: list[str],
    slots_per_band: dict[str, int],
    cores_per_link: int,
) -> NetworkState:
    """Factory for empty network state in tests."""
    return NetworkState(
        topology=topology,
        bands=bands,
        slots_per_band=slots_per_band,
        cores_per_link=cores_per_link,
    )
```

---

## Summary

This document establishes:

1. **Clear authority boundaries** - NetworkState owns spectrum and lightpath state; SimulationEngine owns request lifecycle; engine_props is configuration
2. **Complete field mapping** - All SDNProps fields categorized by ownership
3. **Key structure changes** - Lightpath indexing transformation documented
4. **Compatibility layer** - Properties for legacy code access
5. **Mutation boundaries** - Read vs write access patterns defined
