# P2.1 NetworkState Core - Index

## Sub-phase Overview

**Goal**: Create the foundational `NetworkState` class with read-only operations and the `LinkSpectrum` dataclass for per-link spectrum management.

**Output**: `fusion/domain/network_state.py`

**Dependencies**:
- Phase 1 complete (especially P1.3 Lightpath, P1.1 SimulationConfig)
- NetworkX topology available from simulation setup

## Objectives

1. Define `LinkSpectrum` dataclass for per-link spectrum state
2. Define `NetworkState` class as single source of truth
3. Implement initialization from topology and config
4. Implement read-only methods (no writes in P2.1)
5. Establish ownership and pass-by-reference patterns

## Constraints

- **NetworkState is a state container, NOT a routing algorithm**
- No heuristic logic (First-Fit, k-shortest-path) in NetworkState
- Read methods only - write methods come in P2.2
- All code must pass `mypy --strict` and `ruff check`
- No changes to existing files outside `fusion/domain/`

## Micro-tasks

Execute in alphabetical order:

| Task ID | File | Type | Description |
|---------|------|------|-------------|
| P2.1.a | `P2.1.a_context_extraction_current_state.md` | context-extraction | Summarize how legacy code manages state |
| P2.1.b | `P2.1.b_design_link_spectrum.md` | design | Design LinkSpectrum dataclass API |
| P2.1.c | `P2.1.c_design_network_state_core.md` | design | Design NetworkState class API |
| P2.1.d | `P2.1.d_implement_link_spectrum.md` | refactor-plan | Implement LinkSpectrum dataclass |
| P2.1.e | `P2.1.e_implement_network_state_reads.md` | refactor-plan | Implement NetworkState with read methods |
| P2.1.f | `P2.1.f_verify_network_state_core.md` | verification-plan | Unit tests and verification |

## Shared Context

- `P2.1.shared_context_legacy_state_sources.md` - Summary of legacy state management patterns
- `P2.1.shared_context_state_authority.md` - Complete state authority mapping (from Gap Analysis)

## Key Classes Created

### LinkSpectrum
```python
@dataclass
class LinkSpectrum:
    """Per-link spectrum management."""
    link: tuple[str, str]
    cores_matrix: dict[str, np.ndarray]  # band -> (cores, slots)
    usage_count: int = 0
    throughput: float = 0.0
    link_num: int = 0

    def is_range_free(self, start: int, end: int, core: int, band: str) -> bool: ...
    def allocate_range(self, start: int, end: int, core: int, band: str, lightpath_id: int) -> None: ...
    def release_range(self, start: int, end: int, core: int, band: str) -> None: ...
```

### NetworkState
```python
class NetworkState:
    """Single source of truth for network state."""

    def __init__(self, topology: nx.Graph, config: SimulationConfig) -> None: ...

    # Read methods (P2.1)
    def get_lightpath(self, lightpath_id: int) -> Lightpath | None: ...
    def get_link_spectrum(self, link: tuple[str, str]) -> LinkSpectrum: ...
    def is_spectrum_available(self, path: list[str], start: int, end: int, core: int, band: str) -> bool: ...
    def find_first_fit(self, path: list[str], slots_needed: int, core: int, band: str) -> int | None: ...

    # Properties
    @property
    def topology(self) -> nx.Graph: ...
    @property
    def config(self) -> SimulationConfig: ...
    @property
    def lightpath_count(self) -> int: ...
```

## Exit Criteria

- [ ] `LinkSpectrum` dataclass implemented with all methods
- [ ] `NetworkState` class implemented with read methods
- [ ] Can instantiate `NetworkState` from topology
- [ ] Spectrum matrices initialized correctly for all bands/cores
- [ ] `is_spectrum_available` returns correct results
- [ ] Unit tests achieve 90%+ coverage
- [ ] `mypy fusion/domain/network_state.py --strict` passes
- [ ] `ruff check fusion/domain/network_state.py` passes

## Next Sub-phase

After P2.1 completes, proceed to [P2.2 Write Methods + Legacy Compat](../P2.2_network_state_writes_legacy/P2.2.index.md).
