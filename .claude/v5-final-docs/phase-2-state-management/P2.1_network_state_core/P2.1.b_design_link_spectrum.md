# Task ID: P2.1.b - Design LinkSpectrum Dataclass

**Sub-phase:** P2.1
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the `LinkSpectrum` dataclass that encapsulates per-link spectrum state. This dataclass replaces direct manipulation of the `network_spectrum_dict[link]` dictionary entries.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.shared_context_legacy_state_sources.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.1_domain_scaffolding/P1.1.index.md` (for SimulationConfig)
- Output from P2.1.a (context extraction)

## Outputs

### 1. LinkSpectrum Dataclass Specification

```python
from dataclasses import dataclass, field
from typing import Any
import numpy as np
import numpy.typing as npt

@dataclass
class LinkSpectrum:
    """
    Per-link spectrum management.

    Encapsulates the spectrum allocation state for a single network link,
    supporting multi-band and multi-core configurations.

    Attributes:
        link: The link identifier as (source, destination) tuple
        cores_matrix: Spectrum arrays per band, shape (cores, slots)
        usage_count: Number of active spectrum allocations on this link
        throughput: Cumulative bandwidth served through this link (Gbps)
        link_num: Link index for reference
        length_km: Physical link length in kilometers
    """
    link: tuple[str, str]
    cores_matrix: dict[str, npt.NDArray[np.int64]]
    usage_count: int = 0
    throughput: float = 0.0
    link_num: int = 0
    length_km: float = 0.0
```

### 2. Method Specifications

#### is_range_free
```python
def is_range_free(
    self,
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
) -> bool:
    """
    Check if a spectrum range is completely free.

    Args:
        start_slot: First slot index (inclusive)
        end_slot: Last slot index (exclusive)
        core: Core index (0 to cores_per_link - 1)
        band: Band identifier ("c", "l", "s")

    Returns:
        True if all slots in range are 0 (free), False otherwise

    Raises:
        KeyError: If band is not in cores_matrix
        IndexError: If core or slot indices are out of bounds
    """
```

#### allocate_range
```python
def allocate_range(
    self,
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
    lightpath_id: int,
    guard_slots: int = 0,
) -> None:
    """
    Allocate a spectrum range to a lightpath.

    Marks data slots with positive lightpath_id and guard slots with negative.

    Args:
        start_slot: First slot index (inclusive)
        end_slot: Last slot index (exclusive), includes guard slots
        core: Core index
        band: Band identifier
        lightpath_id: Positive integer ID for the lightpath
        guard_slots: Number of guard band slots at end of allocation

    Raises:
        ValueError: If lightpath_id <= 0
        ValueError: If range is not free (would overwrite existing allocation)
        KeyError: If band is not in cores_matrix
        IndexError: If indices are out of bounds

    Side Effects:
        - Sets spectrum[core][start:end-guard_slots] = lightpath_id
        - Sets spectrum[core][end-guard_slots:end] = -lightpath_id (guard)
        - Increments usage_count
    """
```

#### release_range
```python
def release_range(
    self,
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
) -> None:
    """
    Release a spectrum range (set to free).

    Args:
        start_slot: First slot index (inclusive)
        end_slot: Last slot index (exclusive)
        core: Core index
        band: Band identifier

    Raises:
        KeyError: If band is not in cores_matrix
        IndexError: If indices are out of bounds

    Side Effects:
        - Sets spectrum[core][start:end] = 0
        - Decrements usage_count (clamped to >= 0)
    """
```

#### get_spectrum_array (read-only view)
```python
def get_spectrum_array(
    self,
    band: str,
) -> npt.NDArray[np.int64]:
    """
    Get read-only view of spectrum array for a band.

    Args:
        band: Band identifier

    Returns:
        numpy array of shape (cores, slots), values are lightpath IDs or 0

    Note:
        Returns actual array reference. Callers should NOT modify.
        For safe iteration only.
    """
```

### 3. Factory Method

```python
@classmethod
def from_config(
    cls,
    link: tuple[str, str],
    config: "SimulationConfig",
    link_num: int = 0,
    length_km: float = 0.0,
) -> "LinkSpectrum":
    """
    Create LinkSpectrum initialized from SimulationConfig.

    Args:
        link: Link identifier tuple
        config: Simulation configuration with band/core specs
        link_num: Link index
        length_km: Physical link length

    Returns:
        New LinkSpectrum with zero-initialized spectrum arrays
        matching config.band_list and config.cores_per_link
    """
```

### 4. Invariants

| Invariant | Enforcement |
|-----------|-------------|
| `lightpath_id > 0` for allocations | Validated in `allocate_range` |
| `usage_count >= 0` | Clamped in `release_range` |
| Band exists in `cores_matrix` | KeyError raised if missing |
| No overlapping allocations | Validated in `allocate_range` |
| Guard slots marked with negative ID | Set automatically in `allocate_range` |

### 5. Design Decisions

| Decision | Rationale |
|----------|-----------|
| Dataclass (not frozen) | State must be mutable during simulation |
| `dict[str, ndarray]` for cores_matrix | Matches legacy structure, supports multi-band |
| Explicit guard_slots parameter | Makes guard band handling explicit |
| Raises on invalid operations | Fail fast rather than silent corruption |
| No direct `__setitem__` on spectrum | All mutations through methods |

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.1.d.

Key considerations:
1. Match legacy `network_spectrum_dict[link]` structure closely
2. Support multi-band (C, L, S) and multi-core (MCF)
3. Guard band handling must match current behavior
4. Type annotations must satisfy mypy --strict

## Verification

Design is complete when:
- [ ] All method signatures defined with types
- [ ] All parameters documented
- [ ] All exceptions documented
- [ ] Invariants clearly stated
- [ ] Factory method specified for initialization

## Next Task

After completing this design, proceed to `P2.1.c_design_network_state_core.md`.
