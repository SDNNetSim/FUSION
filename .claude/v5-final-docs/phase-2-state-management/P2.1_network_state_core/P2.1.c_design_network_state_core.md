# Task ID: P2.1.c - Design NetworkState Core Class

**Sub-phase:** P2.1
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the `NetworkState` class that serves as the single source of truth for all mutable network state during simulation. This task covers initialization and read-only methods; write methods are designed in P2.2.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.shared_context_legacy_state_sources.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.b_design_link_spectrum.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.3_lightpath_wrapper/P1.3.index.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.1_domain_scaffolding/P1.1.index.md`

## Outputs

### 1. NetworkState Class Overview

```python
from __future__ import annotations

from typing import TYPE_CHECKING, Iterator
import networkx as nx
import numpy as np

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.lightpath import Lightpath

class NetworkState:
    """
    Single source of truth for network state during simulation.

    Owns:
        - Network topology (read-only after init)
        - Per-link spectrum state (LinkSpectrum objects)
        - Active lightpaths (by ID)
        - Lightpath ID counter

    Design Principles:
        - One instance per simulation
        - Passed by reference to pipelines (not stored)
        - All state mutations through explicit methods
        - Read methods are query-only (no side effects)

    Usage:
        config = SimulationConfig.from_engine_props(engine_props)
        state = NetworkState(topology, config)

        # Read operations
        if state.is_spectrum_available(path, start, end, core, "c"):
            ...

        # Lightpath lookup
        lp = state.get_lightpath(lightpath_id)
    """
```

### 2. Constructor Specification

```python
def __init__(
    self,
    topology: nx.Graph,
    config: SimulationConfig,
) -> None:
    """
    Initialize NetworkState from topology and configuration.

    Args:
        topology: NetworkX graph representing network structure.
                  Edge attributes are preserved (length, etc.)
        config: Immutable simulation configuration

    Side Effects:
        - Creates LinkSpectrum for each edge (bidirectional)
        - Initializes empty lightpath registry
        - Sets lightpath ID counter to 1

    Raises:
        ValueError: If topology is empty (no nodes or edges)
        ValueError: If config band_list is empty

    Note:
        Topology is stored as reference (not copied). Callers must
        not modify topology after passing to NetworkState.
    """
    self._topology: nx.Graph = topology
    self._config: SimulationConfig = config
    self._spectrum: dict[tuple[str, str], LinkSpectrum] = {}
    self._lightpaths: dict[int, Lightpath] = {}
    self._next_lightpath_id: int = 1

    # Initialize LinkSpectrum for each edge
    self._init_spectrum()
```

### 3. Read-Only Properties

```python
@property
def topology(self) -> nx.Graph:
    """Network topology graph (read-only reference)."""

@property
def config(self) -> SimulationConfig:
    """Simulation configuration (immutable)."""

@property
def lightpath_count(self) -> int:
    """Number of active lightpaths."""

@property
def link_count(self) -> int:
    """Number of links in topology (edges, not bidirectional pairs)."""
```

### 4. Read Method Specifications

#### get_lightpath
```python
def get_lightpath(self, lightpath_id: int) -> Lightpath | None:
    """
    Retrieve a lightpath by ID.

    Args:
        lightpath_id: Unique lightpath identifier

    Returns:
        Lightpath object if found, None otherwise

    Note:
        Returns direct reference. Callers may modify Lightpath
        state (e.g., remaining bandwidth) but must not remove
        from registry directly.
    """
```

#### get_lightpaths_between
```python
def get_lightpaths_between(
    self,
    source: str,
    destination: str,
) -> list[Lightpath]:
    """
    Get all lightpaths between two endpoints.

    Args:
        source: Source node ID
        destination: Destination node ID

    Returns:
        List of lightpaths connecting these endpoints (either direction).
        Empty list if none found.

    Note:
        Handles both (src, dst) and (dst, src) automatically.
    """
```

#### iter_lightpaths
```python
def iter_lightpaths(self) -> Iterator[Lightpath]:
    """
    Iterate over all active lightpaths.

    Yields:
        Each active Lightpath in arbitrary order

    Note:
        Safe to iterate during simulation. Do not add/remove
        lightpaths during iteration.
    """
```

#### get_link_spectrum
```python
def get_link_spectrum(self, link: tuple[str, str]) -> LinkSpectrum:
    """
    Get LinkSpectrum for a specific link.

    Args:
        link: (source, destination) tuple

    Returns:
        LinkSpectrum object for that link

    Raises:
        KeyError: If link does not exist in topology

    Note:
        Both (u, v) and (v, u) return the same LinkSpectrum object.
    """
```

#### is_spectrum_available
```python
def is_spectrum_available(
    self,
    path: list[str],
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
) -> bool:
    """
    Check if spectrum range is free along entire path.

    Args:
        path: Ordered list of node IDs forming the path
        start_slot: First slot index (inclusive)
        end_slot: Last slot index (exclusive)
        core: Core index
        band: Band identifier

    Returns:
        True if all slots in range are free on all links in path

    Raises:
        ValueError: If path has fewer than 2 nodes
        KeyError: If any link in path doesn't exist
    """
```

#### find_first_fit
```python
def find_first_fit(
    self,
    path: list[str],
    slots_needed: int,
    core: int,
    band: str,
) -> int | None:
    """
    Find first available slot range along path (first-fit algorithm).

    Args:
        path: Ordered list of node IDs
        slots_needed: Number of contiguous slots required
        core: Core index to search
        band: Band identifier

    Returns:
        Start slot index if found, None if no fit available

    Note:
        This is a read-only query method. It does NOT allocate.
        Use NetworkState.create_lightpath() to allocate (P2.2).

        This helper exists because first-fit is commonly needed.
        More sophisticated algorithms should be in pipelines.
    """
```

### 5. Private Helper Methods

```python
def _init_spectrum(self) -> None:
    """Initialize LinkSpectrum for all edges in topology."""

def _get_path_links(self, path: list[str]) -> list[tuple[str, str]]:
    """Convert path to list of link tuples."""

def _normalize_link(self, link: tuple[str, str]) -> tuple[str, str]:
    """Normalize link to canonical form (for bidirectional lookup)."""
```

### 6. Design Principles

| Principle | Implementation |
|-----------|----------------|
| Single Source of Truth | All state in one object, no external copies |
| Pass-by-Reference | Methods receive state as parameter, don't store |
| Immutable Config | SimulationConfig is frozen, cannot change |
| Read-Only Topology | Stored by reference, never modified |
| Explicit Mutations | All changes through named methods (P2.2) |
| No Routing Logic | First-fit helper only; algorithms in pipelines |

### 7. Not Included in P2.1

The following are deferred to P2.2:
- `create_lightpath()` - Creates and registers a new lightpath
- `release_lightpath()` - Removes lightpath and frees spectrum
- `_allocate_spectrum_on_path()` - Helper for spectrum allocation
- `_release_spectrum_on_path()` - Helper for spectrum release
- `network_spectrum_dict` property - Legacy compatibility
- `lightpath_status_dict` property - Legacy compatibility

### 8. Type Stubs for Forward References

```python
# At top of network_state.py
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.lightpath import Lightpath
```

This avoids circular imports while maintaining full type safety.

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.1.e.

Key considerations:
1. NetworkState must work with Phase 1 domain objects
2. Bidirectional link handling must match legacy behavior
3. Read methods must be pure (no side effects)
4. All methods must have complete type annotations

## Verification

Design is complete when:
- [ ] Constructor fully specified with validation
- [ ] All read methods documented with signatures
- [ ] Private helpers identified
- [ ] Type imports structured to avoid circular deps
- [ ] Integration with Phase 1 objects clear

## Next Task

After completing this design, proceed to `P2.1.d_implement_link_spectrum.md`.
