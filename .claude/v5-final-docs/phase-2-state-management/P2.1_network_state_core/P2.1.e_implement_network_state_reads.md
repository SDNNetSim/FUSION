# Task ID: P2.1.e - Implement NetworkState Read Methods

**Sub-phase:** P2.1
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement the `NetworkState` class with initialization and read-only methods. This task builds on P2.1.d which created `LinkSpectrum`.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.c_design_network_state_core.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.d_implement_link_spectrum.md`
- `fusion/domain/network_state.py` (current state after P2.1.d)

## Outputs

### 1. Add NetworkState to network_state.py

Append to `fusion/domain/network_state.py` after the `LinkSpectrum` class:

```python
from typing import Iterator

import networkx as nx

if TYPE_CHECKING:
    from fusion.domain.lightpath import Lightpath


class NetworkState:
    """
    Single source of truth for network state during simulation.

    Owns:
        - Network topology (read-only after init)
        - Per-link spectrum state (LinkSpectrum objects)
        - Active lightpaths (by ID)
        - Lightpath ID counter

    Design Principles:
        - One instance per simulation
        - Passed by reference to pipelines (not stored)
        - All state mutations through explicit methods
        - Read methods are query-only (no side effects)

    Example:
        >>> state = NetworkState(topology, config)
        >>> if state.is_spectrum_available(path, 0, 10, core=0, band="c"):
        ...     # Spectrum is free, can allocate (using P2.2 methods)
        ...     pass
    """

    __slots__ = (
        "_topology",
        "_config",
        "_spectrum",
        "_lightpaths",
        "_next_lightpath_id",
    )

    def __init__(
        self,
        topology: nx.Graph,
        config: SimulationConfig,
    ) -> None:
        """
        Initialize NetworkState from topology and configuration.

        Args:
            topology: NetworkX graph representing network structure.
                      Edge attributes are preserved (length, etc.)
            config: Immutable simulation configuration

        Raises:
            ValueError: If topology is empty (no edges)
            ValueError: If config band_list is empty
        """
        if topology.number_of_edges() == 0:
            msg = "Topology must have at least one edge"
            raise ValueError(msg)

        if not config.band_list:
            msg = "Config must have at least one band in band_list"
            raise ValueError(msg)

        self._topology: nx.Graph = topology
        self._config: SimulationConfig = config
        self._spectrum: dict[tuple[str, str], LinkSpectrum] = {}
        self._lightpaths: dict[int, Lightpath] = {}
        self._next_lightpath_id: int = 1

        self._init_spectrum()

    def _init_spectrum(self) -> None:
        """Initialize LinkSpectrum for all edges in topology."""
        link_num = 0
        for u, v, edge_data in self._topology.edges(data=True):
            # Get link length from edge data
            length_km = edge_data.get("length", edge_data.get("weight", 0.0))

            # Create single LinkSpectrum for both directions
            link_spectrum = LinkSpectrum.from_config(
                link=(u, v),
                config=self._config,
                link_num=link_num,
                length_km=float(length_km),
            )

            # Both directions point to same object
            self._spectrum[(u, v)] = link_spectrum
            self._spectrum[(v, u)] = link_spectrum

            link_num += 1

    # -------------------------------------------------------------------------
    # Read-Only Properties
    # -------------------------------------------------------------------------

    @property
    def topology(self) -> nx.Graph:
        """Network topology graph (read-only reference)."""
        return self._topology

    @property
    def config(self) -> SimulationConfig:
        """Simulation configuration (immutable)."""
        return self._config

    @property
    def lightpath_count(self) -> int:
        """Number of active lightpaths."""
        return len(self._lightpaths)

    @property
    def link_count(self) -> int:
        """Number of links in topology (edges, not bidirectional pairs)."""
        return self._topology.number_of_edges()

    @property
    def next_lightpath_id(self) -> int:
        """Next lightpath ID that will be assigned (read-only)."""
        return self._next_lightpath_id

    # -------------------------------------------------------------------------
    # Lightpath Read Methods
    # -------------------------------------------------------------------------

    def get_lightpath(self, lightpath_id: int) -> Lightpath | None:
        """
        Retrieve a lightpath by ID.

        Args:
            lightpath_id: Unique lightpath identifier

        Returns:
            Lightpath object if found, None otherwise
        """
        return self._lightpaths.get(lightpath_id)

    def get_lightpaths_between(
        self,
        source: str,
        destination: str,
    ) -> list[Lightpath]:
        """
        Get all lightpaths between two endpoints.

        Args:
            source: Source node ID
            destination: Destination node ID

        Returns:
            List of lightpaths connecting these endpoints (either direction).
            Empty list if none found.
        """
        result: list[Lightpath] = []
        for lp in self._lightpaths.values():
            # Check both directions
            if (lp.source == source and lp.destination == destination) or \
               (lp.source == destination and lp.destination == source):
                result.append(lp)
        return result

    def get_lightpaths_with_capacity(
        self,
        source: str,
        destination: str,
        min_bandwidth_gbps: int = 1,
    ) -> list[Lightpath]:
        """
        Get lightpaths between endpoints with available capacity.

        Useful for grooming: find lightpaths that can accept more traffic.

        Args:
            source: Source node ID
            destination: Destination node ID
            min_bandwidth_gbps: Minimum remaining bandwidth required

        Returns:
            List of lightpaths with at least min_bandwidth_gbps available.
            Sorted by remaining bandwidth descending.
        """
        candidates = self.get_lightpaths_between(source, destination)
        with_capacity = [
            lp for lp in candidates
            if lp.remaining_bandwidth_gbps >= min_bandwidth_gbps
        ]
        # Sort by remaining bandwidth, highest first
        return sorted(
            with_capacity,
            key=lambda lp: lp.remaining_bandwidth_gbps,
            reverse=True,
        )

    def iter_lightpaths(self) -> Iterator[Lightpath]:
        """
        Iterate over all active lightpaths.

        Yields:
            Each active Lightpath in arbitrary order
        """
        yield from self._lightpaths.values()

    # -------------------------------------------------------------------------
    # Spectrum Read Methods
    # -------------------------------------------------------------------------

    def get_link_spectrum(self, link: tuple[str, str]) -> LinkSpectrum:
        """
        Get LinkSpectrum for a specific link.

        Args:
            link: (source, destination) tuple

        Returns:
            LinkSpectrum object for that link

        Raises:
            KeyError: If link does not exist in topology
        """
        if link not in self._spectrum:
            msg = f"Link {link} does not exist in topology"
            raise KeyError(msg)
        return self._spectrum[link]

    def is_spectrum_available(
        self,
        path: list[str],
        start_slot: int,
        end_slot: int,
        core: int,
        band: str,
    ) -> bool:
        """
        Check if spectrum range is free along entire path.

        Args:
            path: Ordered list of node IDs forming the path
            start_slot: First slot index (inclusive)
            end_slot: Last slot index (exclusive)
            core: Core index
            band: Band identifier

        Returns:
            True if all slots in range are free on all links in path

        Raises:
            ValueError: If path has fewer than 2 nodes
            KeyError: If any link in path doesn't exist
        """
        if len(path) < 2:
            msg = "Path must have at least 2 nodes"
            raise ValueError(msg)

        for link in self._get_path_links(path):
            link_spectrum = self.get_link_spectrum(link)
            if not link_spectrum.is_range_free(start_slot, end_slot, core, band):
                return False
        return True

    def find_first_fit(
        self,
        path: list[str],
        slots_needed: int,
        core: int,
        band: str,
    ) -> int | None:
        """
        Find first available slot range along path (first-fit algorithm).

        Args:
            path: Ordered list of node IDs
            slots_needed: Number of contiguous slots required
            core: Core index to search
            band: Band identifier

        Returns:
            Start slot index if found, None if no fit available

        Note:
            This is a read-only query method. It does NOT allocate.
            This helper exists because first-fit is commonly needed.
            More sophisticated algorithms should be in pipelines.
        """
        if len(path) < 2:
            return None

        # Get max slots from first link's spectrum
        first_link = (path[0], path[1])
        link_spectrum = self.get_link_spectrum(first_link)
        max_slots = link_spectrum.get_slot_count(band)

        # Search for contiguous free range
        for start in range(max_slots - slots_needed + 1):
            end = start + slots_needed
            if self.is_spectrum_available(path, start, end, core, band):
                return start

        return None

    # -------------------------------------------------------------------------
    # Private Helpers
    # -------------------------------------------------------------------------

    def _get_path_links(self, path: list[str]) -> list[tuple[str, str]]:
        """Convert path to list of link tuples."""
        links: list[tuple[str, str]] = []
        for i in range(len(path) - 1):
            links.append((path[i], path[i + 1]))
        return links
```

### 2. Update Module Init

**File**: `fusion/domain/__init__.py`

Add NetworkState to exports:
```python
from fusion.domain.network_state import LinkSpectrum, NetworkState

__all__ = [
    # ... existing exports ...
    "LinkSpectrum",
    "NetworkState",
]
```

## Verification Commands

```bash
# Type checking
mypy fusion/domain/network_state.py --strict

# Linting
ruff check fusion/domain/network_state.py

# Smoke test
python -c "
import networkx as nx
from fusion.domain.network_state import NetworkState, LinkSpectrum

# Create mock config
class MockConfig:
    band_list = ('c',)
    band_slots = {'c': 320}
    cores_per_link = 1

# Create simple topology
G = nx.Graph()
G.add_edge('A', 'B', length=100.0)
G.add_edge('B', 'C', length=150.0)

# Initialize NetworkState
state = NetworkState(G, MockConfig())

# Test read methods
assert state.link_count == 2
assert state.lightpath_count == 0
assert state.is_spectrum_available(['A', 'B', 'C'], 0, 10, 0, 'c')

# Test first fit
slot = state.find_first_fit(['A', 'B'], 10, 0, 'c')
assert slot == 0

print('NetworkState smoke test passed')
"
```

## Integration Notes

1. **Phase 1 Dependency**: `Lightpath` class must be importable from `fusion.domain.lightpath`
2. **Type Checking**: Uses `TYPE_CHECKING` to avoid circular imports
3. **Bidirectional Links**: Same `LinkSpectrum` object for `(u,v)` and `(v,u)`

## Next Task

After implementing NetworkState reads, proceed to `P2.1.f_verify_network_state_core.md`.
