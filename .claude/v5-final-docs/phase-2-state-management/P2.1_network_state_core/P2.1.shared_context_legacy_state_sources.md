# P2.1 Shared Context: Legacy State Sources

## Purpose

This document summarizes how legacy FUSION code manages network state. Reference this instead of reading full legacy files in micro-tasks.

## Source Files

| File | Purpose |
|------|---------|
| `fusion/core/properties.py` | SDNProps, RoutingProps, SpectrumProps definitions |
| `fusion/core/simulation.py` | Topology and spectrum initialization |
| `fusion/core/sdn_controller.py` | State mutation during request handling |
| `fusion/core/spectrum_assignment.py` | Spectrum allocation/deallocation |

---

## network_spectrum_dict Structure

**Location**: `SDNProps.network_spectrum_dict` (properties.py:333)

**Type**: `dict[tuple[Any, Any], dict[str, Any]]`

**Key**: `(source_node, destination_node)` tuple - bidirectional entries for each link

**Value Structure**:
```python
{
    "cores_matrix": {
        "c": np.ndarray,  # shape: (cores_per_link, num_slots_c_band)
        "l": np.ndarray,  # shape: (cores_per_link, num_slots_l_band) - if multiband
    },
    "usage_count": int,      # Number of active allocations on this link
    "throughput": float,     # Cumulative bandwidth through this link
    "link_num": int,         # Link index for reference
    "length": float,         # Physical length in km
    "dispersion": float,     # Fiber dispersion parameter
    "attenuation": float,    # Fiber loss parameter
    # ... additional link parameters from topology
}
```

**Spectrum Array Values**:
- `0` = slot is free
- `positive int` = slot occupied by lightpath with that ID
- `negative int` = guard band slot (associated with lightpath `abs(value)`)

**Initialization** (simulation.py:571-585):
```python
# For each edge (u, v) in topology:
for u, v in topology.edges():
    link_dict = {
        "cores_matrix": {band: np.zeros((cores_per_link, band_slots[band])) for band in bands},
        "usage_count": 0,
        "throughput": 0.0,
        "link_num": link_index,
        # ... copy edge attributes
    }
    network_spectrum_dict[(u, v)] = link_dict
    network_spectrum_dict[(v, u)] = link_dict  # Same dict object for both directions
```

---

## lightpath_status_dict Structure

**Location**: `SDNProps.lightpath_status_dict` (properties.py:374)

**Type**: `dict[tuple, dict[int, dict]]`

**Key**: `(source, destination)` tuple - **sorted** so (A, B) and (B, A) map to same key

**Value Structure**:
```python
{
    lightpath_id: {
        "path": list[str],           # Ordered node sequence
        "lightpath_bandwidth": float, # Total capacity in Gbps
        "remaining_bandwidth": float, # Available capacity
        "band": str,                  # "c" or "l"
        "core": int,                  # Core index (0 to cores_per_link-1)
        "start_slot": int,            # First allocated slot
        "end_slot": int,              # Last allocated slot (exclusive)
        "modulation": str,            # e.g., "QPSK", "16-QAM"
        "requests_dict": {            # Groomed requests
            request_id: allocated_bandwidth,
            ...
        },
        "time_bw_usage": dict,        # Utilization tracking over time
        "is_degraded": bool,          # SNR degradation flag
    }
}
```

**Key Generation**:
```python
# Canonical key for any source-destination pair
def get_lightpath_key(src: str, dst: str) -> tuple[str, str]:
    return tuple(sorted([src, dst]))
```

---

## Spectrum Allocation Flow

**Allocation** (spectrum_assignment.py, sdn_controller.py):
1. Find free slot range using allocation algorithm (first_fit, best_fit, etc.)
2. Mark slots in `cores_matrix[band][core][start:end]` with `lightpath_id`
3. Mark guard band slots (if any) with `-lightpath_id`
4. Increment `usage_count`
5. Add entry to `lightpath_status_dict`

**Deallocation** (sdn_controller.py:150):
1. Look up lightpath in `lightpath_status_dict`
2. Clear slots in `cores_matrix` (set to 0)
3. Decrement `usage_count`
4. Remove from `lightpath_status_dict`

**Critical Detail**: Both `(u,v)` and `(v,u)` point to the same dict object, so updates affect both directions automatically.

---

## State Access Patterns

### Read Patterns
```python
# Check if spectrum range is free
spectrum = sdn_props.network_spectrum_dict[link]["cores_matrix"][band][core]
is_free = np.all(spectrum[start:end] == 0)

# Get all lightpaths between two nodes
key = tuple(sorted([src, dst]))
lightpaths = sdn_props.lightpath_status_dict.get(key, {})

# Get specific lightpath info
lp_info = sdn_props.lightpath_status_dict[key][lightpath_id]
```

### Write Patterns
```python
# Allocate spectrum
for link in path_links:
    link_data = sdn_props.network_spectrum_dict[link]
    link_data["cores_matrix"][band][core][start:end] = lightpath_id
    link_data["usage_count"] += 1

# Release spectrum
for link in path_links:
    link_data = sdn_props.network_spectrum_dict[link]
    link_data["cores_matrix"][band][core][start:end] = 0
    link_data["usage_count"] -= 1
```

---

## Mapping to NetworkState

| Legacy | NetworkState |
|--------|--------------|
| `sdn_props.network_spectrum_dict[link]` | `network_state.get_link_spectrum(link)` |
| `sdn_props.lightpath_status_dict[key][id]` | `network_state.get_lightpath(id)` |
| Direct `cores_matrix` manipulation | `LinkSpectrum.allocate_range()` / `release_range()` |
| `np.all(spectrum[start:end] == 0)` | `network_state.is_spectrum_available()` |
| Manual lightpath dict construction | `network_state.create_lightpath()` |

---

## References

- Original: `.claude/v4-docs/migration/phase_2_state_management.md`
- Properties: `fusion/core/properties.py`
- Initialization: `fusion/core/simulation.py:571-585`
- Allocation: `fusion/core/spectrum_assignment.py`
- Release: `fusion/core/sdn_controller.py:102-200`
