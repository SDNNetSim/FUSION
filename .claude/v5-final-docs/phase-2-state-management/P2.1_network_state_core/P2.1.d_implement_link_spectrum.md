# Task ID: P2.1.d - Implement LinkSpectrum Dataclass

**Sub-phase:** P2.1
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement the `LinkSpectrum` dataclass based on the design from P2.1.b. This creates the per-link spectrum container.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.1_network_state_core/P2.1.b_design_link_spectrum.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.1_domain_scaffolding/P1.1.index.md` (SimulationConfig reference)

## Outputs

### 1. Create File

**File**: `fusion/domain/network_state.py`

Start with LinkSpectrum implementation. NetworkState will be added in P2.1.e.

### 2. Full Implementation

```python
"""
Network state management for FUSION simulation.

This module provides:
- LinkSpectrum: Per-link spectrum state management
- NetworkState: Single source of truth for network state (added in P2.1.e)

Phase: P2.1 - NetworkState Core
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import TYPE_CHECKING, ClassVar

import numpy as np
import numpy.typing as npt

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig


@dataclass
class LinkSpectrum:
    """
    Per-link spectrum management.

    Encapsulates the spectrum allocation state for a single network link,
    supporting multi-band and multi-core configurations.

    Attributes:
        link: The link identifier as (source, destination) tuple
        cores_matrix: Spectrum arrays per band, shape (cores, slots) each
        usage_count: Number of active spectrum allocations on this link
        throughput: Cumulative bandwidth served through this link (Gbps)
        link_num: Link index for reference
        length_km: Physical link length in kilometers

    Spectrum Array Values:
        - 0: Slot is free
        - Positive int: Slot occupied by lightpath with that ID
        - Negative int: Guard band slot for lightpath with abs(value) ID

    Example:
        >>> spectrum = LinkSpectrum.from_config(("A", "B"), config, link_num=0)
        >>> spectrum.is_range_free(0, 10, core=0, band="c")
        True
        >>> spectrum.allocate_range(0, 10, core=0, band="c", lightpath_id=1)
        >>> spectrum.is_range_free(0, 10, core=0, band="c")
        False
    """

    link: tuple[str, str]
    cores_matrix: dict[str, npt.NDArray[np.int64]] = field(default_factory=dict)
    usage_count: int = 0
    throughput: float = 0.0
    link_num: int = 0
    length_km: float = 0.0

    # Class-level constants
    FREE_SLOT: ClassVar[int] = 0

    def is_range_free(
        self,
        start_slot: int,
        end_slot: int,
        core: int,
        band: str,
    ) -> bool:
        """
        Check if a spectrum range is completely free.

        Args:
            start_slot: First slot index (inclusive)
            end_slot: Last slot index (exclusive)
            core: Core index (0 to cores_per_link - 1)
            band: Band identifier ("c", "l", "s")

        Returns:
            True if all slots in range are 0 (free), False otherwise

        Raises:
            KeyError: If band is not in cores_matrix
            IndexError: If core or slot indices are out of bounds
        """
        spectrum = self.cores_matrix[band]
        return bool(np.all(spectrum[core, start_slot:end_slot] == self.FREE_SLOT))

    def allocate_range(
        self,
        start_slot: int,
        end_slot: int,
        core: int,
        band: str,
        lightpath_id: int,
        guard_slots: int = 0,
    ) -> None:
        """
        Allocate a spectrum range to a lightpath.

        Marks data slots with positive lightpath_id and guard slots with negative.

        Args:
            start_slot: First slot index (inclusive)
            end_slot: Last slot index (exclusive), includes guard slots
            core: Core index
            band: Band identifier
            lightpath_id: Positive integer ID for the lightpath
            guard_slots: Number of guard band slots at end of allocation

        Raises:
            ValueError: If lightpath_id <= 0
            ValueError: If range is not free (would overwrite existing allocation)
            KeyError: If band is not in cores_matrix
            IndexError: If indices are out of bounds
        """
        if lightpath_id <= 0:
            msg = f"lightpath_id must be positive, got {lightpath_id}"
            raise ValueError(msg)

        if not self.is_range_free(start_slot, end_slot, core, band):
            msg = f"Spectrum range [{start_slot}:{end_slot}] on core {core} band {band} is not free"
            raise ValueError(msg)

        spectrum = self.cores_matrix[band]

        # Data slots (excluding guard band)
        data_end = end_slot - guard_slots
        spectrum[core, start_slot:data_end] = lightpath_id

        # Guard band slots (if any)
        if guard_slots > 0:
            spectrum[core, data_end:end_slot] = -lightpath_id

        self.usage_count += 1

    def release_range(
        self,
        start_slot: int,
        end_slot: int,
        core: int,
        band: str,
    ) -> None:
        """
        Release a spectrum range (set to free).

        Args:
            start_slot: First slot index (inclusive)
            end_slot: Last slot index (exclusive)
            core: Core index
            band: Band identifier

        Raises:
            KeyError: If band is not in cores_matrix
            IndexError: If indices are out of bounds
        """
        spectrum = self.cores_matrix[band]
        spectrum[core, start_slot:end_slot] = self.FREE_SLOT
        self.usage_count = max(0, self.usage_count - 1)

    def get_spectrum_array(self, band: str) -> npt.NDArray[np.int64]:
        """
        Get spectrum array for a band.

        Args:
            band: Band identifier

        Returns:
            numpy array of shape (cores, slots), values are lightpath IDs or 0

        Warning:
            Returns actual array reference. Callers should NOT modify directly.
            Use allocate_range() and release_range() instead.
        """
        return self.cores_matrix[band]

    def get_slot_count(self, band: str) -> int:
        """Get number of slots in a band."""
        return int(self.cores_matrix[band].shape[1])

    def get_core_count(self) -> int:
        """Get number of cores (same across all bands)."""
        if not self.cores_matrix:
            return 0
        first_band = next(iter(self.cores_matrix))
        return int(self.cores_matrix[first_band].shape[0])

    @classmethod
    def from_config(
        cls,
        link: tuple[str, str],
        config: SimulationConfig,
        link_num: int = 0,
        length_km: float = 0.0,
    ) -> LinkSpectrum:
        """
        Create LinkSpectrum initialized from SimulationConfig.

        Args:
            link: Link identifier tuple
            config: Simulation configuration with band/core specs
            link_num: Link index
            length_km: Physical link length

        Returns:
            New LinkSpectrum with zero-initialized spectrum arrays
            matching config.band_list and config.cores_per_link
        """
        cores_matrix: dict[str, npt.NDArray[np.int64]] = {}

        for band in config.band_list:
            num_slots = config.band_slots.get(band, 320)  # Default to 320 if not specified
            cores_matrix[band] = np.zeros(
                (config.cores_per_link, num_slots),
                dtype=np.int64,
            )

        return cls(
            link=link,
            cores_matrix=cores_matrix,
            link_num=link_num,
            length_km=length_km,
        )
```

### 3. Update Module Init

**File**: `fusion/domain/__init__.py`

Add to existing exports:
```python
from fusion.domain.network_state import LinkSpectrum

__all__ = [
    # ... existing exports ...
    "LinkSpectrum",
]
```

## Verification Commands

After implementation, run:

```bash
# Type checking
mypy fusion/domain/network_state.py --strict

# Linting
ruff check fusion/domain/network_state.py

# Quick smoke test (manual or add to test file)
python -c "
from fusion.domain.network_state import LinkSpectrum
import numpy as np

# Create test spectrum
class MockConfig:
    band_list = ('c',)
    band_slots = {'c': 320}
    cores_per_link = 1

spectrum = LinkSpectrum.from_config(('A', 'B'), MockConfig(), link_num=0)
assert spectrum.is_range_free(0, 10, 0, 'c')
spectrum.allocate_range(0, 10, 0, 'c', lightpath_id=1, guard_slots=1)
assert not spectrum.is_range_free(0, 10, 0, 'c')
print('LinkSpectrum smoke test passed')
"
```

## Edge Cases to Handle

1. **Empty guard_slots**: Should work (all slots get positive ID)
2. **Full range allocation**: start=0, end=max_slots
3. **Single slot allocation**: start=N, end=N+1
4. **Multi-core**: Each core tracked independently
5. **Multi-band**: Each band has separate array

## Next Task

After implementing LinkSpectrum, proceed to `P2.1.e_implement_network_state_reads.md`.
