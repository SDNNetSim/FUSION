# Task ID: P2.3.c - Design SpectrumPipeline Protocol

**Sub-phase:** P2.3
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the `SpectrumPipeline` protocol that defines the interface for spectrum assignment algorithms.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.a_extract_pipeline_signatures.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.b_design_spectrum_result.md`

## Outputs

### 1. SpectrumPipeline Protocol Specification

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class SpectrumPipeline(Protocol):
    """
    Protocol for spectrum assignment algorithms.

    Implementations find available spectrum slots along a path
    for a given bandwidth and modulation format.

    Design Notes:
        - Implementations should NOT store NetworkState as instance attribute
        - Receive NetworkState as method parameter for each call
        - Return SpectrumResult without modifying NetworkState
        - Actual allocation is done by NetworkState.create_lightpath()

    Allocation Methods:
        Common implementations include:
        - First-fit: Allocate lowest available slot range
        - Best-fit: Allocate smallest sufficient gap
        - Last-fit: Allocate highest available slot range

    Example Implementation:
        class FirstFitSpectrum:
            def find_spectrum(
                self,
                path: list[str],
                modulation: str,
                bandwidth_gbps: int,
                network_state: NetworkState,
            ) -> SpectrumResult:
                slots_needed = self._calculate_slots(bandwidth_gbps, modulation)

                # Search each band and core
                for band in network_state.config.band_list:
                    for core in range(network_state.config.cores_per_link):
                        start = network_state.find_first_fit(path, slots_needed, core, band)
                        if start is not None:
                            return SpectrumResult(
                                is_free=True,
                                start_slot=start,
                                end_slot=start + slots_needed,
                                core=core,
                                band=band,
                                modulation=modulation,
                                slots_needed=slots_needed,
                            )

                return SpectrumResult.not_found(slots_needed)
    """

    def find_spectrum(
        self,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        """
        Find available spectrum along a path.

        Args:
            path: Ordered list of node IDs forming the route
            modulation: Modulation format name (e.g., "QPSK", "16-QAM")
            bandwidth_gbps: Required bandwidth in Gbps
            network_state: Current network state

        Returns:
            SpectrumResult containing:
            - is_free: True if spectrum was found
            - start_slot, end_slot: Slot range (if found)
            - core: Core index (if found)
            - band: Band identifier (if found)
            - modulation: Confirmed modulation format
            - slots_needed: Number of slots required

        Side Effects:
            None - this is a pure query method.
            Does NOT allocate spectrum. Caller must use
            NetworkState.create_lightpath() to actually allocate.

        Notes:
            - Searches across all bands and cores based on allocation policy
            - Returns SpectrumResult.is_free=False if no spectrum available
            - slots_needed includes guard band slots
        """
        ...

    def find_protected_spectrum(
        self,
        primary_path: list[str],
        backup_path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        """
        Find spectrum for both primary and backup paths (1+1 protection).

        Args:
            primary_path: Primary route node sequence
            backup_path: Backup route node sequence (must be disjoint)
            modulation: Modulation format name
            bandwidth_gbps: Required bandwidth
            network_state: Current network state

        Returns:
            SpectrumResult containing:
            - Primary allocation in main fields (is_free, start_slot, etc.)
            - Backup allocation in backup_* fields

        Notes:
            - Both paths must have free spectrum for success
            - Returns is_free=False if either path lacks spectrum
            - Primary and backup may use different cores/bands
        """
        ...
```

### 2. SpectrumResult Integration

The protocol returns `SpectrumResult` from Phase 1:

```python
@dataclass(frozen=True)
class SpectrumResult:
    is_free: bool
    start_slot: int
    end_slot: int
    core: int
    band: str
    modulation: str
    slots_needed: int
    backup_start_slot: int | None = None
    backup_end_slot: int | None = None
    backup_core: int | None = None
    backup_band: str | None = None
```

### 3. Slot Calculation

Implementations need to calculate slots from bandwidth:

```python
def _calculate_slots_needed(
    self,
    bandwidth_gbps: int,
    modulation: str,
    config: SimulationConfig,
) -> int:
    """
    Calculate spectrum slots needed for given bandwidth and modulation.

    Uses modulation efficiency from config to determine slot count.
    Includes guard band slots.
    """
    # Get modulation efficiency (bits per symbol)
    mod_info = config.modulation_formats.get(modulation, {})
    bits_per_symbol = mod_info.get("bits_per_symbol", 2)  # Default QPSK

    # Calculate data slots
    slot_bandwidth_ghz = 12.5  # Standard slot width
    data_slots = math.ceil(bandwidth_gbps / (slot_bandwidth_ghz * bits_per_symbol))

    # Add guard slots
    total_slots = data_slots + config.guard_slots

    return total_slots
```

### 4. Search Strategy

```python
# Configurable search order
def find_spectrum(self, ..., network_state) -> SpectrumResult:
    config = network_state.config
    slots_needed = self._calculate_slots_needed(...)

    # Search order depends on policy
    if config.allocation_method == "first_fit":
        return self._first_fit_search(path, slots_needed, network_state)
    elif config.allocation_method == "best_fit":
        return self._best_fit_search(path, slots_needed, network_state)
    elif config.allocation_method == "last_fit":
        return self._last_fit_search(path, slots_needed, network_state)
```

### 5. Band and Core Iteration

```python
def _first_fit_search(
    self,
    path: list[str],
    slots_needed: int,
    network_state: NetworkState,
) -> SpectrumResult:
    config = network_state.config

    # Iterate bands (typically C first, then L)
    for band in config.band_list:
        # Iterate cores
        for core in range(config.cores_per_link):
            # Use NetworkState helper for first-fit
            start = network_state.find_first_fit(path, slots_needed, core, band)
            if start is not None:
                return SpectrumResult(
                    is_free=True,
                    start_slot=start,
                    end_slot=start + slots_needed,
                    core=core,
                    band=band,
                    modulation=self._current_modulation,
                    slots_needed=slots_needed,
                )

    return SpectrumResult.not_found(slots_needed)
```

### 6. Protected Spectrum Strategy

```python
def find_protected_spectrum(
    self,
    primary_path: list[str],
    backup_path: list[str],
    modulation: str,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> SpectrumResult:
    """Find spectrum for both primary and backup paths."""
    slots_needed = self._calculate_slots_needed(bandwidth_gbps, modulation, network_state.config)

    # Find primary spectrum
    primary_result = self._search_spectrum(primary_path, slots_needed, network_state)
    if not primary_result.is_free:
        return SpectrumResult.not_found(slots_needed)

    # Find backup spectrum (may be same or different band/core)
    backup_result = self._search_spectrum(backup_path, slots_needed, network_state)
    if not backup_result.is_free:
        return SpectrumResult.not_found(slots_needed)

    # Combine into single result
    return SpectrumResult(
        is_free=True,
        start_slot=primary_result.start_slot,
        end_slot=primary_result.end_slot,
        core=primary_result.core,
        band=primary_result.band,
        modulation=modulation,
        slots_needed=slots_needed,
        backup_start_slot=backup_result.start_slot,
        backup_end_slot=backup_result.end_slot,
        backup_core=backup_result.core,
        backup_band=backup_result.band,
    )
```

### 7. Design Decisions

| Decision | Rationale |
|----------|-----------|
| Two methods (single/protected) | Cleaner than optional parameters |
| No allocation in find | Separation of concerns, pure query |
| Returns slots_needed | Useful for caller to know |
| Band/core search order | Configurable via implementation |
| Guard slots in slots_needed | Total allocation size |

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.3.e.

Key considerations:
1. Protocol must wrap legacy SpectrumAssignment
2. No side effects - allocation is separate
3. Support for multi-band and multi-core
4. Protected spectrum needs both paths

## Next Task

After completing this design, proceed to `P2.3.d_design_grooming_snr_slicing_protocols.md`.
