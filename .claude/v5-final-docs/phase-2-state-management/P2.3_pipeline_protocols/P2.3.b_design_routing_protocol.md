# Task ID: P2.3.b - Design RoutingPipeline Protocol

**Sub-phase:** P2.3
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the `RoutingPipeline` protocol that defines the interface for route finding algorithms.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.a_extract_pipeline_signatures.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.a_design_route_result.md`

## Outputs

### 1. RoutingPipeline Protocol Specification

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class RoutingPipeline(Protocol):
    """
    Protocol for route finding algorithms.

    Implementations find candidate routes between source and destination
    nodes, returning paths with their weights and valid modulation formats.

    Design Notes:
        - Implementations should NOT store NetworkState as instance attribute
        - Receive NetworkState as method parameter for each call
        - Return RouteResult without modifying NetworkState
        - Configuration accessed via network_state.config

    Example Implementation:
        class KShortestPathRouter:
            def find_routes(
                self,
                source: str,
                destination: str,
                bandwidth_gbps: int,
                network_state: NetworkState,
                *,
                forced_path: list[str] | None = None,
            ) -> RouteResult:
                if forced_path is not None:
                    # Use forced path directly
                    return RouteResult(
                        paths=(tuple(forced_path),),
                        weights_km=(calculate_weight(forced_path),),
                        ...
                    )
                # Find k-shortest paths
                k = network_state.config.k_paths
                paths = nx.shortest_simple_paths(...)
                return RouteResult(paths=paths, ...)
    """

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        """
        Find candidate routes between source and destination.

        Args:
            source: Source node identifier
            destination: Destination node identifier
            bandwidth_gbps: Required bandwidth (used for modulation selection)
            network_state: Current network state (topology, config)
            forced_path: If provided, use this path instead of searching
                        (typically from partial grooming)

        Returns:
            RouteResult containing:
            - paths: Candidate paths as tuples of node IDs
            - weights_km: Path distances/weights in kilometers
            - modulations: Valid modulation formats per path
            - strategy_name: Name of routing algorithm used

        Raises:
            No exceptions - returns empty RouteResult if no routes found

        Side Effects:
            None - this is a pure query method

        Notes:
            - Number of paths limited by network_state.config.k_paths
            - Modulation formats filtered by reach based on path weight
            - Empty RouteResult.paths indicates no valid routes
        """
        ...
```

### 2. RouteResult Integration

The protocol returns `RouteResult` from Phase 1:

```python
@dataclass(frozen=True)
class RouteResult:
    paths: tuple[tuple[str, ...], ...]
    weights_km: tuple[float, ...]
    modulations: tuple[tuple[str, ...], ...]
    backup_paths: tuple[tuple[str, ...], ...] | None = None
    backup_weights_km: tuple[float, ...] | None = None
    backup_modulations: tuple[tuple[str, ...], ...] | None = None
    strategy_name: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)
```

### 3. Configuration Access Pattern

```python
# Protocol implementations access config through NetworkState
def find_routes(self, ..., network_state: NetworkState) -> RouteResult:
    config = network_state.config

    k_paths = config.k_paths
    route_method = config.route_method
    modulation_formats = config.modulation_formats
    snr_thresholds = config.snr_thresholds

    # Use topology from NetworkState
    topology = network_state.topology
```

### 4. Protected Route Finding

For 1+1 protection, routing finds disjoint paths:

```python
# Not a separate method - handled by RouteResult structure
# Implementations that support protection populate backup_* fields

def find_routes(self, ...) -> RouteResult:
    # Find primary paths
    primary_paths = ...

    # If protection enabled, find disjoint backup paths
    if network_state.config.protection_type == "1+1":
        backup_paths = find_disjoint_paths(...)
        return RouteResult(
            paths=primary_paths,
            backup_paths=backup_paths,
            ...
        )

    return RouteResult(paths=primary_paths, ...)
```

### 5. Empty Result Handling

```python
# When no routes found, return empty RouteResult
def find_routes(self, ...) -> RouteResult:
    paths = search_for_paths(...)

    if not paths:
        return RouteResult.empty(strategy_name=self.name)

    return RouteResult(paths=paths, ...)
```

### 6. Design Decisions

| Decision | Rationale |
|----------|-----------|
| Single method interface | Simpler than separate primary/backup methods |
| Forced path as parameter | Supports grooming workflow |
| No exceptions for "not found" | Empty result is valid outcome |
| `runtime_checkable` decorator | Enables isinstance checks if needed |
| Returns frozen RouteResult | Immutable result, no accidental mutation |

### 7. Compatibility Notes

The protocol is designed to wrap the existing `Routing` class:

```python
# Adapter pattern (implemented in P2.4)
class RoutingAdapter(RoutingPipeline):
    def __init__(self, config: SimulationConfig):
        self._legacy_routing = Routing(...)

    def find_routes(self, ..., network_state) -> RouteResult:
        # Call legacy method
        self._legacy_routing.get_route(source, destination, bandwidth)
        # Convert route_props to RouteResult
        return RouteResult.from_routing_props(self._legacy_routing.route_props)
```

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.3.e.

Key considerations:
1. Protocol must be compatible with legacy Routing class
2. Must work with Phase 1 RouteResult
3. No NetworkState storage in implementations
4. Configuration via network_state.config

## Next Task

After completing this design, proceed to `P2.3.c_design_spectrum_protocol.md`.
