# Task ID: P2.3.e - Implement All Protocol Definitions

**Sub-phase:** P2.3
**Scope:** Phase 2 - State Management only
**Task type:** refactor-plan

## Purpose

Implement all pipeline protocol definitions in `fusion/interfaces/pipelines.py`.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.b_design_routing_protocol.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.c_design_spectrum_protocol.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.d_design_grooming_snr_slicing_protocols.md`

## Outputs

### 1. Create Package Structure

```bash
mkdir -p fusion/interfaces
touch fusion/interfaces/__init__.py
touch fusion/interfaces/pipelines.py
```

### 2. Create fusion/interfaces/__init__.py

```python
"""
Pipeline interfaces for FUSION simulation.

This package defines Protocol classes for all pipeline components,
enabling type-safe abstractions over concrete implementations.

Phase: P2.3 - Pipeline Protocols
"""

from fusion.interfaces.pipelines import (
    GroomingPipeline,
    RoutingPipeline,
    SlicingPipeline,
    SNRPipeline,
    SpectrumPipeline,
)

__all__ = [
    "GroomingPipeline",
    "RoutingPipeline",
    "SlicingPipeline",
    "SNRPipeline",
    "SpectrumPipeline",
]
```

### 3. Create fusion/interfaces/pipelines.py

```python
"""
Pipeline protocol definitions for FUSION simulation.

This module defines typing.Protocol classes for all pipeline components:
- RoutingPipeline: Find candidate routes
- SpectrumPipeline: Find available spectrum
- GroomingPipeline: Pack requests onto existing lightpaths
- SNRPipeline: Validate signal quality
- SlicingPipeline: Divide requests into smaller allocations

Design Principles:
- Protocols are type-only definitions (no runtime behavior)
- All pipelines receive NetworkState as method parameter
- Pipelines do NOT store NetworkState as instance attribute
- Return structured result objects from fusion.domain.results

Phase: P2.3 - Pipeline Protocols

Usage:
    # Type hint a parameter as accepting any routing implementation
    def process_request(
        router: RoutingPipeline,
        network_state: NetworkState,
    ) -> RouteResult:
        return router.find_routes("A", "B", 100, network_state)

    # Check if object implements protocol
    if isinstance(my_router, RoutingPipeline):
        result = my_router.find_routes(...)
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Protocol, runtime_checkable

if TYPE_CHECKING:
    from fusion.domain.lightpath import Lightpath
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import (
        GroomingResult,
        RouteResult,
        SlicingResult,
        SNRResult,
        SpectrumResult,
    )


@runtime_checkable
class RoutingPipeline(Protocol):
    """
    Protocol for route finding algorithms.

    Implementations find candidate routes between source and destination
    nodes, returning paths with their weights and valid modulation formats.

    Design Notes:
        - Implementations should NOT store NetworkState as instance attribute
        - Receive NetworkState as method parameter for each call
        - Return RouteResult without modifying NetworkState
        - Configuration accessed via network_state.config

    Common Implementations:
        - K-shortest paths routing
        - Congestion-aware routing
        - Fragmentation-aware routing
        - NLI-aware routing (non-linear interference)
    """

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        """
        Find candidate routes between source and destination.

        Args:
            source: Source node identifier
            destination: Destination node identifier
            bandwidth_gbps: Required bandwidth (used for modulation selection)
            network_state: Current network state (topology, config)
            forced_path: If provided, use this path instead of searching
                        (typically from partial grooming)

        Returns:
            RouteResult containing candidate paths, weights, and modulations.
            Returns empty RouteResult if no routes found.

        Side Effects:
            None - this is a pure query method
        """
        ...


@runtime_checkable
class SpectrumPipeline(Protocol):
    """
    Protocol for spectrum assignment algorithms.

    Implementations find available spectrum slots along a path
    for a given bandwidth and modulation format.

    Design Notes:
        - Implementations should NOT store NetworkState as instance attribute
        - Return SpectrumResult without modifying NetworkState
        - Actual allocation done by NetworkState.create_lightpath()

    Common Implementations:
        - First-fit: Allocate lowest available slot range
        - Best-fit: Allocate smallest sufficient gap
        - Last-fit: Allocate highest available slot range
    """

    def find_spectrum(
        self,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        """
        Find available spectrum along a path.

        Args:
            path: Ordered list of node IDs forming the route
            modulation: Modulation format name (e.g., "QPSK", "16-QAM")
            bandwidth_gbps: Required bandwidth in Gbps
            network_state: Current network state

        Returns:
            SpectrumResult with slot range if found, or is_free=False.

        Side Effects:
            None - does NOT allocate spectrum
        """
        ...

    def find_protected_spectrum(
        self,
        primary_path: list[str],
        backup_path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        """
        Find spectrum for both primary and backup paths (1+1 protection).

        Args:
            primary_path: Primary route node sequence
            backup_path: Backup route node sequence (should be disjoint)
            modulation: Modulation format name
            bandwidth_gbps: Required bandwidth
            network_state: Current network state

        Returns:
            SpectrumResult with both primary and backup allocations,
            or is_free=False if either path lacks spectrum.

        Side Effects:
            None - does NOT allocate spectrum
        """
        ...


@runtime_checkable
class GroomingPipeline(Protocol):
    """
    Protocol for traffic grooming algorithms.

    Grooming attempts to pack multiple requests onto existing lightpaths
    that have available capacity, reducing new lightpath establishment.

    Design Notes:
        - MAY have side effects (modifies lightpath bandwidth)
        - Should support rollback for failed allocations
        - Returns GroomingResult indicating success/partial/failure

    Grooming Strategies:
        - Full grooming: Entire request fits on existing lightpath(s)
        - Partial grooming: Some bandwidth groomed, rest needs new lightpath
        - No grooming: No suitable lightpaths found
    """

    def try_groom(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> GroomingResult:
        """
        Attempt to groom request onto existing lightpaths.

        Args:
            request: The request to groom (source, destination, bandwidth)
            network_state: Current network state with active lightpaths

        Returns:
            GroomingResult indicating grooming outcome.

        Side Effects:
            If grooming succeeds, modifies lightpath bandwidth allocations.
        """
        ...

    def rollback_groom(
        self,
        request: Request,
        lightpath_ids: list[int],
        network_state: NetworkState,
    ) -> None:
        """
        Rollback grooming allocations (e.g., after downstream failure).

        Args:
            request: The request that was groomed
            lightpath_ids: Lightpath IDs to rollback
            network_state: Current network state

        Side Effects:
            Releases bandwidth from specified lightpaths.
        """
        ...


@runtime_checkable
class SNRPipeline(Protocol):
    """
    Protocol for signal-to-noise ratio validation.

    Validates that lightpaths meet SNR requirements for their
    modulation format, considering interference from other channels.

    Design Notes:
        - Pure query method (no side effects)
        - May check existing lightpaths affected by new allocation
        - Returns SNRResult with pass/fail and measured values

    SNR Considerations:
        - ASE noise from amplifiers
        - Non-linear interference (NLI)
        - Crosstalk in multi-core fibers (MCF)
        - Modulation-dependent thresholds
    """

    def validate(
        self,
        lightpath: Lightpath,
        network_state: NetworkState,
    ) -> SNRResult:
        """
        Validate SNR for a lightpath.

        Args:
            lightpath: The lightpath to validate
            network_state: Current network state with spectrum allocations

        Returns:
            SNRResult indicating pass/fail and SNR measurements.

        Side Effects:
            None - this is a pure query method
        """
        ...


@runtime_checkable
class SlicingPipeline(Protocol):
    """
    Protocol for request slicing algorithms.

    Slicing divides a large request into multiple smaller lightpaths
    when a single lightpath cannot accommodate the full bandwidth.

    Design Notes:
        - Pure query method (no side effects)
        - Used when normal allocation fails
        - Limited by config.max_slices
        - Does NOT create lightpaths (caller does)

    Slicing Strategies:
        - Static slicing: Fixed slice size
        - Dynamic slicing: Adaptive based on availability
    """

    def try_slice(
        self,
        request: Request,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SlicingResult:
        """
        Attempt to slice request into multiple smaller allocations.

        Args:
            request: The request being processed
            path: Route to use for slicing
            modulation: Modulation format for slices
            bandwidth_gbps: Total bandwidth to slice
            network_state: Current network state

        Returns:
            SlicingResult indicating if slicing is feasible.

        Side Effects:
            None - caller creates lightpaths based on result
        """
        ...
```

## Verification Commands

```bash
# Type checking (critical for protocols)
mypy fusion/interfaces/ --strict

# Linting
ruff check fusion/interfaces/

# Verify imports work
python -c "
from fusion.interfaces import (
    RoutingPipeline,
    SpectrumPipeline,
    GroomingPipeline,
    SNRPipeline,
    SlicingPipeline,
)
print('All protocols imported successfully')

# Verify runtime_checkable works
class MockRouter:
    def find_routes(self, source, destination, bandwidth_gbps, network_state, *, forced_path=None):
        pass

router = MockRouter()
print(f'isinstance check: {isinstance(router, RoutingPipeline)}')
"
```

## Important Notes

### TYPE_CHECKING Guard

All domain imports are inside `TYPE_CHECKING` to prevent circular imports:

```python
if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
    # ...
```

This means:
- Types are available for static analysis
- No runtime import of heavy modules
- Protocols remain lightweight

### runtime_checkable Decorator

The `@runtime_checkable` decorator enables `isinstance()` checks:

```python
if isinstance(my_object, RoutingPipeline):
    # Object has find_routes method with correct signature
    result = my_object.find_routes(...)
```

Note: Runtime checks only verify method names exist, not signatures.

### Ellipsis in Protocol Methods

Protocol methods use `...` (ellipsis) for the body:

```python
def find_routes(self, ...) -> RouteResult:
    ...  # Not pass, not raise NotImplementedError
```

This is the standard way to define protocol method stubs.

## Next Task

After implementing protocols, proceed to `P2.3.f_verify_protocols.md`.
