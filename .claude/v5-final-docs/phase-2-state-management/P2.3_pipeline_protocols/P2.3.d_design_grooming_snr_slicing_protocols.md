# Task ID: P2.3.d - Design Grooming, SNR, and Slicing Protocols

**Sub-phase:** P2.3
**Scope:** Phase 2 - State Management only
**Task type:** design

## Purpose

Design the remaining pipeline protocols: `GroomingPipeline`, `SNRPipeline`, and `SlicingPipeline`.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.a_extract_pipeline_signatures.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.c_design_grooming_slicing_results.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.d_design_snr_result.md`

## Outputs

### 1. GroomingPipeline Protocol Specification

```python
@runtime_checkable
class GroomingPipeline(Protocol):
    """
    Protocol for traffic grooming algorithms.

    Grooming attempts to pack multiple requests onto existing lightpaths
    that have available capacity, reducing the need for new lightpath
    establishment.

    Design Notes:
        - May modify lightpath bandwidth allocations (NOT pure query)
        - Should support rollback for failed allocations
        - Returns GroomingResult indicating success/partial/failure

    Grooming Strategies:
        - Full grooming: Entire request fits on existing lightpath(s)
        - Partial grooming: Some bandwidth groomed, rest needs new lightpath
        - No grooming: No suitable lightpaths found

    Example Implementation:
        class SimpleGrooming:
            def try_groom(
                self,
                request: Request,
                network_state: NetworkState,
            ) -> GroomingResult:
                candidates = network_state.get_lightpaths_with_capacity(
                    request.source,
                    request.destination,
                    min_bandwidth_gbps=1,
                )

                if not candidates:
                    return GroomingResult.no_grooming(request.bandwidth_gbps)

                # Try to fit on single lightpath
                for lp in candidates:
                    if lp.can_accommodate(request.bandwidth_gbps):
                        lp.allocate_bandwidth(request.request_id, request.bandwidth_gbps)
                        return GroomingResult.full(
                            request.bandwidth_gbps,
                            [lp.lightpath_id],
                        )

                # Partial grooming...
                return GroomingResult.no_grooming(request.bandwidth_gbps)
    """

    def try_groom(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> GroomingResult:
        """
        Attempt to groom request onto existing lightpaths.

        Args:
            request: The request to groom (source, destination, bandwidth)
            network_state: Current network state with active lightpaths

        Returns:
            GroomingResult containing:
            - fully_groomed: True if entire request was groomed
            - partially_groomed: True if some bandwidth was groomed
            - bandwidth_groomed_gbps: Amount successfully groomed
            - remaining_bandwidth_gbps: Amount still needing allocation
            - lightpaths_used: IDs of lightpaths used for grooming
            - forced_path: If partially groomed, suggested path for remainder

        Side Effects:
            If grooming succeeds (full or partial), modifies lightpath
            bandwidth allocations via Lightpath.allocate_bandwidth()

        Notes:
            - Searches lightpaths between request endpoints
            - May use multiple lightpaths for partial grooming
            - Does NOT modify NetworkState spectrum (lightpaths already exist)
        """
        ...

    def rollback_groom(
        self,
        request: Request,
        lightpath_ids: list[int],
        network_state: NetworkState,
    ) -> None:
        """
        Rollback grooming allocations (e.g., after downstream failure).

        Args:
            request: The request that was groomed
            lightpath_ids: Lightpath IDs to rollback
            network_state: Current network state

        Side Effects:
            Releases bandwidth from specified lightpaths via
            Lightpath.release_bandwidth()

        Notes:
            - Called when subsequent pipeline stages fail
            - Restores lightpath capacity
            - Safe to call even if request wasn't groomed on all lightpaths
        """
        ...
```

### 2. SNRPipeline Protocol Specification

```python
@runtime_checkable
class SNRPipeline(Protocol):
    """
    Protocol for signal-to-noise ratio validation.

    Validates that lightpaths meet SNR requirements for their
    modulation format, considering interference from other channels.

    Design Notes:
        - Pure query method (no side effects)
        - May check existing lightpaths affected by new allocation
        - Returns SNRResult with pass/fail and measured values

    SNR Considerations:
        - ASE noise from amplifiers
        - Non-linear interference (NLI) from other channels
        - Crosstalk in multi-core fibers (MCF)
        - Path length and modulation format dependent thresholds

    Example Implementation:
        class GNModelSNR:
            def validate(
                self,
                lightpath: Lightpath,
                network_state: NetworkState,
            ) -> SNRResult:
                config = network_state.config
                required_snr = config.snr_thresholds.get(lightpath.modulation, 10.0)

                # Calculate SNR using GN model
                snr_db = self._calculate_gn_model_snr(lightpath, network_state)

                if snr_db >= required_snr:
                    return SNRResult.success(snr_db, required_snr)
                else:
                    return SNRResult.failure(
                        snr_db,
                        required_snr,
                        reason="SNR below threshold",
                    )
    """

    def validate(
        self,
        lightpath: Lightpath,
        network_state: NetworkState,
    ) -> SNRResult:
        """
        Validate SNR for a lightpath.

        Args:
            lightpath: The lightpath to validate (may be newly created
                      or existing lightpath being rechecked)
            network_state: Current network state with spectrum allocations

        Returns:
            SNRResult containing:
            - passed: True if SNR meets threshold
            - snr_db: Measured/calculated SNR value
            - required_snr_db: Threshold for this modulation
            - margin_db: SNR margin above threshold
            - failure_reason: If failed, why
            - link_snr_values: Per-link SNR breakdown (optional)

        Side Effects:
            None - this is a pure query method

        Notes:
            - Uses lightpath.modulation to determine threshold
            - Considers interference from all other active lightpaths
            - May return different results before/after allocation
        """
        ...
```

### 3. SlicingPipeline Protocol Specification

```python
@runtime_checkable
class SlicingPipeline(Protocol):
    """
    Protocol for request slicing algorithms.

    Slicing divides a large request into multiple smaller lightpaths
    when a single lightpath cannot accommodate the full bandwidth.

    Design Notes:
        - Used when normal allocation fails due to spectrum fragmentation
        - Creates multiple smaller lightpaths that together serve request
        - Limited by config.max_slices

    Slicing Strategies:
        - Static slicing: Fixed slice size (e.g., 50 Gbps per slice)
        - Dynamic slicing: Adaptive slice size based on availability

    Example Implementation:
        class DynamicSlicing:
            def try_slice(
                self,
                request: Request,
                path: list[str],
                modulation: str,
                bandwidth_gbps: int,
                network_state: NetworkState,
            ) -> SlicingResult:
                config = network_state.config
                max_slices = config.max_slices

                # Try progressively smaller slices
                for num_slices in range(2, max_slices + 1):
                    slice_bw = bandwidth_gbps // num_slices
                    if self._can_allocate_slices(path, slice_bw, num_slices, network_state):
                        return SlicingResult.sliced(
                            num_slices=num_slices,
                            slice_bandwidth=slice_bw,
                            lightpath_ids=[],  # Caller creates lightpaths
                        )

                return SlicingResult.failed()
    """

    def try_slice(
        self,
        request: Request,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SlicingResult:
        """
        Attempt to slice request into multiple smaller allocations.

        Args:
            request: The request being processed
            path: Route to use for slicing
            modulation: Modulation format for slices
            bandwidth_gbps: Total bandwidth to slice
            network_state: Current network state

        Returns:
            SlicingResult containing:
            - success: True if slicing is possible
            - num_slices: Number of slices needed
            - slice_bandwidth_gbps: Bandwidth per slice
            - lightpaths_created: Empty (caller creates lightpaths)
            - total_bandwidth_gbps: Total bandwidth allocated

        Side Effects:
            None - this is a pure query method.
            Caller creates lightpaths based on result.

        Notes:
            - Only called when single lightpath allocation fails
            - Does NOT create lightpaths (just checks feasibility)
            - Limited by config.max_slices
            - Each slice needs its own spectrum range
        """
        ...
```

### 4. Result Type Integration

| Protocol | Result Type | Factory Methods |
|----------|-------------|-----------------|
| GroomingPipeline | `GroomingResult` | `.no_grooming()`, `.full()`, `.partial()` |
| SNRPipeline | `SNRResult` | `.success()`, `.failure()`, `.skipped()` |
| SlicingPipeline | `SlicingResult` | `.failed()`, `.sliced()` |

### 5. Protocol Relationships

```
Request Arrival
      │
      ▼
GroomingPipeline.try_groom()
      │
      ├── Fully groomed? ──► Done
      │
      ▼
RoutingPipeline.find_routes()
      │
      ▼
SpectrumPipeline.find_spectrum()
      │
      ├── Found? ──► SNRPipeline.validate() ──► Allocate
      │
      ▼
SlicingPipeline.try_slice()
      │
      ├── Success? ──► Create sliced lightpaths
      │
      ▼
Block request
```

### 6. Design Decisions

| Decision | Rationale |
|----------|-----------|
| Grooming has side effects | Must modify lightpath bandwidth |
| Grooming has rollback | Need to undo on downstream failure |
| SNR is pure query | Just validation, no state change |
| Slicing doesn't create | Keeps lightpath creation in one place |
| All receive NetworkState | Consistent pattern across protocols |

### 7. Grooming Side Effect Note

Grooming is unique among protocols - it has side effects:

```python
# Grooming modifies Lightpath objects
def try_groom(self, request, network_state) -> GroomingResult:
    lp = network_state.get_lightpath(lp_id)
    lp.allocate_bandwidth(request.request_id, bandwidth)  # Side effect!
    return GroomingResult.full(...)

# Rollback on failure
def rollback_groom(self, request, lightpath_ids, network_state) -> None:
    for lp_id in lightpath_ids:
        lp = network_state.get_lightpath(lp_id)
        if lp:
            lp.release_bandwidth(request.request_id)  # Undo side effect
```

This is acceptable because:
1. Grooming modifies existing lightpaths, not spectrum
2. Rollback method provides compensation
3. Alternative would require returning "pending" results

## Execution Notes

This task produces a **design specification only**. Implementation is in P2.3.e.

Key considerations:
1. Grooming is the only protocol with side effects
2. SNR and Slicing are pure queries
3. All integrate with Phase 1 result objects

---

## 8. Complete GroomingResult Fields (from Gap Analysis)

```python
@dataclass(frozen=True)
class GroomingResult:
    """
    Complete result of a grooming attempt.

    Contains all information needed for:
    1. Determining next steps (full/partial/none)
    2. Tracking which lightpaths were used
    3. Constraining subsequent allocation attempts
    """

    # Outcome flags
    fully_groomed: bool          # True if entire request was groomed
    partially_groomed: bool      # True if some bandwidth was groomed
    no_grooming: bool            # True if no grooming possible

    # Bandwidth tracking
    bandwidth_groomed_gbps: int  # Amount successfully groomed
    remaining_bandwidth_gbps: int  # Amount still needing allocation

    # Lightpath tracking
    lightpath_ids: list[int]     # Lightpaths used for grooming
    lightpath_bandwidths: list[int]  # Bandwidth allocated per lightpath

    # Constraints for subsequent allocation
    forced_path: list[str] | None  # If partially groomed, path constraint
    forced_modulations: list[str] | None  # Allowed modulations for remainder
    forced_path_weight: float | None  # Path weight for partial allocation

    @classmethod
    def no_grooming_available(cls, total_bandwidth: int) -> "GroomingResult":
        """Factory for no grooming available."""
        return cls(
            fully_groomed=False,
            partially_groomed=False,
            no_grooming=True,
            bandwidth_groomed_gbps=0,
            remaining_bandwidth_gbps=total_bandwidth,
            lightpath_ids=[],
            lightpath_bandwidths=[],
            forced_path=None,
            forced_modulations=None,
            forced_path_weight=None,
        )

    @classmethod
    def full(
        cls,
        bandwidth: int,
        lightpath_ids: list[int],
        lightpath_bandwidths: list[int],
    ) -> "GroomingResult":
        """Factory for fully groomed request."""
        return cls(
            fully_groomed=True,
            partially_groomed=False,
            no_grooming=False,
            bandwidth_groomed_gbps=bandwidth,
            remaining_bandwidth_gbps=0,
            lightpath_ids=lightpath_ids,
            lightpath_bandwidths=lightpath_bandwidths,
            forced_path=None,
            forced_modulations=None,
            forced_path_weight=None,
        )

    @classmethod
    def partial(
        cls,
        bandwidth_groomed: int,
        remaining: int,
        lightpath_ids: list[int],
        lightpath_bandwidths: list[int],
        forced_path: list[str],
        forced_path_weight: float,
        forced_modulations: list[str] | None = None,
    ) -> "GroomingResult":
        """Factory for partially groomed request."""
        return cls(
            fully_groomed=False,
            partially_groomed=True,
            no_grooming=False,
            bandwidth_groomed_gbps=bandwidth_groomed,
            remaining_bandwidth_gbps=remaining,
            lightpath_ids=lightpath_ids,
            lightpath_bandwidths=lightpath_bandwidths,
            forced_path=forced_path,
            forced_modulations=forced_modulations,
            forced_path_weight=forced_path_weight,
        )
```

---

## 9. SNR Recheck Protocol (from Gap Analysis)

The basic SNRPipeline.validate() checks SNR for a single lightpath. However, after allocation, existing lightpaths may be affected by interference. The recheck protocol addresses this:

```python
@runtime_checkable
class SNRPipeline(Protocol):
    """Extended SNRPipeline with recheck capability."""

    def validate(
        self,
        lightpath: Lightpath,
        network_state: NetworkState,
    ) -> SNRResult:
        """Validate SNR for a lightpath (as defined above)."""
        ...

    def recheck_affected(
        self,
        new_lightpath_id: int,
        network_state: NetworkState,
        *,
        affected_range_slots: int = 5,
    ) -> SNRRecheckResult:
        """
        Recheck SNR of existing lightpaths after new allocation.

        Some existing lightpaths may be degraded by the new
        allocation's interference. This identifies them.

        Args:
            new_lightpath_id: ID of newly created lightpath
            network_state: Current network state
            affected_range_slots: Consider lightpaths within this many
                                 slots of the new allocation

        Returns:
            SNRRecheckResult with:
            - all_pass: True if all affected lightpaths still pass
            - degraded_lightpath_ids: List of lightpath IDs now failing
            - violations: Dict mapping lightpath_id -> SNR shortfall (dB)

        Side Effects:
            None - pure query method

        Notes:
            - Only checks lightpaths on same links as new allocation
            - Only checks lightpaths in nearby spectrum (within range)
            - Used to trigger rollback if existing lightpaths degraded
        """
        ...


@dataclass(frozen=True)
class SNRRecheckResult:
    """Result of SNR recheck after new allocation."""

    all_pass: bool                      # True if all affected lightpaths OK
    degraded_lightpath_ids: list[int]   # Lightpaths now below threshold
    violations: dict[int, float]        # lightpath_id -> SNR shortfall in dB

    @classmethod
    def success(cls) -> "SNRRecheckResult":
        """All affected lightpaths still pass."""
        return cls(
            all_pass=True,
            degraded_lightpath_ids=[],
            violations={},
        )

    @classmethod
    def degraded(
        cls,
        degraded_ids: list[int],
        violations: dict[int, float],
    ) -> "SNRRecheckResult":
        """Some lightpaths are now degraded."""
        return cls(
            all_pass=False,
            degraded_lightpath_ids=degraded_ids,
            violations=violations,
        )
```

---

## 10. SlicingPipeline with Rollback (from Gap Analysis)

The basic SlicingPipeline is a pure query, but the orchestrator needs to handle rollback when sliced allocations fail partway through:

```python
@runtime_checkable
class SlicingPipeline(Protocol):
    """Extended SlicingPipeline with allocation support."""

    def try_slice(
        self,
        request: Request,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        max_slices: int | None = None,
        spectrum_pipeline: "SpectrumPipeline | None" = None,
        snr_pipeline: "SNRPipeline | None" = None,
    ) -> SlicingResult:
        """
        Attempt to slice request into multiple smaller allocations.

        Extended parameters:
            max_slices: Override config.max_slices
            spectrum_pipeline: Pipeline for finding spectrum per slice
            snr_pipeline: Pipeline for validating each slice

        Notes:
            When spectrum_pipeline and snr_pipeline are provided,
            this method can fully allocate slices rather than just
            checking feasibility.
        """
        ...

    def rollback_slices(
        self,
        lightpath_ids: list[int],
        network_state: NetworkState,
    ) -> None:
        """
        Rollback all slices on failure.

        Called when partial slice allocation fails and all
        created slices must be released.

        Args:
            lightpath_ids: IDs of lightpaths to release
            network_state: Network state to modify

        Side Effects:
            Deletes specified lightpaths from network_state
        """
        ...


@dataclass(frozen=True)
class SlicingResult:
    """
    Complete result of a slicing attempt.
    """

    # Outcome
    success: bool                    # True if slicing succeeded
    blocked: bool                    # True if slicing impossible

    # Slice details
    num_slices: int                  # Number of slices created/needed
    slice_bandwidths_gbps: list[int]  # Bandwidth per slice
    total_bandwidth_gbps: int        # Total bandwidth allocated

    # Created lightpaths (empty if just feasibility check)
    lightpath_ids: list[int]         # IDs of created lightpaths

    # Per-slice allocation details
    slice_slots: list[tuple[int, int]]  # (start, end) per slice
    slice_cores: list[int]           # Core per slice
    slice_bands: list[str]           # Band per slice

    @classmethod
    def failed(cls) -> "SlicingResult":
        """Slicing not possible."""
        return cls(
            success=False,
            blocked=True,
            num_slices=0,
            slice_bandwidths_gbps=[],
            total_bandwidth_gbps=0,
            lightpath_ids=[],
            slice_slots=[],
            slice_cores=[],
            slice_bands=[],
        )

    @classmethod
    def sliced(
        cls,
        num_slices: int,
        slice_bandwidths: list[int],
        lightpath_ids: list[int],
        slice_slots: list[tuple[int, int]],
        slice_cores: list[int],
        slice_bands: list[str],
    ) -> "SlicingResult":
        """Slicing succeeded."""
        return cls(
            success=True,
            blocked=False,
            num_slices=num_slices,
            slice_bandwidths_gbps=slice_bandwidths,
            total_bandwidth_gbps=sum(slice_bandwidths),
            lightpath_ids=lightpath_ids,
            slice_slots=slice_slots,
            slice_cores=slice_cores,
            slice_bands=slice_bands,
        )
```

---

## 11. Protocol Rollback Contract Summary

| Protocol | Mutates State? | Rollback Method | Rollback Trigger |
|----------|---------------|-----------------|------------------|
| RoutingPipeline | No | N/A | N/A |
| SpectrumPipeline | No | N/A | N/A |
| GroomingPipeline | Yes (bandwidth) | `rollback_groom()` | Downstream failure |
| SNRPipeline | No | N/A | N/A (triggers rollback of others) |
| SlicingPipeline | Yes (lightpaths) | `rollback_slices()` | SNR failure on any slice |

---

## Next Task

After completing this design, proceed to `P2.3.e_implement_all_protocols.md`.
