# Task ID: P2.3.a - Extract Pipeline Signatures

**Sub-phase:** P2.3
**Scope:** Phase 2 - State Management only
**Task type:** context-extraction

## Purpose

Extract the current signatures and behaviors of legacy pipeline entry points to inform protocol design.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.shared_context_existing_entrypoints.md`
- `fusion/core/routing.py` (get_route method, ~line 179)
- `fusion/core/spectrum_assignment.py` (get_spectrum method)
- `fusion/core/grooming.py` (handle_grooming method)

## Outputs

### 1. Routing Pipeline Signature Analysis

**Legacy Entry Point**: `Routing.get_route()`

| Aspect | Legacy | Protocol Equivalent |
|--------|--------|---------------------|
| Input: source | `int \| str` (node ID) | `str` (standardize on str) |
| Input: destination | `int \| str` | `str` |
| Input: bandwidth | `float` (via request) | `int` (bandwidth_gbps) |
| Input: k_paths | From `engine_props` | From `network_state.config.k_paths` |
| Input: forced_path | Optional, from grooming | Optional `list[str]` parameter |
| Output: paths | `route_props.paths_matrix` | `RouteResult.paths` |
| Output: weights | `route_props.weights_list` | `RouteResult.weights_km` |
| Output: modulations | `route_props.modulation_formats_matrix` | `RouteResult.modulations` |
| Side effects | Updates `route_props` | Returns `RouteResult` (pure) |

**Protocol Signature**:
```python
def find_routes(
    self,
    source: str,
    destination: str,
    bandwidth_gbps: int,
    network_state: NetworkState,
    *,
    forced_path: list[str] | None = None,
) -> RouteResult
```

### 2. Spectrum Pipeline Signature Analysis

**Legacy Entry Point**: `SpectrumAssignment.get_spectrum()`

| Aspect | Legacy | Protocol Equivalent |
|--------|--------|---------------------|
| Input: path | `list[str]` | `list[str]` |
| Input: modulation | `str` | `str` |
| Input: bandwidth | `float` | `int` (bandwidth_gbps) |
| Input: core | From iteration | Explicit `int` or search all |
| Input: band | From iteration | Explicit `str` or search all |
| Output: is_free | `spectrum_props.is_free` | `SpectrumResult.is_free` |
| Output: start_slot | `spectrum_props.start_slot` | `SpectrumResult.start_slot` |
| Output: end_slot | `spectrum_props.end_slot` | `SpectrumResult.end_slot` |
| Output: core | `spectrum_props.core_number` | `SpectrumResult.core` |
| Output: band | `spectrum_props.current_band` | `SpectrumResult.band` |
| Side effects | Updates `spectrum_props` | Returns `SpectrumResult` (pure) |

**Protocol Signature**:
```python
def find_spectrum(
    self,
    path: list[str],
    modulation: str,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> SpectrumResult

def find_protected_spectrum(
    self,
    primary_path: list[str],
    backup_path: list[str],
    modulation: str,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> SpectrumResult  # Contains both primary and backup allocation info
```

### 3. Grooming Pipeline Signature Analysis

**Legacy Entry Point**: `Grooming.handle_grooming()`

| Aspect | Legacy | Protocol Equivalent |
|--------|--------|---------------------|
| Input: request_type | `str` ("arrival"/"release") | Separate methods |
| Input: request | Via `self.sdn_props` | Explicit `Request` parameter |
| Output: fully_groomed | Return tuple[0] | `GroomingResult.fully_groomed` |
| Output: lightpath_ids | Return tuple[1] | `GroomingResult.lightpaths_used` |
| Output: forced_path | Return tuple[2] | `GroomingResult.forced_path` |
| Output: partial | Derived | `GroomingResult.partially_groomed` |
| Side effects | Modifies lightpath bandwidth | Method mutates via NetworkState |

**Protocol Signature**:
```python
def try_groom(
    self,
    request: Request,
    network_state: NetworkState,
) -> GroomingResult

def rollback_groom(
    self,
    request: Request,
    lightpath_ids: list[int],
    network_state: NetworkState,
) -> None
```

### 4. SNR Pipeline Signature Analysis

**Legacy Entry Points**: `SnrMeasurements.calculate_snr()`, `.recheck_snr_after_allocation()`

| Aspect | Legacy | Protocol Equivalent |
|--------|--------|---------------------|
| Input: path/lightpath | Path or lightpath_id | `Lightpath` object |
| Input: modulation | `str` | From `Lightpath.modulation` |
| Input: spectrum | start/end/core/band | From `Lightpath` |
| Output: passed | `bool` return | `SNRResult.passed` |
| Output: snr_db | `float` return | `SNRResult.snr_db` |
| Output: required_snr | From thresholds | `SNRResult.required_snr_db` |
| Side effects | Updates `spectrum_props.snr_db` | Returns `SNRResult` (pure) |

**Protocol Signature**:
```python
def validate(
    self,
    lightpath: Lightpath,
    network_state: NetworkState,
) -> SNRResult
```

### 5. Slicing Pipeline Signature Analysis

**Legacy Entry Point**: `LightPathSlicing.try_slice()`

| Aspect | Legacy | Protocol Equivalent |
|--------|--------|---------------------|
| Input: bandwidth | `float` | `int` (bandwidth_gbps) |
| Input: path | `list[str]` | `list[str]` |
| Input: modulation | `str` | `str` |
| Input: max_slices | From config | From `network_state.config` |
| Output: success | Return tuple[0] | `SlicingResult.success` |
| Output: num_slices | Return tuple[1] | `SlicingResult.num_slices` |
| Output: slice_bw | Return tuple[2] | `SlicingResult.slice_bandwidth_gbps` |
| Side effects | Creates lightpaths | Returns result, caller creates |

**Protocol Signature**:
```python
def try_slice(
    self,
    request: Request,
    path: list[str],
    modulation: str,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> SlicingResult
```

### 6. Common Observations

1. **All pipelines need NetworkState**: Replaces scattered prop access
2. **Pure return values**: No mutation of property objects
3. **Request as parameter**: Instead of reading from sdn_props
4. **Lightpath as parameter**: For SNR validation
5. **Explicit types**: No int|str ambiguity, standardize on str for nodes

### 7. Optional Protocol Methods

Some protocols may need additional methods:

| Protocol | Optional Method | Purpose |
|----------|-----------------|---------|
| SpectrumPipeline | `calculate_slots_needed()` | Compute slots from bandwidth/mod |
| SNRPipeline | `validate_batch()` | Check multiple lightpaths |
| GroomingPipeline | `find_candidates()` | List potential lightpaths |

## Execution Notes

This is a **read-only analysis task**. Document the signatures to guide P2.3.b-d design tasks.

Focus on:
1. Input parameters and their types
2. Output structure mapping to result objects
3. Side effects that need to become pure returns
4. Configuration access patterns

## Next Task

After extracting signatures, proceed to `P2.3.b_design_routing_protocol.md`.
