# P2.3 Shared Context: Existing Pipeline Entry Points

## Purpose

This document summarizes the current pipeline entry points in legacy FUSION code. Reference this when designing protocol signatures to ensure compatibility.

## Source Files

| Pipeline | File | Class/Function |
|----------|------|----------------|
| Routing | `fusion/core/routing.py` | `Routing.get_route()` |
| Spectrum | `fusion/core/spectrum_assignment.py` | `SpectrumAssignment.get_spectrum()` |
| Grooming | `fusion/core/grooming.py` | `Grooming.handle_grooming()` |
| SNR | `fusion/core/snr_measurements.py` | `SnrMeasurements` methods |
| Slicing | `fusion/modules/spectrum/light_path_slicing.py` | `LightPathSlicing` |

---

## Routing Entry Points

### Routing.get_route()

**Location**: `fusion/core/routing.py:179`

**Current Signature** (conceptual):
```python
def get_route(
    self,
    source: int | str,
    destination: int | str,
    request_bandwidth: float,
) -> None:
    """
    Find candidate routes between source and destination.

    Updates self.route_props with:
    - paths_matrix: list of candidate paths
    - weights_list: path weights/distances
    - modulation_formats_matrix: valid modulations per path
    """
```

**State Dependencies**:
- Reads: `self.engine_props` (config), `self.sdn_props.topology`
- Writes: `self.route_props` (paths_matrix, weights_list, etc.)

**Key Behaviors**:
1. Uses registry to dispatch to specific routing algorithm
2. Filters paths by modulation reach
3. Supports forced path (for grooming)
4. Returns k-shortest paths with weights

### Modular Routing Algorithms

**Location**: `fusion/modules/routing/`

Each algorithm implements:
```python
def find_routes(
    engine_props: EngineProps,
    sdn_props: SDNProps,
    source: str,
    destination: str,
    bandwidth: float,
    k_paths: int,
) -> tuple[list[list[str]], list[float]]:
    """Returns (paths, weights)"""
```

---

## Spectrum Entry Points

### SpectrumAssignment.get_spectrum()

**Location**: `fusion/core/spectrum_assignment.py`

**Current Signature** (conceptual):
```python
def get_spectrum(
    self,
    path: list[str],
    modulation: str,
    bandwidth: float,
) -> bool:
    """
    Find and optionally allocate spectrum on path.

    Updates self.spectrum_props with:
    - is_free: bool
    - start_slot: int
    - end_slot: int
    - core_number: int
    - current_band: str

    Returns True if spectrum found, False otherwise.
    """
```

**State Dependencies**:
- Reads: `self.engine_props`, `self.sdn_props.network_spectrum_dict`
- Writes: `self.spectrum_props`, optionally `sdn_props.network_spectrum_dict`

**Key Behaviors**:
1. Calculates slots needed from bandwidth and modulation
2. Uses allocation method (first_fit, best_fit, last_fit)
3. Searches across bands and cores
4. Validates SNR if enabled
5. Can allocate or just search

### Protected Spectrum (1+1)

For protection, spectrum assignment is called twice:
1. Primary path allocation
2. Backup path allocation (disjoint)

---

## Grooming Entry Points

### Grooming.handle_grooming()

**Location**: `fusion/core/grooming.py`

**Current Signature** (conceptual):
```python
def handle_grooming(
    self,
    request_type: str,  # "arrival" or "release"
) -> tuple[bool, list[int], list[str] | None]:
    """
    Try to groom request onto existing lightpaths.

    For arrivals:
    - Searches lightpath_status_dict for lightpaths with capacity
    - Allocates bandwidth if found
    - Returns (fully_groomed, lightpath_ids, forced_path)

    For releases:
    - Finds lightpaths serving this request
    - Releases bandwidth allocations
    - Returns lightpaths to potentially release

    Returns:
        (is_fully_groomed, lightpath_ids_used, forced_path_or_none)
    """
```

**State Dependencies**:
- Reads: `self.sdn_props.lightpath_status_dict`, request info
- Writes: Lightpath bandwidth allocations

**Key Behaviors**:
1. Looks for lightpaths between same endpoints
2. Checks remaining bandwidth capacity
3. Supports partial grooming (some bandwidth groomed)
4. Returns forced_path if partially groomed (for new lightpath)

---

## SNR Entry Points

### SnrMeasurements

**Location**: `fusion/core/snr_measurements.py`

**Key Methods**:
```python
def calculate_snr(
    self,
    path: list[str],
    modulation: str,
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
) -> tuple[bool, float]:
    """
    Calculate SNR for a potential allocation.

    Returns:
        (passes_threshold, snr_db)
    """

def recheck_snr_after_allocation(
    self,
    lightpath_id: int,
) -> bool:
    """
    Recheck SNR after new allocation (for existing lightpaths).

    Returns True if all affected lightpaths still pass SNR.
    """
```

**State Dependencies**:
- Reads: `self.engine_props`, `self.sdn_props.network_spectrum_dict`, lightpath info
- Writes: `self.spectrum_props.snr_db`, degradation flags

---

## Slicing Entry Points

### LightPathSlicing

**Location**: `fusion/modules/spectrum/light_path_slicing.py`

**Current Behavior**:
```python
def try_slice(
    self,
    request_bandwidth: float,
    path: list[str],
    modulation: str,
) -> tuple[bool, int, int]:
    """
    Try to slice request across multiple lightpaths.

    Returns:
        (success, num_slices, slice_bandwidth)

    If successful, creates multiple smaller lightpaths.
    """
```

**Key Behaviors**:
1. Divides bandwidth into smaller chunks
2. Attempts to allocate each chunk separately
3. Limited by max_slices configuration
4. Only used when normal allocation fails

---

## Protocol Design Implications

### Common Patterns

1. **NetworkState replaces sdn_props**: All state access through NetworkState
2. **Config from SimulationConfig**: Not engine_props
3. **Result objects instead of property mutation**: Return structured results
4. **No side effects in find methods**: Allocation is separate

### Signature Mapping

| Legacy | Protocol |
|--------|----------|
| `engine_props` | `network_state.config` |
| `sdn_props.network_spectrum_dict` | `network_state.get_link_spectrum()` |
| `sdn_props.lightpath_status_dict` | `network_state.get_lightpaths_between()` |
| `route_props` (output) | `RouteResult` return |
| `spectrum_props` (output) | `SpectrumResult` return |

### Pass-by-Reference

All protocols receive `NetworkState` as a method parameter:
```python
def find_routes(self, ..., network_state: NetworkState) -> RouteResult:
```

Not stored as instance variable:
```python
# BAD
class BadPipeline:
    def __init__(self, network_state):
        self._state = network_state  # Don't do this!
```

---

## References

- Routing: `fusion/core/routing.py`
- Spectrum: `fusion/core/spectrum_assignment.py`
- Grooming: `fusion/core/grooming.py`
- SNR: `fusion/core/snr_measurements.py`
- Slicing: `fusion/modules/spectrum/light_path_slicing.py`
