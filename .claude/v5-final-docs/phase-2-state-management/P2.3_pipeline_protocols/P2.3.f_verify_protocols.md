# Task ID: P2.3.f - Verify Protocol Definitions

**Sub-phase:** P2.3
**Scope:** Phase 2 - State Management only
**Task type:** verification-plan

## Purpose

Verify that all protocol definitions are correct, pass type checking, and can be implemented.

## Context to load before running this task

- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.e_implement_all_protocols.md`
- `fusion/interfaces/pipelines.py` (implementation)

## Outputs

### 1. Create Test File

**File**: `fusion/tests/interfaces/test_pipelines.py`

```python
"""
Tests for pipeline protocol definitions.

These tests verify:
1. Protocols are importable and usable
2. Mock implementations satisfy protocols
3. runtime_checkable works correctly
4. Type hints are valid

Phase: P2.3 - Pipeline Protocols
"""

from __future__ import annotations

from typing import TYPE_CHECKING

import pytest

from fusion.interfaces import (
    GroomingPipeline,
    RoutingPipeline,
    SlicingPipeline,
    SNRPipeline,
    SpectrumPipeline,
)

if TYPE_CHECKING:
    from fusion.domain.lightpath import Lightpath
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import (
        GroomingResult,
        RouteResult,
        SlicingResult,
        SNRResult,
        SpectrumResult,
    )


# =============================================================================
# Mock Implementations for Testing
# =============================================================================

class MockRoutingPipeline:
    """Mock implementation of RoutingPipeline for testing."""

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        # Return a minimal RouteResult
        from fusion.domain.results import RouteResult
        return RouteResult.empty("mock")


class MockSpectrumPipeline:
    """Mock implementation of SpectrumPipeline for testing."""

    def find_spectrum(
        self,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        from fusion.domain.results import SpectrumResult
        return SpectrumResult.not_found(10)

    def find_protected_spectrum(
        self,
        primary_path: list[str],
        backup_path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SpectrumResult:
        from fusion.domain.results import SpectrumResult
        return SpectrumResult.not_found(10)


class MockGroomingPipeline:
    """Mock implementation of GroomingPipeline for testing."""

    def try_groom(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> GroomingResult:
        from fusion.domain.results import GroomingResult
        return GroomingResult.no_grooming(100)

    def rollback_groom(
        self,
        request: Request,
        lightpath_ids: list[int],
        network_state: NetworkState,
    ) -> None:
        pass


class MockSNRPipeline:
    """Mock implementation of SNRPipeline for testing."""

    def validate(
        self,
        lightpath: Lightpath,
        network_state: NetworkState,
    ) -> SNRResult:
        from fusion.domain.results import SNRResult
        return SNRResult.skipped()


class MockSlicingPipeline:
    """Mock implementation of SlicingPipeline for testing."""

    def try_slice(
        self,
        request: Request,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SlicingResult:
        from fusion.domain.results import SlicingResult
        return SlicingResult.failed()


# =============================================================================
# Protocol Import Tests
# =============================================================================

class TestProtocolImports:
    """Test that protocols are importable."""

    def test_import_routing_pipeline(self) -> None:
        """RoutingPipeline should be importable."""
        assert RoutingPipeline is not None

    def test_import_spectrum_pipeline(self) -> None:
        """SpectrumPipeline should be importable."""
        assert SpectrumPipeline is not None

    def test_import_grooming_pipeline(self) -> None:
        """GroomingPipeline should be importable."""
        assert GroomingPipeline is not None

    def test_import_snr_pipeline(self) -> None:
        """SNRPipeline should be importable."""
        assert SNRPipeline is not None

    def test_import_slicing_pipeline(self) -> None:
        """SlicingPipeline should be importable."""
        assert SlicingPipeline is not None


# =============================================================================
# runtime_checkable Tests
# =============================================================================

class TestRuntimeCheckable:
    """Test runtime_checkable functionality."""

    def test_mock_routing_is_routing_pipeline(self) -> None:
        """Mock routing should pass isinstance check."""
        mock = MockRoutingPipeline()
        assert isinstance(mock, RoutingPipeline)

    def test_mock_spectrum_is_spectrum_pipeline(self) -> None:
        """Mock spectrum should pass isinstance check."""
        mock = MockSpectrumPipeline()
        assert isinstance(mock, SpectrumPipeline)

    def test_mock_grooming_is_grooming_pipeline(self) -> None:
        """Mock grooming should pass isinstance check."""
        mock = MockGroomingPipeline()
        assert isinstance(mock, GroomingPipeline)

    def test_mock_snr_is_snr_pipeline(self) -> None:
        """Mock SNR should pass isinstance check."""
        mock = MockSNRPipeline()
        assert isinstance(mock, SNRPipeline)

    def test_mock_slicing_is_slicing_pipeline(self) -> None:
        """Mock slicing should pass isinstance check."""
        mock = MockSlicingPipeline()
        assert isinstance(mock, SlicingPipeline)

    def test_wrong_class_not_protocol(self) -> None:
        """Class without correct methods should fail isinstance."""

        class WrongClass:
            def wrong_method(self) -> None:
                pass

        obj = WrongClass()
        assert not isinstance(obj, RoutingPipeline)
        assert not isinstance(obj, SpectrumPipeline)


# =============================================================================
# Protocol Method Signature Tests
# =============================================================================

class TestProtocolMethodSignatures:
    """Test that protocols have expected methods."""

    def test_routing_has_find_routes(self) -> None:
        """RoutingPipeline should have find_routes method."""
        assert hasattr(RoutingPipeline, "find_routes")

    def test_spectrum_has_find_spectrum(self) -> None:
        """SpectrumPipeline should have find_spectrum method."""
        assert hasattr(SpectrumPipeline, "find_spectrum")

    def test_spectrum_has_find_protected_spectrum(self) -> None:
        """SpectrumPipeline should have find_protected_spectrum method."""
        assert hasattr(SpectrumPipeline, "find_protected_spectrum")

    def test_grooming_has_try_groom(self) -> None:
        """GroomingPipeline should have try_groom method."""
        assert hasattr(GroomingPipeline, "try_groom")

    def test_grooming_has_rollback_groom(self) -> None:
        """GroomingPipeline should have rollback_groom method."""
        assert hasattr(GroomingPipeline, "rollback_groom")

    def test_snr_has_validate(self) -> None:
        """SNRPipeline should have validate method."""
        assert hasattr(SNRPipeline, "validate")

    def test_slicing_has_try_slice(self) -> None:
        """SlicingPipeline should have try_slice method."""
        assert hasattr(SlicingPipeline, "try_slice")


# =============================================================================
# Type Annotation Tests (via mypy in CI)
# =============================================================================

class TestTypeAnnotations:
    """Test type annotations are valid (via static analysis)."""

    def test_routing_pipeline_annotation(self) -> None:
        """Verify RoutingPipeline can be used as type hint."""

        def accept_router(router: RoutingPipeline) -> None:
            pass

        mock = MockRoutingPipeline()
        accept_router(mock)  # Should not raise

    def test_spectrum_pipeline_annotation(self) -> None:
        """Verify SpectrumPipeline can be used as type hint."""

        def accept_spectrum(spectrum: SpectrumPipeline) -> None:
            pass

        mock = MockSpectrumPipeline()
        accept_spectrum(mock)

    def test_grooming_pipeline_annotation(self) -> None:
        """Verify GroomingPipeline can be used as type hint."""

        def accept_grooming(grooming: GroomingPipeline) -> None:
            pass

        mock = MockGroomingPipeline()
        accept_grooming(mock)
```

### 2. Create Test Directory Structure

```bash
mkdir -p fusion/tests/interfaces
touch fusion/tests/interfaces/__init__.py
```

### 3. Verification Commands

```bash
# 1. Type checking (CRITICAL)
mypy fusion/interfaces/ --strict

# 2. Linting
ruff check fusion/interfaces/

# 3. Run tests
pytest fusion/tests/interfaces/test_pipelines.py -v

# 4. Verify no circular imports
python -c "
import sys
# Clear any cached imports
for mod in list(sys.modules.keys()):
    if 'fusion' in mod:
        del sys.modules[mod]

# Import protocols first (should not trigger domain imports)
from fusion.interfaces import RoutingPipeline
print('Protocols import without triggering domain imports')

# Now import domain
from fusion.domain.network_state import NetworkState
print('Domain imports work after protocols')
"

# 5. Full import test
python -c "
from fusion.interfaces import (
    RoutingPipeline,
    SpectrumPipeline,
    GroomingPipeline,
    SNRPipeline,
    SlicingPipeline,
)
print('All protocols:', [
    RoutingPipeline.__name__,
    SpectrumPipeline.__name__,
    GroomingPipeline.__name__,
    SNRPipeline.__name__,
    SlicingPipeline.__name__,
])
"
```

## Verification Checklist

After running tests, verify:

- [ ] `mypy fusion/interfaces/ --strict` passes with no errors
- [ ] `ruff check fusion/interfaces/` passes
- [ ] All unit tests pass
- [ ] No circular import issues
- [ ] `runtime_checkable` works for isinstance checks
- [ ] Mock implementations satisfy protocols
- [ ] Protocols can be used as type hints

## Common Issues

### Issue: Circular Import

**Symptom**: ImportError when importing protocols

**Solution**: Ensure all domain imports are inside `TYPE_CHECKING`:

```python
if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
```

### Issue: mypy Error on Protocol Methods

**Symptom**: mypy complains about method signatures

**Solution**: Use `...` not `pass` for protocol method bodies:

```python
def find_routes(self, ...) -> RouteResult:
    ...  # Correct
```

### Issue: isinstance Returns False

**Symptom**: Mock implementation fails isinstance check

**Solution**: Ensure mock has ALL required methods with matching names:

```python
class MockSpectrumPipeline:
    def find_spectrum(self, ...): ...        # Required
    def find_protected_spectrum(self, ...): ...  # Also required!
```

## Exit Criteria for P2.3

P2.3 is complete when:

1. `fusion/interfaces/` package created
2. All five protocols defined in `pipelines.py`
3. `mypy --strict` passes on all interface files
4. `ruff check` passes
5. Unit tests verify protocol usability
6. No circular imports

## Next Sub-phase

After P2.3 verification passes, proceed to [P2.4 Legacy Adapters](../P2.4_legacy_adapters/P2.4.index.md).
