# Phase 2 Gap Analysis: State Management

## Overview

This document analyzes gaps identified in the Phase 2 State Management documentation after reviewing the v4 architecture docs and the actual FUSION codebase. The analysis ensures that:
1. All state sources are properly mapped
2. All legacy write paths are identified and wrapped
3. Pipeline protocols are fully specified
4. Legacy adapters are enumerated and scoped

---

## Gap Summary

| Area | Gap | Severity | Resolution |
|------|-----|----------|------------|
| P2.1 | Missing `stats_props` state coverage | Medium | Add to shared context |
| P2.1 | Missing `reqs_status_dict` coverage | Medium | Document as SimEngine state |
| P2.1 | Missing per-module property objects | High | Add comprehensive props mapping |
| P2.2 | Incomplete lightpath entry fields | High | Add all fields to spec |
| P2.2 | Missing protection path handling | Medium | Document backup allocation |
| P2.3 | Incomplete SlicingPipeline spec | Medium | Add detailed protocol |
| P2.4 | Missing SlicingAdapter | Low | Note separate handling |

---

## Section 1: State Sources Not Covered (P2.1 Gaps)

### 1.1 stats_props (StatsProps)

**Location**: `fusion/core/properties.py:549-612`

**Current Coverage**: Not mentioned in P2.1 documentation

**State Managed**:
```python
class StatsProps:
    snapshots_dict: dict[int, dict[str, Any]] = {}
    cores_dict: dict[int, int] = {}
    weights_dict: dict[str, Any] = {}
    modulations_used_dict: dict[str, Any] = {}
    bandwidth_blocking_dict: dict[str | float, int] = {}
    link_usage_dict: dict[str, dict[str, Any]] = {}
    demand_realization_ratio: dict[str, Any] = {}
    frag_dict: dict[str, Any] = {}
    lp_bw_utilization_dict: dict[str, Any] = {}
    sim_lp_utilization_list: list[float] = []
    block_reasons_dict: dict[str, int | float | None]
    # ... many more lists
```

**Resolution**: StatsProps is a **statistics aggregation container**, not network state. It should NOT be part of NetworkState. Document in shared context as "out of scope for NetworkState".

### 1.2 SimulationEngine Internal State

**Location**: `fusion/core/simulation.py:200-262`

**State Managed**:
```python
class SimulationEngine:
    network_spectrum_dict: dict  # Duplicates sdn_props.network_spectrum_dict
    reqs_dict: dict | None       # Request queue by arrival time
    reqs_status_dict: dict       # Tracked routed requests for release
    iteration: int               # Current simulation iteration
    topology: nx.Graph           # Duplicates sdn_props.topology
    grooming_stats: dict         # Aggregated grooming outcomes
```

**Analysis**:
- `network_spectrum_dict` and `topology`: These are **copies** of sdn_props state. NetworkState centralizes this.
- `reqs_dict`: Request generation, not network state. Out of scope.
- `reqs_status_dict`: **Important** - Maps request_id to allocation details for release handling. This is **request-level state**, not network state, but depends on NetworkState lightpath data.
- `grooming_stats`: Statistics aggregation, out of scope for NetworkState.

**Resolution**: Document that SimulationEngine maintains request tracking state (`reqs_status_dict`) separately from network state. NetworkState handles spectrum and lightpaths; request tracking remains in SimulationEngine.

### 1.3 Per-Module Property Objects

**Location**: `fusion/core/properties.py`

**Property Objects**:
| Class | Purpose | Mutable Per | NetworkState Impact |
|-------|---------|-------------|---------------------|
| `RoutingProps` | Routing results | Per routing call | Output only, no state impact |
| `SpectrumProps` | Spectrum search results | Per spectrum call | Output only, no state impact |
| `SNRProps` | SNR parameters | Mostly static | Configuration, not state |
| `GroomingProps` | Grooming configuration | Static | Configuration, not state |

**Analysis**: These are **intermediate result containers**, not authoritative state. They hold temporary values during pipeline execution and should be replaced by Phase 1 result objects.

**Resolution**: Explicitly document that these property objects are NOT state sources but intermediate containers. Phase 2 adapters convert their outputs to Phase 1 result objects.

### 1.4 SDNProps Additional State

**Location**: `fusion/core/properties.py:321-546`

**Undocumented State Fields**:
```python
# Request tracking for failure handling
allocated_requests: dict[int, dict[str, Any]] = {}

# Transponder tracking
transponder_usage_dict: dict | None = None

# Protection state
primary_path: list[int] | None = None
backup_path: list[int] | None = None
is_protected: bool = False
active_path: str = "primary"

# Per-request tracking lists (reset per request)
bandwidth_list: list[float] = []
modulation_list: list[str] = []
core_list: list[int] = []
band_list: list[str] = []
# ... more lists
```

**Resolution**:
- `allocated_requests`: Request-to-allocation mapping for failure handling. Belongs in **request tracking**, not NetworkState.
- `transponder_usage_dict`: Physical layer tracking. Out of scope for Phase 2.
- Protection state: Per-request, transient state during allocation. Not persisted network state.
- Per-request lists: Temporary allocation tracking, reset per request. Not network state.

---

## Section 2: Missing Write Path Details (P2.2 Gaps)

### 2.1 Incomplete lightpath_status_dict Entry Fields

**Current Documentation**: P2.2.shared_context lists basic fields but misses several.

**Complete Field List**:
```python
{
    lightpath_id: {
        # Documented fields
        "path": list[str],
        "lightpath_bandwidth": float,
        "remaining_bandwidth": float,
        "band": str,
        "core": int,
        "start_slot": int,
        "end_slot": int,
        "modulation": str,  # Note: Sometimes "mod_format"
        "requests_dict": dict[int, float],
        "time_bw_usage": dict[float, float],
        "is_degraded": bool,

        # Missing from documentation
        "path_weight": float,    # Path distance in km
        "snr_cost": float | None,  # SNR value at allocation
        "xt_cost": float | None,   # Crosstalk cost
        "mod_format": str,       # Alternate key for modulation
    }
}
```

**Resolution**: Update P2.2 shared context with complete field list.

### 2.2 Guard Band Allocation Details

**Current Documentation**: Mentioned but not fully specified.

**Complete Specification**:
```python
# Guard band values use NEGATIVE lightpath_id
# Data slots: cores_matrix[band][core][start:end] = lightpath_id (positive)
# Guard slots: cores_matrix[band][core][end:end+guard] = -lightpath_id (negative)

# Example: lightpath_id=5 with 8 data slots, 1 guard slot
# cores_matrix["c"][0][10:18] = 5    # Data
# cores_matrix["c"][0][18] = -5       # Guard band

# Release must clear both:
# np.where(core_array == lightpath_id)  -> Data slots
# np.where(core_array == -lightpath_id) -> Guard slots
```

**Resolution**: Add guard band convention to P2.2.b write method design.

### 2.3 Protected Lightpath Allocation

**Current Documentation**: Mentions backup_path but incomplete.

**Complete Specification**:
```python
def create_protected_lightpath(
    self,
    primary_path: list[str],
    backup_path: list[str],
    start_slot: int,
    end_slot: int,
    core: int,
    band: str,
    modulation: str,
    bandwidth_gbps: int,
    path_weight_km: float,
    guard_slots: int = 0,
) -> Lightpath:
    """
    Create 1+1 protected lightpath.

    Allocates spectrum on BOTH paths:
    1. Primary path: all links marked with lightpath_id
    2. Backup path: all links marked with lightpath_id

    Single Lightpath object returned with:
    - path = primary_path
    - backup_path = backup_path
    - is_protected = True

    On release, BOTH paths' spectrum is freed.
    """
```

**Resolution**: Add protected lightpath creation spec to P2.2.b.

### 2.4 Usage Count Tracking

**Current Documentation**: Mentioned but semantics unclear.

**Complete Specification**:
```python
# usage_count increments for EACH link traversed during allocation
# NOT per lightpath, but per link-lightpath pair

# Allocation on path [A, B, C]:
# network_spectrum_dict[(A, B)]["usage_count"] += 1
# network_spectrum_dict[(B, A)]["usage_count"] += 1  # Bidirectional
# network_spectrum_dict[(B, C)]["usage_count"] += 1
# network_spectrum_dict[(C, B)]["usage_count"] += 1  # Bidirectional

# Note: Both directions point to same dict, so increment is seen in both
# Actually: Since both (u,v) and (v,u) reference same dict object,
# the single += 1 affects both lookups
```

**Resolution**: Clarify usage_count semantics in P2.2.

---

## Section 3: Pipeline Protocol Gaps (P2.3)

### 3.1 SlicingPipeline Incomplete

**Current Documentation**: Protocol outline only.

**Complete Protocol**:
```python
class SlicingPipeline(Protocol):
    """Pipeline for splitting requests across multiple lightpaths."""

    def try_slice(
        self,
        request: Request,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        max_slices: int | None = None,
        spectrum_pipeline: SpectrumPipeline | None = None,
        snr_pipeline: SNRPipeline | None = None,
    ) -> SlicingResult:
        """
        Attempt to slice request across multiple lightpaths.

        Args:
            request: Request to slice
            path: Path to allocate on
            modulation: Base modulation format
            bandwidth_gbps: Total bandwidth to allocate
            network_state: Current network state
            max_slices: Maximum number of slices allowed
            spectrum_pipeline: Pipeline for finding spectrum (optional, for delegation)
            snr_pipeline: Pipeline for SNR validation (optional)

        Returns:
            SlicingResult with:
            - success: bool
            - num_slices: int
            - lightpath_ids: list[int]
            - slice_bandwidths: list[int]
        """
        ...

    def rollback_slices(
        self,
        lightpath_ids: list[int],
        network_state: NetworkState,
    ) -> None:
        """
        Rollback all slices on failure.

        Called when partial slice allocation fails and all
        created slices must be released.
        """
        ...
```

**Resolution**: Add complete SlicingPipeline to P2.3.d.

### 3.2 GroomingPipeline Forced Path Handling

**Current Documentation**: Mentions forced_path but incomplete.

**Complete Specification**:
```python
class GroomingResult:
    """Result of grooming attempt."""
    fully_groomed: bool
    partially_groomed: bool
    lightpath_ids: list[int]  # Lightpaths used for grooming
    bandwidth_groomed: int     # Total bandwidth groomed
    remaining_bandwidth: int   # Bandwidth still needing allocation
    forced_path: list[str] | None  # Path constraint for remaining allocation
    forced_modulations: list[str] | None  # Modulation constraint

    # When partially_groomed=True, caller must:
    # 1. Allocate remaining_bandwidth on forced_path
    # 2. Use forced_modulations if specified
    # 3. On failure, rollback grooming via rollback_groom()
```

**Resolution**: Add GroomingResult fields to P2.3.

### 3.3 SNR Recheck Protocol

**Current Documentation**: Basic validate() only.

**Complete Protocol**:
```python
class SNRPipeline(Protocol):
    def validate(
        self,
        lightpath: Lightpath,
        network_state: NetworkState,
    ) -> SNRResult:
        """Check if lightpath meets SNR threshold."""
        ...

    def recheck_affected(
        self,
        new_lightpath_id: int,
        network_state: NetworkState,
    ) -> SNRRecheckResult:
        """
        Recheck SNR of existing lightpaths after new allocation.

        Some existing lightpaths may be degraded by the new
        allocation's interference. This method identifies them.

        Returns:
            SNRRecheckResult with:
            - all_pass: bool
            - degraded_lightpath_ids: list[int]
            - violations: dict[int, float]  # lightpath_id -> SNR shortfall
        """
        ...
```

**Resolution**: Add recheck protocol to P2.3.

---

## Section 4: Legacy Adapter Gaps (P2.4)

### 4.1 SlicingAdapter Not Enumerated

**Current Documentation**: Lists only four adapters (Routing, Spectrum, Grooming, SNR).

**Analysis**: Slicing is handled by `LightPathSlicingManager` which is initialized and called by `SDNController`. It's not a standalone pipeline in legacy code.

**Resolution**: Document that slicing is handled differently:
- Legacy: `LightPathSlicingManager` in SDNController
- V4: `SlicingPipeline` protocol with `SlicingAdapter` wrapper

### 4.2 Event Loop Context

**Current Documentation**: Adapters wrap individual method calls.

**Missing Context**: Legacy code relies on `sdn_props` being mutated between calls within a single request's event handling. Adapters must handle this stateless pattern:

```python
class RoutingAdapter(RoutingPipeline):
    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        # Create fresh props each call - no state carryover
        route_props = RoutingProps()

        # Create minimal sdn_props proxy
        class SDNPropsProxy:
            def __init__(self, ns: NetworkState, src: str, dst: str, bw: int):
                self.topology = ns.topology
                self.source = src
                self.destination = dst
                self.bandwidth = bw
                # Read-only spectrum access
                self.network_spectrum_dict = ns.network_spectrum_dict

        sdn_props = SDNPropsProxy(network_state, source, destination, bandwidth_gbps)

        # Call legacy
        routing = Routing(
            engine_props=self._config.to_engine_props(),
            sdn_props=sdn_props,
            route_props=route_props,
        )
        routing.get_route()

        # Convert to result
        return RouteResult(
            paths=route_props.paths_matrix,
            modulations=route_props.modulation_formats_matrix,
            weights_km=route_props.weights_list,
        )
```

**Resolution**: Document stateless adapter pattern in P2.4.a.

### 4.3 SNRAdapter Complexity

**Current Documentation**: Basic wrapper.

**Missing Context**: SNR calculations read spectrum state and may write back degradation flags. Adapter must:
1. Read spectrum via NetworkState
2. Not mutate NetworkState (read-only SNR check)
3. Return result indicating pass/fail and degradation status

```python
class SNRAdapter(SNRPipeline):
    def validate(
        self,
        lightpath: Lightpath,
        network_state: NetworkState,
    ) -> SNRResult:
        # Create spectrum_props from lightpath
        spectrum_props = SpectrumProps()
        spectrum_props.start_slot = lightpath.start_slot
        spectrum_props.end_slot = lightpath.end_slot
        spectrum_props.core_number = lightpath.core
        spectrum_props.current_band = lightpath.band
        spectrum_props.path_list = lightpath.path

        # Create SNR measurer
        snr_obj = SnrMeasurements(
            engine_props_dict=self._config.to_engine_props(),
            sdn_props=self._create_sdn_proxy(network_state),
            spectrum_props=spectrum_props,
            route_props=RoutingProps(),  # Empty, not needed
        )

        # Calculate SNR
        passes, snr_db = snr_obj.calculate_snr(
            path=lightpath.path,
            modulation=lightpath.modulation,
            start_slot=lightpath.start_slot,
            end_slot=lightpath.end_slot,
            core=lightpath.core,
            band=lightpath.band,
        )

        return SNRResult(
            passes=passes,
            snr_db=snr_db,
            threshold_db=self._get_threshold(lightpath.modulation),
        )
```

**Resolution**: Document SNR adapter complexity in P2.4.d.

---

## Section 5: Authoritative State Mapping

### Complete State Authority Table

| State | Legacy Location | NetworkState Authority | Migration Notes |
|-------|-----------------|----------------------|-----------------|
| Spectrum arrays | `sdn_props.network_spectrum_dict[link]["cores_matrix"]` | `NetworkState._spectrum[link].cores_matrix` | Direct mapping |
| Link usage | `sdn_props.network_spectrum_dict[link]["usage_count"]` | `NetworkState._spectrum[link].usage_count` | Direct mapping |
| Link throughput | `sdn_props.network_spectrum_dict[link]["throughput"]` | `NetworkState._spectrum[link].throughput` | Direct mapping |
| Active lightpaths | `sdn_props.lightpath_status_dict[key][id]` | `NetworkState._lightpaths[id]` | Key structure changes |
| Lightpath ID counter | `sdn_props.lightpath_counter` | `NetworkState._next_lightpath_id` | Direct mapping |
| Topology | `sdn_props.topology` / `engine_props["topology"]` | `NetworkState._topology` | Reference shared |
| Request tracking | `sdn_props.allocated_requests` | SimulationEngine only | Not in NetworkState |
| Transponder tracking | `sdn_props.transponder_usage_dict` | Out of scope | Future phase |
| Statistics | `stats_props.*` | Out of scope | Separate component |

### State NOT in NetworkState (By Design)

| State | Reason | Owner |
|-------|--------|-------|
| Request queue (`reqs_dict`) | Request lifecycle, not network | SimulationEngine |
| Request status (`reqs_status_dict`) | Request tracking for release | SimulationEngine |
| Statistics (`stats_props`) | Aggregation, not network state | SimStats |
| Grooming stats | Aggregation | SimulationEngine |
| Per-request lists in SDNProps | Temporary, reset per request | SDNController |
| Property objects (RouteProps, etc.) | Intermediate results | Pipelines |

---

## Section 6: Action Items

### P2.1 Updates Required

1. Add `P2.1.shared_context_state_authority.md` documenting complete state mapping
2. Update `P2.1.a_context_extraction` to reference this gap analysis
3. Clarify that stats_props and request tracking are NOT in NetworkState

### P2.2 Updates Required

1. Update `P2.2.shared_context` with complete lightpath entry fields
2. Add guard band convention to `P2.2.b_design_write_methods`
3. Add protected lightpath spec to write methods
4. Document usage_count semantics

### P2.3 Updates Required

1. Complete `P2.3.d_design_grooming_snr_slicing_protocols` with:
   - Full SlicingPipeline protocol
   - GroomingResult fields
   - SNR recheck protocol
2. Add rollback contracts to all protocols

### P2.4 Updates Required

1. Add SlicingAdapter to scope
2. Document stateless adapter pattern in `P2.4.a`
3. Add SNR adapter complexity notes
4. Document per-call state isolation requirements

---

## Verification Checklist

After completing gap resolutions:

- [ ] All legacy write points have corresponding NetworkState methods
- [ ] All state sources documented with authority assignment
- [ ] Pipeline protocols complete with full method signatures
- [ ] Adapters enumerated for all legacy components
- [ ] Rollback/failure paths documented for all mutating operations
- [ ] Guard band handling fully specified
- [ ] Protection (1+1) handling fully specified
- [ ] State isolation requirements documented for adapters
