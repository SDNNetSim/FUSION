# Task ID: P5.4.d - Design Protected Spectrum Allocation

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the spectrum allocation strategy for 1+1 dedicated protection, where the same spectrum slots must be allocated on both primary and backup paths simultaneously.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.b_design_protection_pipeline.md`
- `fusion/core/spectrum_assignment.py`

---

## Outputs

### 1. 1+1 Dedicated Protection Spectrum Strategy

In 1+1 dedicated protection, the **same spectrum slots** are allocated on both primary and backup paths:

```
Primary Path (A -> B -> D):
  Link A-B: [=====] slots 10-15
  Link B-D: [=====] slots 10-15

Backup Path (A -> C -> D):
  Link A-C: [=====] slots 10-15
  Link C-D: [=====] slots 10-15

Both paths use slots 10-15 simultaneously.
```

### 2. ProtectedSpectrumAllocator Class Design

```python
"""
Protected spectrum allocation for 1+1 dedicated protection.

This module provides spectrum allocation that reserves the same slots
on both primary and backup paths for 1+1 dedicated protection.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class ProtectedAllocationResult:
    """
    Result of protected spectrum allocation.

    Attributes:
        success: Whether allocation succeeded on both paths
        start_slot: Starting slot index
        end_slot: Ending slot index (exclusive)
        slots_used: Number of slots allocated
        primary_path: Primary path allocated
        backup_path: Backup path allocated
        failure_reason: Reason for failure if not successful
    """

    success: bool
    start_slot: int | None = None
    end_slot: int | None = None
    slots_used: int | None = None
    primary_path: list[str] | None = None
    backup_path: list[str] | None = None
    failure_reason: str | None = None


class ProtectedSpectrumAllocator:
    """
    Allocate spectrum for 1+1 dedicated protection.

    For 1+1 protection, the same spectrum slots must be available
    on ALL links of BOTH primary and backup paths. This allocator
    finds a contiguous block that satisfies this constraint.

    Allocation Strategy:
    1. Compute combined link set (primary + backup)
    2. Find slots free on ALL links
    3. Apply first-fit to find contiguous block
    4. Mark slots as used on both paths

    Attributes:
        guard_band: Guard band slots between allocations

    Example:
        >>> allocator = ProtectedSpectrumAllocator(guard_band=1)
        >>> result = allocator.allocate(
        ...     primary_path=["A", "B", "D"],
        ...     backup_path=["A", "C", "D"],
        ...     slots_needed=6,
        ...     network_state=network_state,
        ... )
        >>> if result.success:
        ...     print(f"Allocated slots {result.start_slot}-{result.end_slot}")
    """

    def __init__(self, guard_band: int = 1) -> None:
        """
        Initialize protected spectrum allocator.

        Args:
            guard_band: Number of guard band slots between allocations
        """
        self.guard_band = guard_band

    def allocate(
        self,
        primary_path: list[str],
        backup_path: list[str],
        slots_needed: int,
        network_state: NetworkState,
    ) -> ProtectedAllocationResult:
        """
        Allocate spectrum on both primary and backup paths.

        Finds a contiguous spectrum block that is available on all
        links of both paths, then marks it as allocated.

        Args:
            primary_path: Primary path node sequence
            backup_path: Backup path node sequence
            slots_needed: Number of contiguous slots required
            network_state: Current network state

        Returns:
            ProtectedAllocationResult with allocation details

        Example:
            >>> result = allocator.allocate(
            ...     ["A", "B", "D"], ["A", "C", "D"], 6, state
            ... )
        """
        # Get all links from both paths
        primary_links = self._path_to_links(primary_path)
        backup_links = self._path_to_links(backup_path)
        all_links = primary_links | backup_links

        # Find spectrum availability intersection
        available_mask = self._get_combined_availability(all_links, network_state)

        if available_mask is None:
            return ProtectedAllocationResult(
                success=False,
                failure_reason="Could not get spectrum availability",
            )

        # Find contiguous block using first-fit
        start_slot = self._find_first_fit(available_mask, slots_needed)

        if start_slot is None:
            return ProtectedAllocationResult(
                success=False,
                primary_path=primary_path,
                backup_path=backup_path,
                failure_reason="No contiguous spectrum block available on both paths",
            )

        end_slot = start_slot + slots_needed

        # Mark slots as allocated on both paths
        self._mark_allocated(primary_links, start_slot, end_slot, network_state)
        self._mark_allocated(backup_links, start_slot, end_slot, network_state)

        return ProtectedAllocationResult(
            success=True,
            start_slot=start_slot,
            end_slot=end_slot,
            slots_used=slots_needed,
            primary_path=primary_path,
            backup_path=backup_path,
        )

    def check_availability(
        self,
        primary_path: list[str],
        backup_path: list[str],
        slots_needed: int,
        network_state: NetworkState,
    ) -> bool:
        """
        Check if allocation is possible without actually allocating.

        Args:
            primary_path: Primary path
            backup_path: Backup path
            slots_needed: Slots required
            network_state: Current state

        Returns:
            True if allocation would succeed
        """
        all_links = (
            self._path_to_links(primary_path) |
            self._path_to_links(backup_path)
        )

        available_mask = self._get_combined_availability(all_links, network_state)

        if available_mask is None:
            return False

        start_slot = self._find_first_fit(available_mask, slots_needed)
        return start_slot is not None

    def deallocate(
        self,
        primary_path: list[str],
        backup_path: list[str],
        start_slot: int,
        end_slot: int,
        network_state: NetworkState,
    ) -> None:
        """
        Deallocate spectrum from both paths.

        Args:
            primary_path: Primary path
            backup_path: Backup path
            start_slot: Starting slot
            end_slot: Ending slot
            network_state: Current state
        """
        primary_links = self._path_to_links(primary_path)
        backup_links = self._path_to_links(backup_path)

        self._mark_free(primary_links, start_slot, end_slot, network_state)
        self._mark_free(backup_links, start_slot, end_slot, network_state)

    def _path_to_links(self, path: list[str]) -> set[tuple[str, str]]:
        """Convert path to set of links."""
        links = set()
        for i in range(len(path) - 1):
            # Normalize link direction for consistency
            link = tuple(sorted([path[i], path[i + 1]]))
            links.add(link)
        return links

    def _get_combined_availability(
        self,
        links: set[tuple[str, str]],
        network_state: NetworkState,
    ) -> np.ndarray | None:
        """
        Get spectrum availability that is free on ALL links.

        Args:
            links: Set of links to check
            network_state: Current state

        Returns:
            Boolean mask where True = slot is free on all links
        """
        combined_mask = None

        for link in links:
            link_availability = network_state.get_link_spectrum(link)

            if link_availability is None:
                logger.warning(f"No spectrum data for link {link}")
                return None

            # Convert to boolean mask (True = free)
            free_mask = link_availability == 0

            if combined_mask is None:
                combined_mask = free_mask
            else:
                # AND operation: slot must be free on ALL links
                combined_mask = combined_mask & free_mask

        return combined_mask

    def _find_first_fit(
        self,
        available_mask: np.ndarray,
        slots_needed: int,
    ) -> int | None:
        """
        Find first contiguous block of free slots.

        Args:
            available_mask: Boolean mask of available slots
            slots_needed: Number of contiguous slots required

        Returns:
            Starting slot index, or None if not found
        """
        total_slots = len(available_mask)
        required = slots_needed + self.guard_band

        consecutive = 0
        start = None

        for i in range(total_slots):
            if available_mask[i]:
                if start is None:
                    start = i
                consecutive += 1

                if consecutive >= required:
                    return start
            else:
                consecutive = 0
                start = None

        return None

    def _mark_allocated(
        self,
        links: set[tuple[str, str]],
        start_slot: int,
        end_slot: int,
        network_state: NetworkState,
    ) -> None:
        """Mark slots as allocated on all links."""
        for link in links:
            network_state.allocate_spectrum(link, start_slot, end_slot)

    def _mark_free(
        self,
        links: set[tuple[str, str]],
        start_slot: int,
        end_slot: int,
        network_state: NetworkState,
    ) -> None:
        """Mark slots as free on all links."""
        for link in links:
            network_state.deallocate_spectrum(link, start_slot, end_slot)


class ProtectedSpectrumCalculator:
    """
    Calculate spectrum requirements for protected lightpaths.

    Computes slots needed based on bandwidth, modulation format,
    and slot width for protected allocation.
    """

    def __init__(
        self,
        slot_width_ghz: float = 12.5,
        guard_band_slots: int = 1,
    ) -> None:
        """
        Initialize spectrum calculator.

        Args:
            slot_width_ghz: Width of each frequency slot in GHz
            guard_band_slots: Guard band between allocations
        """
        self.slot_width_ghz = slot_width_ghz
        self.guard_band_slots = guard_band_slots

    def calculate_slots_needed(
        self,
        bandwidth_gbps: int,
        modulation: str,
        modulation_formats: dict[str, dict],
    ) -> int:
        """
        Calculate slots needed for given bandwidth and modulation.

        Args:
            bandwidth_gbps: Required bandwidth in Gbps
            modulation: Modulation format name
            modulation_formats: Modulation format specifications

        Returns:
            Number of slots required (including guard band)
        """
        mod_info = modulation_formats.get(modulation, {})
        bits_per_symbol = mod_info.get("bits_per_symbol", 2)  # Default QPSK

        # Calculate required bandwidth in GHz
        # bandwidth_ghz = bandwidth_gbps / bits_per_symbol
        bandwidth_ghz = bandwidth_gbps / bits_per_symbol

        # Calculate slots (ceiling)
        data_slots = int(np.ceil(bandwidth_ghz / self.slot_width_ghz))

        return data_slots + self.guard_band_slots

    def calculate_for_both_paths(
        self,
        bandwidth_gbps: int,
        primary_modulation: str,
        backup_modulation: str,
        modulation_formats: dict[str, dict],
    ) -> int:
        """
        Calculate slots needed considering both path modulations.

        For 1+1 protection with same slots on both paths, we need
        to use the modulation that requires MORE slots (worst case).

        Args:
            bandwidth_gbps: Required bandwidth
            primary_modulation: Primary path modulation
            backup_modulation: Backup path modulation
            modulation_formats: Modulation specifications

        Returns:
            Slots needed (max of primary and backup requirements)
        """
        primary_slots = self.calculate_slots_needed(
            bandwidth_gbps, primary_modulation, modulation_formats
        )
        backup_slots = self.calculate_slots_needed(
            bandwidth_gbps, backup_modulation, modulation_formats
        )

        return max(primary_slots, backup_slots)
```

### 3. Allocation Strategy Comparison

| Strategy | Description | Use Case |
|----------|-------------|----------|
| **First-Fit** | Allocate first available block | Default, good fragmentation |
| **Best-Fit** | Allocate smallest fitting block | Minimize waste |
| **Random-Fit** | Random among fitting blocks | Load balancing |

For 1+1 protection, we use **First-Fit** on the intersection of available slots.

### 4. Integration with ProtectionPipeline

```python
class ProtectionPipeline:
    def __init__(self, config: ProtectionConfig) -> None:
        self.config = config
        self._spectrum_allocator = ProtectedSpectrumAllocator(
            guard_band=config.guard_band_slots
        )

    def allocate_protected_lightpath(
        self,
        primary_path: list[str],
        backup_path: list[str],
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> ProtectedAllocationResult:
        """Allocate spectrum for protected lightpath."""
        # Calculate slots needed
        slots = self._calculate_slots(bandwidth_gbps, modulation)

        # Allocate on both paths
        return self._spectrum_allocator.allocate(
            primary_path, backup_path, slots, network_state
        )
```

### 5. Spectrum State Updates

```python
# NetworkState interface for spectrum management
class NetworkState:
    def get_link_spectrum(self, link: tuple[str, str]) -> np.ndarray:
        """Get spectrum state for link (0=free, 1=allocated)."""
        ...

    def allocate_spectrum(
        self,
        link: tuple[str, str],
        start: int,
        end: int,
    ) -> None:
        """Mark slots as allocated on link."""
        ...

    def deallocate_spectrum(
        self,
        link: tuple[str, str],
        start: int,
        end: int,
    ) -> None:
        """Mark slots as free on link."""
        ...
```

---

## Verification

- [ ] Same slots allocated on both paths
- [ ] Allocation fails if any link lacks capacity
- [ ] First-fit finds earliest contiguous block
- [ ] Guard band applied correctly
- [ ] Deallocation releases both paths
- [ ] Slots calculator handles different modulations

---

## Test Cases to Implement

```python
class TestProtectedSpectrumAllocator:
    """Tests for ProtectedSpectrumAllocator."""

    def test_allocate_both_paths(self) -> None:
        """Should allocate same slots on both paths."""
        allocator = ProtectedSpectrumAllocator()
        result = allocator.allocate(
            primary_path=["A", "B", "D"],
            backup_path=["A", "C", "D"],
            slots_needed=6,
            network_state=state,
        )

        assert result.success
        assert result.start_slot is not None
        # Verify slots used on both paths
        assert state.is_allocated("A", "B", result.start_slot)
        assert state.is_allocated("A", "C", result.start_slot)

    def test_fail_when_one_path_full(self) -> None:
        """Should fail if backup path has no capacity."""
        # Fill backup path
        state.fill_link(("A", "C"))

        allocator = ProtectedSpectrumAllocator()
        result = allocator.allocate(
            primary_path=["A", "B", "D"],
            backup_path=["A", "C", "D"],
            slots_needed=6,
            network_state=state,
        )

        assert not result.success

    def test_check_availability(self) -> None:
        """Should check without allocating."""
        allocator = ProtectedSpectrumAllocator()
        available = allocator.check_availability(
            ["A", "B", "D"], ["A", "C", "D"], 6, state
        )

        assert available
        # State unchanged
        assert state.get_link_spectrum(("A", "B")).sum() == 0

    def test_deallocate(self) -> None:
        """Should free slots on both paths."""
        allocator = ProtectedSpectrumAllocator()
        result = allocator.allocate(
            ["A", "B", "D"], ["A", "C", "D"], 6, state
        )

        allocator.deallocate(
            ["A", "B", "D"], ["A", "C", "D"],
            result.start_slot, result.end_slot, state
        )

        # Both paths should be free
        assert state.get_link_spectrum(("A", "B"))[result.start_slot] == 0
        assert state.get_link_spectrum(("A", "C"))[result.start_slot] == 0
```

---

## Next Task

Proceed to **P5.4.e** to design the failure handling mechanism.
