# Task ID: P5.4.h - Verification Plan for Protection Pipeline

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** verification-plan

---

## Purpose

Define the verification plan for the ProtectionPipeline, including unit tests, integration tests, and acceptance criteria.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.g_implement_protection_pipeline.md`

---

## Outputs

### 1. Test File Structure

```
fusion/pipelines/tests/
├── __init__.py
├── test_protection_pipeline.py
├── test_disjoint_path_finder.py
├── test_protected_spectrum.py
├── test_failure_handler.py
└── conftest.py
```

### 2. Test Fixtures (conftest.py)

```python
"""
Test fixtures for protection pipeline tests.
"""

import pytest
import networkx as nx
import numpy as np
from dataclasses import dataclass
from typing import Any


@dataclass
class MockLightpath:
    """Mock Lightpath for testing."""

    lightpath_id: str
    source: str
    destination: str
    path: list[str]
    spectrum_start: int
    spectrum_end: int
    modulation: str
    bandwidth_gbps: int
    created_at: float
    backup_path: list[str] | None = None
    is_protected: bool = False
    active_path: str = "primary"

    @property
    def current_path(self) -> list[str]:
        if self.is_protected and self.active_path == "backup":
            return self.backup_path
        return self.path


class MockNetworkState:
    """Mock NetworkState for testing."""

    def __init__(self, topology: nx.Graph) -> None:
        self.topology = topology
        self._spectrum: dict[tuple[str, str], np.ndarray] = {}
        self._lightpaths: dict[str, MockLightpath] = {}
        self.modulation_formats = {
            "QPSK": {"max_length": 5000},
            "8QAM": {"max_length": 2000},
            "16QAM": {"max_length": 1000},
        }

        # Initialize spectrum for all edges
        for u, v in topology.edges():
            key = tuple(sorted([u, v]))
            self._spectrum[key] = np.zeros(100, dtype=int)

    def get_link_spectrum(self, link: tuple[str, str]) -> np.ndarray | None:
        key = tuple(sorted(link))
        return self._spectrum.get(key)

    def allocate_spectrum(
        self,
        link: tuple[str, str],
        start: int,
        end: int,
    ) -> None:
        key = tuple(sorted(link))
        if key in self._spectrum:
            self._spectrum[key][start:end] = 1

    def deallocate_spectrum(
        self,
        link: tuple[str, str],
        start: int,
        end: int,
    ) -> None:
        key = tuple(sorted(link))
        if key in self._spectrum:
            self._spectrum[key][start:end] = 0

    @property
    def active_lightpaths(self) -> list[MockLightpath]:
        return list(self._lightpaths.values())

    def add_lightpath(self, lightpath: MockLightpath) -> None:
        self._lightpaths[lightpath.lightpath_id] = lightpath


@pytest.fixture
def diamond_topology() -> nx.Graph:
    """
    Diamond topology for disjoint path testing.

        B
       / \
      A   D
       \ /
        C
    """
    G = nx.Graph()
    G.add_edges_from([
        ("A", "B", {"weight": 100}),
        ("B", "D", {"weight": 100}),
        ("A", "C", {"weight": 100}),
        ("C", "D", {"weight": 100}),
    ])
    return G


@pytest.fixture
def linear_topology() -> nx.Graph:
    """Linear topology (no disjoint paths)."""
    G = nx.Graph()
    G.add_edges_from([
        ("A", "B", {"weight": 100}),
        ("B", "C", {"weight": 100}),
        ("C", "D", {"weight": 100}),
    ])
    return G


@pytest.fixture
def complex_topology() -> nx.Graph:
    """
    More complex topology with multiple disjoint paths.

        B---E
       /|   |\
      A |   | D
       \|   |/
        C---F
    """
    G = nx.Graph()
    G.add_edges_from([
        ("A", "B", {"weight": 100}),
        ("A", "C", {"weight": 100}),
        ("B", "C", {"weight": 100}),
        ("B", "E", {"weight": 100}),
        ("C", "F", {"weight": 100}),
        ("E", "F", {"weight": 100}),
        ("E", "D", {"weight": 100}),
        ("F", "D", {"weight": 100}),
    ])
    return G


@pytest.fixture
def diamond_state(diamond_topology: nx.Graph) -> MockNetworkState:
    """NetworkState with diamond topology."""
    return MockNetworkState(diamond_topology)


@pytest.fixture
def linear_state(linear_topology: nx.Graph) -> MockNetworkState:
    """NetworkState with linear topology."""
    return MockNetworkState(linear_topology)


@pytest.fixture
def complex_state(complex_topology: nx.Graph) -> MockNetworkState:
    """NetworkState with complex topology."""
    return MockNetworkState(complex_topology)


@pytest.fixture
def protected_lightpath() -> MockLightpath:
    """Protected lightpath fixture."""
    return MockLightpath(
        lightpath_id="lp-001",
        source="A",
        destination="D",
        path=["A", "B", "D"],
        spectrum_start=10,
        spectrum_end=16,
        modulation="QPSK",
        bandwidth_gbps=100,
        created_at=0.0,
        backup_path=["A", "C", "D"],
        is_protected=True,
        active_path="primary",
    )


@pytest.fixture
def unprotected_lightpath() -> MockLightpath:
    """Unprotected lightpath fixture."""
    return MockLightpath(
        lightpath_id="lp-002",
        source="A",
        destination="D",
        path=["A", "B", "D"],
        spectrum_start=20,
        spectrum_end=26,
        modulation="QPSK",
        bandwidth_gbps=100,
        created_at=0.0,
    )
```

### 3. DisjointPathFinder Tests

```python
"""Tests for DisjointPathFinder."""

import pytest

from fusion.pipelines.protection_pipeline import (
    DisjointPathFinder,
    DisjointnessType,
)


class TestDisjointPathFinder:
    """Test suite for DisjointPathFinder."""

    def test_find_edge_disjoint_diamond(self, diamond_topology) -> None:
        """Should find 2 edge-disjoint paths in diamond topology."""
        finder = DisjointPathFinder(DisjointnessType.LINK)
        paths = finder.find_all_disjoint_paths(diamond_topology, "A", "D")

        assert len(paths) == 2
        assert finder.verify_disjointness(paths[0], paths[1])

    def test_find_node_disjoint_diamond(self, diamond_topology) -> None:
        """Should find 2 node-disjoint paths in diamond topology."""
        finder = DisjointPathFinder(DisjointnessType.NODE)
        paths = finder.find_all_disjoint_paths(diamond_topology, "A", "D")

        assert len(paths) == 2
        # Verify no shared intermediate nodes
        intermediate1 = set(paths[0][1:-1])
        intermediate2 = set(paths[1][1:-1])
        assert intermediate1.isdisjoint(intermediate2)

    def test_linear_no_disjoint_paths(self, linear_topology) -> None:
        """Should return fewer than 2 paths for linear topology."""
        finder = DisjointPathFinder(DisjointnessType.LINK)
        paths = finder.find_all_disjoint_paths(linear_topology, "A", "D")

        assert len(paths) < 2

    def test_find_disjoint_pair(self, diamond_topology) -> None:
        """Should find a single disjoint pair."""
        finder = DisjointPathFinder(DisjointnessType.LINK)
        primary, backup = finder.find_disjoint_pair(diamond_topology, "A", "D")

        assert primary is not None
        assert backup is not None
        assert primary != backup
        assert finder.verify_disjointness(primary, backup)

    def test_verify_link_disjoint_true(self) -> None:
        """Should return True for link-disjoint paths."""
        finder = DisjointPathFinder(DisjointnessType.LINK)

        path1 = ["A", "B", "D"]
        path2 = ["A", "C", "D"]

        assert finder.verify_disjointness(path1, path2)

    def test_verify_link_disjoint_false(self) -> None:
        """Should return False for non-disjoint paths."""
        finder = DisjointPathFinder(DisjointnessType.LINK)

        path1 = ["A", "B", "D"]
        path2 = ["A", "B", "C", "D"]  # Shares A-B link

        assert not finder.verify_disjointness(path1, path2)

    def test_verify_node_disjoint_true(self) -> None:
        """Should return True for node-disjoint paths."""
        finder = DisjointPathFinder(DisjointnessType.NODE)

        path1 = ["A", "B", "D"]
        path2 = ["A", "C", "D"]

        assert finder.verify_disjointness(path1, path2)

    def test_verify_node_disjoint_false(self) -> None:
        """Should return False when sharing intermediate node."""
        finder = DisjointPathFinder(DisjointnessType.NODE)

        path1 = ["A", "B", "C", "D"]
        path2 = ["A", "E", "C", "D"]  # Shares C

        assert not finder.verify_disjointness(path1, path2)

    def test_no_path_returns_empty(self, diamond_topology) -> None:
        """Should return empty list when no path exists."""
        finder = DisjointPathFinder(DisjointnessType.LINK)
        paths = finder.find_all_disjoint_paths(diamond_topology, "A", "X")

        assert paths == []
```

### 4. ProtectedSpectrumAllocator Tests

```python
"""Tests for ProtectedSpectrumAllocator."""

import pytest

from fusion.pipelines.protection_pipeline import ProtectedSpectrumAllocator


class TestProtectedSpectrumAllocator:
    """Test suite for ProtectedSpectrumAllocator."""

    def test_allocate_success(self, diamond_state) -> None:
        """Should allocate same slots on both paths."""
        allocator = ProtectedSpectrumAllocator(guard_band=1)

        result = allocator.allocate(
            primary_path=["A", "B", "D"],
            backup_path=["A", "C", "D"],
            slots_needed=6,
            network_state=diamond_state,
        )

        assert result.success
        assert result.start_slot is not None
        assert result.slots_used == 6

        # Verify allocated on all links
        for link in [("A", "B"), ("B", "D"), ("A", "C"), ("C", "D")]:
            spectrum = diamond_state.get_link_spectrum(link)
            assert spectrum[result.start_slot] == 1

    def test_allocate_fail_no_spectrum(self, diamond_state) -> None:
        """Should fail when spectrum not available."""
        allocator = ProtectedSpectrumAllocator(guard_band=1)

        # Fill all spectrum
        for link in [("A", "B"), ("B", "D"), ("A", "C"), ("C", "D")]:
            spectrum = diamond_state.get_link_spectrum(link)
            spectrum[:] = 1

        result = allocator.allocate(
            primary_path=["A", "B", "D"],
            backup_path=["A", "C", "D"],
            slots_needed=6,
            network_state=diamond_state,
        )

        assert not result.success
        assert result.failure_reason is not None

    def test_check_availability_true(self, diamond_state) -> None:
        """Should return True when spectrum available."""
        allocator = ProtectedSpectrumAllocator()

        available = allocator.check_availability(
            primary_path=["A", "B", "D"],
            backup_path=["A", "C", "D"],
            slots_needed=6,
            network_state=diamond_state,
        )

        assert available

    def test_check_availability_false(self, diamond_state) -> None:
        """Should return False when spectrum not available."""
        allocator = ProtectedSpectrumAllocator()

        # Fill backup path
        for link in [("A", "C"), ("C", "D")]:
            spectrum = diamond_state.get_link_spectrum(link)
            spectrum[:] = 1

        available = allocator.check_availability(
            primary_path=["A", "B", "D"],
            backup_path=["A", "C", "D"],
            slots_needed=6,
            network_state=diamond_state,
        )

        assert not available

    def test_deallocate(self, diamond_state) -> None:
        """Should free slots on both paths."""
        allocator = ProtectedSpectrumAllocator()

        # First allocate
        result = allocator.allocate(
            ["A", "B", "D"], ["A", "C", "D"], 6, diamond_state
        )

        # Then deallocate
        allocator.deallocate(
            ["A", "B", "D"], ["A", "C", "D"],
            result.start_slot, result.end_slot, diamond_state
        )

        # Verify freed
        for link in [("A", "B"), ("B", "D"), ("A", "C"), ("C", "D")]:
            spectrum = diamond_state.get_link_spectrum(link)
            assert spectrum[result.start_slot] == 0

    def test_guard_band_applied(self, diamond_state) -> None:
        """Should apply guard band between allocations."""
        allocator = ProtectedSpectrumAllocator(guard_band=2)

        result1 = allocator.allocate(
            ["A", "B", "D"], ["A", "C", "D"], 6, diamond_state
        )
        result2 = allocator.allocate(
            ["A", "B", "D"], ["A", "C", "D"], 6, diamond_state
        )

        assert result1.success
        assert result2.success
        # Second allocation should start after first + guard band
        assert result2.start_slot >= result1.end_slot + 2
```

### 5. FailureHandler Tests

```python
"""Tests for FailureHandler."""

import pytest

from fusion.pipelines.protection_pipeline import (
    FailureHandler,
    FailureType,
)


class TestFailureHandler:
    """Test suite for FailureHandler."""

    def test_link_failure_switchover(
        self, diamond_state, protected_lightpath
    ) -> None:
        """Should switch protected lightpath to backup."""
        diamond_state.add_lightpath(protected_lightpath)
        handler = FailureHandler(switchover_time_ms=50.0)

        result = handler.handle_link_failure(
            failed_link=("A", "B"),
            network_state=diamond_state,
            current_time=100.0,
        )

        assert result.failure_type == FailureType.LINK
        assert len(result.switchovers) == 1
        assert result.switchovers[0].to_path == "backup"
        assert result.recovery_time_ms == 50.0
        assert protected_lightpath.active_path == "backup"

    def test_unprotected_lightpath_lost(
        self, diamond_state, unprotected_lightpath
    ) -> None:
        """Should mark unprotected lightpath as lost."""
        diamond_state.add_lightpath(unprotected_lightpath)
        handler = FailureHandler()

        result = handler.handle_link_failure(
            failed_link=("A", "B"),
            network_state=diamond_state,
            current_time=100.0,
        )

        assert len(result.switchovers) == 0
        assert len(result.lost_lightpaths) == 1
        assert unprotected_lightpath.lightpath_id in result.lost_lightpaths

    def test_backup_path_affected_lost(
        self, diamond_state, protected_lightpath
    ) -> None:
        """Should lose lightpath if both paths affected."""
        # Modify backup to share failed link
        protected_lightpath.backup_path = ["A", "B", "C", "D"]
        diamond_state.add_lightpath(protected_lightpath)

        handler = FailureHandler()
        result = handler.handle_link_failure(
            failed_link=("A", "B"),
            network_state=diamond_state,
            current_time=100.0,
        )

        assert len(result.switchovers) == 0
        assert len(result.lost_lightpaths) == 1

    def test_node_failure_node_disjoint(
        self, diamond_state, protected_lightpath
    ) -> None:
        """Should survive node failure with node-disjoint backup."""
        diamond_state.add_lightpath(protected_lightpath)
        handler = FailureHandler()

        # Fail intermediate node B (not on backup path A-C-D)
        result = handler.handle_node_failure(
            failed_node="B",
            network_state=diamond_state,
            current_time=100.0,
        )

        assert len(result.switchovers) == 1
        assert result.switchovers[0].to_path == "backup"

    def test_metrics_tracking(self, diamond_state, protected_lightpath) -> None:
        """Should track failure metrics."""
        diamond_state.add_lightpath(protected_lightpath)
        handler = FailureHandler()

        handler.handle_link_failure(("A", "B"), diamond_state, 100.0)
        metrics = handler.get_metrics()

        assert metrics["total_failures"] == 1
        assert metrics["successful_switchovers"] == 1
        assert metrics["lost_lightpaths"] == 0
        assert metrics["switchover_success_rate"] == 1.0
```

### 6. ProtectionPipeline Integration Tests

```python
"""Integration tests for ProtectionPipeline."""

import pytest

from fusion.pipelines.protection_pipeline import (
    ProtectionPipeline,
    ProtectionConfig,
    DisjointnessType,
)


class TestProtectionPipeline:
    """Integration test suite for ProtectionPipeline."""

    def test_find_protected_routes_success(self, diamond_state) -> None:
        """Should find protected routes in diamond topology."""
        config = ProtectionConfig(
            enabled=True,
            disjointness=DisjointnessType.LINK,
        )
        pipeline = ProtectionPipeline(config)

        result = pipeline.find_protected_routes(
            source="A",
            destination="D",
            bandwidth_gbps=100,
            network_state=diamond_state,
        )

        assert len(result.paths) == 1
        assert result.backup_paths is not None
        assert len(result.backup_paths) == 1
        assert result.paths[0] != result.backup_paths[0]

    def test_find_protected_routes_no_disjoint(self, linear_state) -> None:
        """Should return empty when no disjoint paths exist."""
        config = ProtectionConfig(enabled=True)
        pipeline = ProtectionPipeline(config)

        result = pipeline.find_protected_routes(
            source="A",
            destination="D",
            bandwidth_gbps=100,
            network_state=linear_state,
        )

        assert result.paths == []

    def test_handle_failure_integration(
        self, diamond_state, protected_lightpath
    ) -> None:
        """Should handle failure through pipeline."""
        diamond_state.add_lightpath(protected_lightpath)

        config = ProtectionConfig(enabled=True, switchover_time_ms=50.0)
        pipeline = ProtectionPipeline(config)

        result = pipeline.handle_link_failure(
            failed_link=("A", "B"),
            network_state=diamond_state,
            current_time=100.0,
        )

        assert len(result.switchovers) == 1
        assert result.recovery_time_ms == 50.0

    def test_metrics_tracking(self, diamond_state) -> None:
        """Should track pipeline metrics."""
        config = ProtectionConfig(enabled=True)
        pipeline = ProtectionPipeline(config)

        # Successful request
        pipeline.find_protected_routes("A", "D", 100, diamond_state)

        metrics = pipeline.get_metrics()
        assert metrics["total_requests"] == 1
        assert metrics["protected_allocations"] == 1
        assert metrics["success_rate"] == 1.0

    def test_node_disjoint_mode(self, diamond_state) -> None:
        """Should use node-disjoint paths when configured."""
        config = ProtectionConfig(
            enabled=True,
            disjointness=DisjointnessType.NODE,
        )
        pipeline = ProtectionPipeline(config)

        result = pipeline.find_protected_routes(
            source="A",
            destination="D",
            bandwidth_gbps=100,
            network_state=diamond_state,
        )

        assert len(result.paths) == 1
        # Verify node-disjoint (no shared intermediate nodes)
        primary_intermediate = set(result.paths[0][1:-1])
        backup_intermediate = set(result.backup_paths[0][1:-1])
        assert primary_intermediate.isdisjoint(backup_intermediate)
```

### 7. Acceptance Criteria

| Criterion | Test Coverage |
|-----------|---------------|
| Link-disjoint paths found | `test_find_edge_disjoint_diamond` |
| Node-disjoint paths found | `test_find_node_disjoint_diamond` |
| Spectrum allocated on both paths | `test_allocate_success` |
| Allocation fails when no spectrum | `test_allocate_fail_no_spectrum` |
| Switchover on link failure | `test_link_failure_switchover` |
| Unprotected lightpaths lost | `test_unprotected_lightpath_lost` |
| Metrics tracked correctly | `test_metrics_tracking` |
| Integration end-to-end | `test_find_protected_routes_success` |

---

## Verification Commands

```bash
# Run all protection pipeline tests
pytest fusion/pipelines/tests/ -v

# Run with coverage
pytest fusion/pipelines/tests/ -v --cov=fusion/pipelines --cov-report=term-missing

# Type checking
mypy fusion/pipelines/protection_pipeline.py

# Lint checking
ruff check fusion/pipelines/
```

---

## Exit Criteria for P5.4

- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] Code coverage >= 80%
- [ ] Type checking passes (mypy)
- [ ] Lint checking passes (ruff)
- [ ] DisjointPathFinder finds correct paths
- [ ] ProtectedSpectrumAllocator allocates on both paths
- [ ] FailureHandler triggers switchovers correctly
- [ ] ProtectionPipeline integrates all components
- [ ] Metrics tracked accurately

---

## Next Sub-Phase

After P5.4 verification, proceed to **P5.5 Orchestrator Integration**.
