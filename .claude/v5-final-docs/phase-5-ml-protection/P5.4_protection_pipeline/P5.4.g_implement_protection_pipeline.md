# Task ID: P5.4.g - Implement ProtectionPipeline

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** wiring-plan

---

## Purpose

Provide the complete implementation of the ProtectionPipeline, integrating all designed components: DisjointPathFinder, ProtectedSpectrumAllocator, FailureHandler, and extended Lightpath model.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.b_design_protection_pipeline.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.c_design_disjoint_path_finder.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.d_design_protected_spectrum.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.e_design_failure_handling.md`

---

## Outputs

### 1. Complete Protection Pipeline Module

**File:** `fusion/pipelines/protection_pipeline.py`

```python
"""
Protection pipeline for 1+1 dedicated path protection.

This module provides the ProtectionPipeline class that orchestrates
disjoint path finding, dual spectrum allocation, and failure handling
for 1+1 dedicated protection in optical networks.

1+1 Protection:
- Allocates spectrum on BOTH primary and backup paths
- Same slots used on both paths (dedicated protection)
- Fast switchover on failure (~50ms configurable)
- Supports link-disjoint and node-disjoint modes

Example:
    >>> from fusion.pipelines.protection_pipeline import (
    ...     ProtectionPipeline,
    ...     ProtectionConfig,
    ... )
    >>> config = ProtectionConfig(enabled=True, disjointness="link")
    >>> pipeline = ProtectionPipeline(config)
    >>> result = pipeline.find_protected_routes("A", "D", 100, network_state)
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any

import networkx as nx
import numpy as np

if TYPE_CHECKING:
    from fusion.domain.lightpath import Lightpath
    from fusion.domain.network_state import NetworkState
    from fusion.domain.results import RouteResult

logger = logging.getLogger(__name__)


# =============================================================================
# Enums and Config
# =============================================================================


class DisjointnessType(Enum):
    """Type of path disjointness for protection."""

    LINK = "link"
    NODE = "node"


class FailureType(Enum):
    """Type of network failure."""

    LINK = "link"
    NODE = "node"


@dataclass
class ProtectionConfig:
    """
    Configuration for protection pipeline.

    Attributes:
        enabled: Whether protection is enabled
        disjointness: Type of disjointness (link or node)
        switchover_time_ms: Protection switchover latency
        revert_after_repair: Whether to revert to primary after repair
        guard_band_slots: Guard band between spectrum allocations
    """

    enabled: bool = False
    disjointness: DisjointnessType = DisjointnessType.LINK
    switchover_time_ms: float = 50.0
    revert_after_repair: bool = False
    guard_band_slots: int = 1

    @classmethod
    def from_dict(cls, config: dict[str, Any]) -> "ProtectionConfig":
        """Create from dictionary."""
        disjointness = config.get("disjointness", "link")
        if isinstance(disjointness, str):
            disjointness = DisjointnessType(disjointness)

        return cls(
            enabled=config.get("enabled", False),
            disjointness=disjointness,
            switchover_time_ms=config.get("switchover_time_ms", 50.0),
            revert_after_repair=config.get("revert_after_repair", False),
            guard_band_slots=config.get("guard_band_slots", 1),
        )


# =============================================================================
# Data Classes
# =============================================================================


@dataclass
class PathInfo:
    """Information about a candidate path."""

    path: tuple[str, ...]
    weight_km: float
    modulations: list[str]
    is_feasible: bool


@dataclass(frozen=True)
class SwitchoverAction:
    """Record of a protection switchover."""

    lightpath_id: str
    from_path: str
    to_path: str
    latency_ms: float
    timestamp: float


@dataclass
class RecoveryResult:
    """Result of failure recovery."""

    failure_type: FailureType
    failed_element: tuple[str, str] | str
    timestamp: float
    switchovers: list[SwitchoverAction] = field(default_factory=list)
    lost_lightpaths: list[str] = field(default_factory=list)
    recovery_time_ms: float = 0.0


@dataclass(frozen=True)
class ProtectedAllocationResult:
    """Result of protected spectrum allocation."""

    success: bool
    start_slot: int | None = None
    end_slot: int | None = None
    slots_used: int | None = None
    primary_path: list[str] | None = None
    backup_path: list[str] | None = None
    failure_reason: str | None = None


# =============================================================================
# Disjoint Path Finder
# =============================================================================


class DisjointPathFinder:
    """
    Find disjoint paths for protection routing.

    Implements link-disjoint and node-disjoint path finding using
    NetworkX algorithms.
    """

    def __init__(
        self, disjointness: DisjointnessType = DisjointnessType.LINK
    ) -> None:
        self.disjointness = disjointness

    def find_all_disjoint_paths(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> list[list[str]]:
        """Find all disjoint paths between source and destination."""
        try:
            if self.disjointness == DisjointnessType.LINK:
                paths = list(
                    nx.edge_disjoint_paths(topology, source, destination)
                )
            else:
                paths = list(
                    nx.node_disjoint_paths(topology, source, destination)
                )
            return [list(path) for path in paths]
        except (nx.NetworkXNoPath, nx.NetworkXError) as e:
            logger.debug(f"No disjoint paths {source} -> {destination}: {e}")
            return []

    def find_disjoint_pair(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> tuple[list[str] | None, list[str] | None]:
        """Find a single disjoint path pair."""
        all_paths = self.find_all_disjoint_paths(topology, source, destination)
        if len(all_paths) >= 2:
            return all_paths[0], all_paths[1]
        return None, None

    def verify_disjointness(self, path1: list[str], path2: list[str]) -> bool:
        """Verify that two paths are disjoint."""
        if self.disjointness == DisjointnessType.LINK:
            edges1 = {(path1[i], path1[i + 1]) for i in range(len(path1) - 1)}
            edges2 = {(path2[i], path2[i + 1]) for i in range(len(path2) - 1)}
            for edge in edges1:
                if edge in edges2 or (edge[1], edge[0]) in edges2:
                    return False
            return True
        else:
            intermediate1 = set(path1[1:-1])
            intermediate2 = set(path2[1:-1])
            return intermediate1.isdisjoint(intermediate2)


# =============================================================================
# Protected Spectrum Allocator
# =============================================================================


class ProtectedSpectrumAllocator:
    """
    Allocate spectrum for 1+1 dedicated protection.

    Allocates the same spectrum slots on both primary and backup paths.
    """

    def __init__(self, guard_band: int = 1) -> None:
        self.guard_band = guard_band

    def allocate(
        self,
        primary_path: list[str],
        backup_path: list[str],
        slots_needed: int,
        network_state: NetworkState,
    ) -> ProtectedAllocationResult:
        """Allocate spectrum on both paths."""
        primary_links = self._path_to_links(primary_path)
        backup_links = self._path_to_links(backup_path)
        all_links = primary_links | backup_links

        available_mask = self._get_combined_availability(
            all_links, network_state
        )

        if available_mask is None:
            return ProtectedAllocationResult(
                success=False,
                failure_reason="Could not get spectrum availability",
            )

        start_slot = self._find_first_fit(available_mask, slots_needed)

        if start_slot is None:
            return ProtectedAllocationResult(
                success=False,
                primary_path=primary_path,
                backup_path=backup_path,
                failure_reason="No contiguous spectrum on both paths",
            )

        end_slot = start_slot + slots_needed

        self._mark_allocated(primary_links, start_slot, end_slot, network_state)
        self._mark_allocated(backup_links, start_slot, end_slot, network_state)

        return ProtectedAllocationResult(
            success=True,
            start_slot=start_slot,
            end_slot=end_slot,
            slots_used=slots_needed,
            primary_path=primary_path,
            backup_path=backup_path,
        )

    def check_availability(
        self,
        primary_path: list[str],
        backup_path: list[str],
        slots_needed: int,
        network_state: NetworkState,
    ) -> bool:
        """Check if allocation is possible."""
        all_links = (
            self._path_to_links(primary_path) |
            self._path_to_links(backup_path)
        )
        available_mask = self._get_combined_availability(
            all_links, network_state
        )
        if available_mask is None:
            return False
        return self._find_first_fit(available_mask, slots_needed) is not None

    def deallocate(
        self,
        primary_path: list[str],
        backup_path: list[str],
        start_slot: int,
        end_slot: int,
        network_state: NetworkState,
    ) -> None:
        """Deallocate spectrum from both paths."""
        primary_links = self._path_to_links(primary_path)
        backup_links = self._path_to_links(backup_path)
        self._mark_free(primary_links, start_slot, end_slot, network_state)
        self._mark_free(backup_links, start_slot, end_slot, network_state)

    def _path_to_links(self, path: list[str]) -> set[tuple[str, str]]:
        links = set()
        for i in range(len(path) - 1):
            link = tuple(sorted([path[i], path[i + 1]]))
            links.add(link)
        return links

    def _get_combined_availability(
        self,
        links: set[tuple[str, str]],
        network_state: NetworkState,
    ) -> np.ndarray | None:
        combined_mask = None
        for link in links:
            link_availability = network_state.get_link_spectrum(link)
            if link_availability is None:
                return None
            free_mask = link_availability == 0
            if combined_mask is None:
                combined_mask = free_mask
            else:
                combined_mask = combined_mask & free_mask
        return combined_mask

    def _find_first_fit(
        self,
        available_mask: np.ndarray,
        slots_needed: int,
    ) -> int | None:
        total_slots = len(available_mask)
        required = slots_needed + self.guard_band
        consecutive = 0
        start = None

        for i in range(total_slots):
            if available_mask[i]:
                if start is None:
                    start = i
                consecutive += 1
                if consecutive >= required:
                    return start
            else:
                consecutive = 0
                start = None

        return None

    def _mark_allocated(
        self,
        links: set[tuple[str, str]],
        start_slot: int,
        end_slot: int,
        network_state: NetworkState,
    ) -> None:
        for link in links:
            network_state.allocate_spectrum(link, start_slot, end_slot)

    def _mark_free(
        self,
        links: set[tuple[str, str]],
        start_slot: int,
        end_slot: int,
        network_state: NetworkState,
    ) -> None:
        for link in links:
            network_state.deallocate_spectrum(link, start_slot, end_slot)


# =============================================================================
# Failure Handler
# =============================================================================


class FailureHandler:
    """Handle network failures and trigger protection switchovers."""

    def __init__(
        self,
        switchover_time_ms: float = 50.0,
        revert_after_repair: bool = False,
    ) -> None:
        self.switchover_time_ms = switchover_time_ms
        self.revert_after_repair = revert_after_repair
        self._total_failures = 0
        self._successful_switchovers = 0
        self._lost_lightpaths = 0

    def handle_link_failure(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
        current_time: float,
    ) -> RecoveryResult:
        """Handle a link failure event."""
        self._total_failures += 1
        affected = self._find_affected_lightpaths(failed_link, network_state)
        switchovers = []
        lost = []

        for lightpath in affected:
            if self._can_switchover(lightpath, failed_link):
                action = self._perform_switchover(lightpath, current_time)
                switchovers.append(action)
                self._successful_switchovers += 1
            else:
                lost.append(lightpath.lightpath_id)
                self._lost_lightpaths += 1

        recovery_time = self.switchover_time_ms if switchovers else 0.0

        return RecoveryResult(
            failure_type=FailureType.LINK,
            failed_element=failed_link,
            timestamp=current_time,
            switchovers=switchovers,
            lost_lightpaths=lost,
            recovery_time_ms=recovery_time,
        )

    def handle_node_failure(
        self,
        failed_node: str,
        network_state: NetworkState,
        current_time: float,
    ) -> RecoveryResult:
        """Handle a node failure event."""
        self._total_failures += 1
        affected = self._find_lightpaths_through_node(failed_node, network_state)
        switchovers = []
        lost = []

        for lightpath in affected:
            if self._can_switchover_node(lightpath, failed_node):
                action = self._perform_switchover(lightpath, current_time)
                switchovers.append(action)
                self._successful_switchovers += 1
            else:
                lost.append(lightpath.lightpath_id)
                self._lost_lightpaths += 1

        recovery_time = self.switchover_time_ms if switchovers else 0.0

        return RecoveryResult(
            failure_type=FailureType.NODE,
            failed_element=failed_node,
            timestamp=current_time,
            switchovers=switchovers,
            lost_lightpaths=lost,
            recovery_time_ms=recovery_time,
        )

    def _find_affected_lightpaths(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
    ) -> list[Lightpath]:
        return [
            lp for lp in network_state.active_lightpaths
            if self._path_contains_link(lp.current_path, failed_link)
        ]

    def _find_lightpaths_through_node(
        self,
        failed_node: str,
        network_state: NetworkState,
    ) -> list[Lightpath]:
        return [
            lp for lp in network_state.active_lightpaths
            if failed_node in lp.current_path[1:-1]
        ]

    def _can_switchover(
        self,
        lightpath: Lightpath,
        failed_link: tuple[str, str],
    ) -> bool:
        if not lightpath.is_protected or lightpath.active_path != "primary":
            return False
        return not self._path_contains_link(lightpath.backup_path, failed_link)

    def _can_switchover_node(
        self,
        lightpath: Lightpath,
        failed_node: str,
    ) -> bool:
        if not lightpath.is_protected or lightpath.active_path != "primary":
            return False
        return failed_node not in lightpath.backup_path[1:-1]

    def _perform_switchover(
        self,
        lightpath: Lightpath,
        current_time: float,
    ) -> SwitchoverAction:
        action = SwitchoverAction(
            lightpath_id=lightpath.lightpath_id,
            from_path="primary",
            to_path="backup",
            latency_ms=self.switchover_time_ms,
            timestamp=current_time,
        )
        lightpath.active_path = "backup"
        return action

    def _path_contains_link(
        self,
        path: list[str] | None,
        link: tuple[str, str],
    ) -> bool:
        if path is None:
            return False
        for i in range(len(path) - 1):
            edge = (path[i], path[i + 1])
            if edge == link or edge == (link[1], link[0]):
                return True
        return False

    def get_metrics(self) -> dict[str, Any]:
        """Get failure handling metrics."""
        success_rate = (
            self._successful_switchovers / self._total_failures
            if self._total_failures > 0
            else 1.0
        )
        return {
            "total_failures": self._total_failures,
            "successful_switchovers": self._successful_switchovers,
            "lost_lightpaths": self._lost_lightpaths,
            "switchover_success_rate": success_rate,
        }


# =============================================================================
# Protection Pipeline
# =============================================================================


class ProtectionPipeline:
    """
    Pipeline for 1+1 dedicated path protection.

    Orchestrates disjoint path finding, dual spectrum allocation,
    and failure handling for protected lightpaths.

    Attributes:
        config: Protection configuration
        disjoint_finder: Disjoint path finding algorithm
        spectrum_allocator: Protected spectrum allocator
        failure_handler: Failure handling mechanism

    Example:
        >>> config = ProtectionConfig(enabled=True)
        >>> pipeline = ProtectionPipeline(config)
        >>> result = pipeline.find_protected_routes("A", "D", 100, state)
    """

    def __init__(self, config: ProtectionConfig) -> None:
        """Initialize protection pipeline."""
        self.config = config
        self._disjoint_finder = DisjointPathFinder(config.disjointness)
        self._spectrum_allocator = ProtectedSpectrumAllocator(
            guard_band=config.guard_band_slots
        )
        self._failure_handler = FailureHandler(
            switchover_time_ms=config.switchover_time_ms,
            revert_after_repair=config.revert_after_repair,
        )

        # Metrics
        self._total_requests = 0
        self._protected_allocations = 0
        self._protection_failures = 0

    def find_protected_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> RouteResult:
        """
        Find protected routes with disjoint primary and backup paths.

        Args:
            source: Source node
            destination: Destination node
            bandwidth_gbps: Required bandwidth
            network_state: Current network state

        Returns:
            RouteResult with paired primary/backup paths
        """
        from fusion.domain.results import RouteResult

        self._total_requests += 1
        topology = network_state.topology

        # Find disjoint paths
        disjoint_paths = self._disjoint_finder.find_all_disjoint_paths(
            topology, source, destination
        )

        if len(disjoint_paths) < 2:
            logger.debug(f"No disjoint paths for {source} -> {destination}")
            self._protection_failures += 1
            return RouteResult(paths=[], modulations=[], weights_km=[])

        # Find feasible pairs
        feasible_pairs = self._find_feasible_pairs(
            disjoint_paths, bandwidth_gbps, network_state
        )

        if not feasible_pairs:
            logger.debug(f"No feasible pair for {source} -> {destination}")
            self._protection_failures += 1
            return RouteResult(paths=[], modulations=[], weights_km=[])

        # Select best pair
        best_pair = self._select_best_pair(feasible_pairs)
        self._protected_allocations += 1

        return self._build_route_result(best_pair)

    def _find_feasible_pairs(
        self,
        disjoint_paths: list[list[str]],
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> list[tuple[PathInfo, PathInfo]]:
        """Find all feasible primary/backup path pairs."""
        feasible_pairs = []

        for i in range(len(disjoint_paths)):
            for j in range(i + 1, len(disjoint_paths)):
                primary_info = self._evaluate_path(
                    disjoint_paths[i], bandwidth_gbps, network_state
                )
                backup_info = self._evaluate_path(
                    disjoint_paths[j], bandwidth_gbps, network_state
                )

                if primary_info.is_feasible and backup_info.is_feasible:
                    feasible_pairs.append((primary_info, backup_info))

        return feasible_pairs

    def _evaluate_path(
        self,
        path: list[str],
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> PathInfo:
        """Evaluate a path for feasibility."""
        weight_km = self._compute_path_weight(path, network_state)
        modulations = self._get_valid_modulations(
            path, bandwidth_gbps, network_state
        )
        is_feasible = len(modulations) > 0

        return PathInfo(
            path=tuple(path),
            weight_km=weight_km,
            modulations=modulations,
            is_feasible=is_feasible,
        )

    def _select_best_pair(
        self,
        feasible_pairs: list[tuple[PathInfo, PathInfo]],
    ) -> tuple[PathInfo, PathInfo]:
        """Select best pair (shortest combined length)."""
        return min(
            feasible_pairs,
            key=lambda pair: pair[0].weight_km + pair[1].weight_km,
        )

    def _compute_path_weight(
        self,
        path: list[str],
        network_state: NetworkState,
    ) -> float:
        """Compute path weight in kilometers."""
        topology = network_state.topology
        weight = 0.0
        for i in range(len(path) - 1):
            edge_data = topology.get_edge_data(path[i], path[i + 1])
            if edge_data:
                weight += edge_data.get("weight", 1.0)
        return weight

    def _get_valid_modulations(
        self,
        path: list[str],
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> list[str]:
        """Get valid modulation formats for path."""
        path_length = self._compute_path_weight(path, network_state)
        valid_mods = []
        mod_formats = getattr(network_state, "modulation_formats", {})

        for mod_name, mod_info in mod_formats.items():
            max_reach = mod_info.get("max_length", float("inf"))
            if path_length <= max_reach:
                valid_mods.append(mod_name)

        # Default fallback
        if not valid_mods:
            valid_mods = ["QPSK"]

        return valid_mods

    def _build_route_result(
        self,
        pair: tuple[PathInfo, PathInfo],
    ) -> RouteResult:
        """Build RouteResult from selected path pair."""
        from fusion.domain.results import RouteResult

        primary, backup = pair

        return RouteResult(
            paths=[list(primary.path)],
            modulations=[primary.modulations],
            weights_km=[primary.weight_km],
            backup_paths=[list(backup.path)],
            backup_modulations=[backup.modulations],
            backup_weights_km=[backup.weight_km],
            strategy_name="1plus1_protection",
        )

    def handle_link_failure(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
        current_time: float,
    ) -> RecoveryResult:
        """Handle link failure with switchover."""
        return self._failure_handler.handle_link_failure(
            failed_link, network_state, current_time
        )

    def handle_node_failure(
        self,
        failed_node: str,
        network_state: NetworkState,
        current_time: float,
    ) -> RecoveryResult:
        """Handle node failure with switchover."""
        return self._failure_handler.handle_node_failure(
            failed_node, network_state, current_time
        )

    def allocate_protected(
        self,
        primary_path: list[str],
        backup_path: list[str],
        slots_needed: int,
        network_state: NetworkState,
    ) -> ProtectedAllocationResult:
        """Allocate spectrum on both paths."""
        return self._spectrum_allocator.allocate(
            primary_path, backup_path, slots_needed, network_state
        )

    def get_metrics(self) -> dict[str, Any]:
        """Get protection pipeline metrics."""
        success_rate = (
            self._protected_allocations / self._total_requests
            if self._total_requests > 0
            else 0.0
        )

        return {
            "total_requests": self._total_requests,
            "protected_allocations": self._protected_allocations,
            "protection_failures": self._protection_failures,
            "success_rate": success_rate,
            "disjointness_type": self.config.disjointness.value,
            "switchover_time_ms": self.config.switchover_time_ms,
            **self._failure_handler.get_metrics(),
        }

    def reset_metrics(self) -> None:
        """Reset all metrics."""
        self._total_requests = 0
        self._protected_allocations = 0
        self._protection_failures = 0
```

### 2. Package __init__.py

**File:** `fusion/pipelines/__init__.py`

```python
"""
Pipeline modules for FUSION simulation.

This package contains pipeline implementations for various
simulation components including protection.
"""

from fusion.pipelines.protection_pipeline import (
    DisjointPathFinder,
    DisjointnessType,
    FailureHandler,
    FailureType,
    PathInfo,
    ProtectedAllocationResult,
    ProtectedSpectrumAllocator,
    ProtectionConfig,
    ProtectionPipeline,
    RecoveryResult,
    SwitchoverAction,
)

__all__ = [
    # Main pipeline
    "ProtectionPipeline",
    "ProtectionConfig",
    # Components
    "DisjointPathFinder",
    "ProtectedSpectrumAllocator",
    "FailureHandler",
    # Enums
    "DisjointnessType",
    "FailureType",
    # Data classes
    "PathInfo",
    "SwitchoverAction",
    "RecoveryResult",
    "ProtectedAllocationResult",
]
```

---

## Verification

- [ ] ProtectionPipeline initializes all components
- [ ] find_protected_routes finds disjoint pairs
- [ ] Spectrum allocation works on both paths
- [ ] Failure handling triggers switchovers
- [ ] Metrics track all operations
- [ ] All imports resolve correctly

---

## Next Task

Proceed to **P5.4.h** to create the verification plan.
