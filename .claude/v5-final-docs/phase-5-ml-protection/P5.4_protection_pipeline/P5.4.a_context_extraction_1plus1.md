# Task ID: P5.4.a - Context Extraction: 1+1 Protection Patterns

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** context-extraction

---

## Purpose

Extract and document existing 1+1 protection patterns from the FUSION codebase to inform the new ProtectionPipeline design.

---

## Context to load before running this task

- `fusion/modules/routing/one_plus_one_protection.py`
- `fusion/modules/rl/policies/one_plus_one_policy.py`
- `fusion/modules/routing/tests/test_one_plus_one_protection.py`

---

## Outputs

### 1. Existing Class Inventory

| Class | Location | Purpose |
|-------|----------|---------|
| `OnePlusOneProtection` | `fusion/modules/routing/one_plus_one_protection.py` | Routing algorithm for disjoint paths |
| `OnePlusOnePolicy` | `fusion/modules/rl/policies/one_plus_one_policy.py` | Path selection policy |

### 2. OnePlusOneProtection Analysis

#### Class Signature

```python
class OnePlusOneProtection(AbstractRoutingAlgorithm):
    """
    Traditional 1+1 disjoint protection routing for optical networks.

    Implements:
    - Max-flow algorithm (Suurballe's) for disjoint path finding
    - Simultaneous allocation on both paths
    - Configurable switchover latency
    """

    def __init__(self, engine_props: dict[str, Any], sdn_props: SDNProps) -> None:
        self.topology = engine_props.get("topology", sdn_props.topology)
        self.protection_switchover_ms = engine_props.get(
            "protection_settings", {}
        ).get("protection_switchover_ms", 50.0)
        self.revert_to_primary = engine_props.get(
            "protection_settings", {}
        ).get("revert_to_primary", False)
```

#### Key Methods

| Method | Input | Output | Purpose |
|--------|-------|--------|---------|
| `route()` | source, destination, request | None (sets route_props) | Main routing entry point |
| `find_all_disjoint_paths()` | source, destination | `list[list[int]]` | Find all edge-disjoint paths |
| `find_disjoint_paths()` | source, destination | `tuple[path, path]` | Get first disjoint pair |
| `handle_failure()` | current_time, affected_requests | `list[dict]` | Switchover logic |
| `get_metrics()` | None | `dict[str, Any]` | Protection statistics |

#### Disjoint Path Algorithm

```python
def find_all_disjoint_paths(self, source, destination) -> list[list[int]]:
    """
    Uses NetworkX edge_disjoint_paths (Suurballe's algorithm).
    Returns all edge-disjoint paths between source and destination.
    """
    try:
        paths = list(nx.edge_disjoint_paths(
            self.topology,
            source,
            destination,
            flow_func=None,  # Default: shortest augmenting path
        ))
        return [list(path) for path in paths]
    except (AttributeError, nx.NetworkXNoPath, nx.NetworkXError):
        return []
```

#### Route Selection Logic

```python
def route(self, source, destination, request):
    # 1. Find all disjoint paths
    all_disjoint_paths = self.find_all_disjoint_paths(source, destination)

    if len(all_disjoint_paths) < 2:
        # Cannot provide 1+1 protection
        self._disjoint_paths_failed += 1
        return

    # 2. Try all pairs, find first where BOTH are feasible
    for i in range(len(all_disjoint_paths)):
        for j in range(i + 1, len(all_disjoint_paths)):
            primary = all_disjoint_paths[i]
            backup = all_disjoint_paths[j]

            primary_mods = self._get_modulation_formats_for_path(primary)
            backup_mods = self._get_modulation_formats_for_path(backup)

            primary_feasible = any(mod and mod is not False for mod in primary_mods)
            backup_feasible = any(mod and mod is not False for mod in backup_mods)

            if primary_feasible and backup_feasible:
                # Found feasible pair
                self._set_route_props(primary, backup, primary_mods, backup_mods)
                return

    # No feasible pair found
    self._disjoint_paths_failed += 1
```

### 3. OnePlusOnePolicy Analysis

#### Class Signature

```python
class OnePlusOnePolicy(PathPolicy):
    """
    1+1 policy: use primary if feasible, else backup.

    Action space: [primary, backup] = [0, 1]
    Action mask: [primary_feasible, backup_feasible]
    """
```

#### Selection Logic

```python
def select_path(self, state: dict[str, Any], action_mask: list[bool]) -> int:
    """
    Priority order:
    1. Primary (index 0) if feasible
    2. Backup (index 1) if feasible
    3. -1 if both infeasible
    """
    if action_mask[0]:
        return 0  # Primary
    if len(action_mask) > 1 and action_mask[1]:
        return 1  # Backup
    return -1  # Block
```

### 4. SDNProps Protection State

```python
# Set by OnePlusOneProtection.route()
sdn_props.primary_path = [0, 1, 2, 5]
sdn_props.backup_path = [0, 3, 4, 5]
sdn_props.is_protected = True
sdn_props.active_path = "primary"
```

### 5. RouteProps Backup Fields

```python
# Primary paths
route_props.paths_matrix = [[0, 1, 2, 5]]
route_props.modulation_formats_matrix = [["QPSK"]]
route_props.weights_list = [3]  # hop count

# Backup paths
route_props.backup_paths_matrix = [[0, 3, 4, 5]]
route_props.backup_modulation_formats_matrix = [["QPSK"]]
```

### 6. Failure Handling Pattern

```python
def handle_failure(self, current_time, affected_requests) -> list[dict]:
    recovery_actions = []

    for request in affected_requests:
        if request.get("is_protected", False):
            recovery_actions.append({
                "request_id": request["id"],
                "action": "switchover",
                "recovery_time_ms": self.protection_switchover_ms,
                "from_path": "primary",
                "to_path": "backup",
            })

    return recovery_actions
```

### 7. Environment Validation

```python
def validate_environment(self, topology: nx.Graph) -> bool:
    """
    1+1 protection requires:
    - Connected graph
    - Edge connectivity >= 2 (for disjoint paths)
    """
    if not nx.is_connected(topology):
        return False

    edge_connectivity = nx.edge_connectivity(topology)
    if edge_connectivity < 2:
        return False

    return True
```

### 8. Metrics Tracking

```python
def get_metrics(self) -> dict[str, Any]:
    total_attempts = self._disjoint_paths_found + self._disjoint_paths_failed
    success_rate = (
        self._disjoint_paths_found / total_attempts
        if total_attempts > 0 else 0.0
    )

    return {
        "algorithm": "1plus1_protection",
        "disjoint_paths_found": self._disjoint_paths_found,
        "disjoint_paths_failed": self._disjoint_paths_failed,
        "success_rate": success_rate,
        "protection_switchover_ms": self.protection_switchover_ms,
        "revert_to_primary": self.revert_to_primary,
    }
```

### 9. Gap Analysis

| Current Implementation | New Design Requirement |
|------------------------|------------------------|
| Uses legacy Props classes | Use domain types (Request, NetworkState) |
| Link-disjoint only | Support both link and node disjoint |
| Sets route_props directly | Return RouteResult |
| Integrated routing+allocation | Separate pipeline stages |
| No protection PathOption | PathOption with backup fields |

### 10. Patterns to Preserve

1. **Suurballe's algorithm** via `nx.edge_disjoint_paths` - proven robust
2. **Both-feasible requirement** - must validate both paths
3. **Configurable switchover latency** - operational parameter
4. **Metrics tracking** - success rate monitoring
5. **Environment validation** - edge connectivity check

### 11. Patterns to Evolve

1. **State dict to Request/PathOption** - use domain types
2. **route_props to RouteResult** - immutable result
3. **Coupled routing to Pipeline** - separate concerns
4. **Link-only to Link/Node** - configurable disjointness

---

## Verification

- [x] OnePlusOneProtection methods documented
- [x] OnePlusOnePolicy selection logic captured
- [x] SDN props protection fields identified
- [x] Failure handling pattern extracted
- [x] Gap analysis completed

---

## Next Task

Proceed to **P5.4.b** to design the ProtectionPipeline class.
