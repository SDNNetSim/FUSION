# Task ID: P5.4.f - Extend Lightpath Model

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Extend the `Lightpath` domain model with protection-related fields to support 1+1 dedicated protection.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.shared_context_protection_logic.md`
- `fusion/domain/lightpath.py` (existing Lightpath model)
- `.claude/v4-docs/migration/phase_5_ml_protection.md`

---

## Outputs

### 1. Current Lightpath Model (Reference)

```python
# Existing fields in fusion/domain/lightpath.py
@dataclass
class Lightpath:
    lightpath_id: str
    source: str
    destination: str
    path: list[str]
    spectrum_start: int
    spectrum_end: int
    modulation: str
    bandwidth_gbps: int
    created_at: float
    expires_at: float | None = None
```

### 2. Extended Lightpath Model

```python
"""
Lightpath domain model with protection support.

This module defines the Lightpath class representing an established
optical connection, extended with 1+1 protection fields.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    pass


class ActivePathState(Enum):
    """Which path is currently active for traffic."""

    PRIMARY = "primary"
    BACKUP = "backup"


@dataclass
class Lightpath:
    """
    Represents an established lightpath in the optical network.

    A lightpath is an end-to-end optical connection with allocated
    spectrum resources. For protected lightpaths, includes backup
    path and switchover state.

    Attributes:
        lightpath_id: Unique identifier
        source: Source node
        destination: Destination node
        path: Primary path (list of node IDs)
        spectrum_start: Starting slot index
        spectrum_end: Ending slot index (exclusive)
        modulation: Modulation format used
        bandwidth_gbps: Allocated bandwidth
        created_at: Creation timestamp
        expires_at: Expiration timestamp (None if permanent)

        # Protection fields (new)
        backup_path: Backup path for protection (None if unprotected)
        backup_modulation: Modulation format on backup path
        is_protected: Whether this is a protected lightpath
        active_path: Currently active path (primary or backup)

    Example:
        >>> # Unprotected lightpath
        >>> lp = Lightpath(
        ...     lightpath_id="lp-001",
        ...     source="A",
        ...     destination="D",
        ...     path=["A", "B", "C", "D"],
        ...     spectrum_start=10,
        ...     spectrum_end=16,
        ...     modulation="QPSK",
        ...     bandwidth_gbps=100,
        ...     created_at=0.0,
        ... )
        >>>
        >>> # Protected lightpath
        >>> protected_lp = Lightpath(
        ...     lightpath_id="lp-002",
        ...     source="A",
        ...     destination="D",
        ...     path=["A", "B", "D"],
        ...     spectrum_start=20,
        ...     spectrum_end=26,
        ...     modulation="QPSK",
        ...     bandwidth_gbps=100,
        ...     created_at=0.0,
        ...     backup_path=["A", "C", "D"],
        ...     backup_modulation="QPSK",
        ...     is_protected=True,
        ... )
    """

    # Core fields
    lightpath_id: str
    source: str
    destination: str
    path: list[str]
    spectrum_start: int
    spectrum_end: int
    modulation: str
    bandwidth_gbps: int
    created_at: float
    expires_at: float | None = None

    # Protection fields
    backup_path: list[str] | None = None
    backup_modulation: str | None = None
    is_protected: bool = False
    active_path: str = field(default="primary")

    def __post_init__(self) -> None:
        """Validate protection consistency."""
        if self.is_protected and self.backup_path is None:
            raise ValueError(
                "Protected lightpath must have a backup_path"
            )

        if self.backup_path is not None and not self.is_protected:
            # Auto-set is_protected if backup_path provided
            object.__setattr__(self, "is_protected", True)

    @property
    def current_path(self) -> list[str]:
        """
        Get the currently active path.

        Returns:
            Primary path or backup path based on active_path state
        """
        if self.is_protected and self.active_path == "backup":
            return self.backup_path
        return self.path

    @property
    def current_modulation(self) -> str:
        """
        Get modulation of the currently active path.

        Returns:
            Modulation format of active path
        """
        if self.is_protected and self.active_path == "backup":
            return self.backup_modulation or self.modulation
        return self.modulation

    @property
    def slots_used(self) -> int:
        """Number of spectrum slots allocated."""
        return self.spectrum_end - self.spectrum_start

    @property
    def hop_count(self) -> int:
        """Number of hops in primary path."""
        return len(self.path) - 1

    @property
    def backup_hop_count(self) -> int | None:
        """Number of hops in backup path (None if unprotected)."""
        if self.backup_path is None:
            return None
        return len(self.backup_path) - 1

    def switch_to_backup(self) -> None:
        """
        Switch to backup path.

        Raises:
            ValueError: If lightpath is not protected
        """
        if not self.is_protected:
            raise ValueError("Cannot switch unprotected lightpath")

        if self.active_path == "backup":
            return  # Already on backup

        self.active_path = "backup"

    def switch_to_primary(self) -> None:
        """
        Switch back to primary path.

        Raises:
            ValueError: If lightpath is not protected
        """
        if not self.is_protected:
            raise ValueError("Cannot switch unprotected lightpath")

        if self.active_path == "primary":
            return  # Already on primary

        self.active_path = "primary"

    def contains_link(self, link: tuple[str, str]) -> bool:
        """
        Check if current path contains the given link.

        Args:
            link: Link as (node_a, node_b) tuple

        Returns:
            True if current path traverses the link
        """
        path = self.current_path
        for i in range(len(path) - 1):
            edge = (path[i], path[i + 1])
            if edge == link or edge == (link[1], link[0]):
                return True
        return False

    def contains_node(self, node: str) -> bool:
        """
        Check if current path traverses the given node.

        Args:
            node: Node identifier

        Returns:
            True if current path traverses the node
        """
        return node in self.current_path

    def get_links(self) -> list[tuple[str, str]]:
        """
        Get all links in the current path.

        Returns:
            List of (node_a, node_b) tuples
        """
        path = self.current_path
        return [(path[i], path[i + 1]) for i in range(len(path) - 1)]

    def get_all_links(self) -> list[tuple[str, str]]:
        """
        Get all links in both primary and backup paths.

        Returns:
            List of unique links from both paths
        """
        links = self.get_links()

        if self.is_protected and self.backup_path:
            for i in range(len(self.backup_path) - 1):
                link = (self.backup_path[i], self.backup_path[i + 1])
                if link not in links:
                    links.append(link)

        return links

    def to_dict(self) -> dict:
        """Convert to dictionary representation."""
        return {
            "lightpath_id": self.lightpath_id,
            "source": self.source,
            "destination": self.destination,
            "path": self.path,
            "spectrum_start": self.spectrum_start,
            "spectrum_end": self.spectrum_end,
            "modulation": self.modulation,
            "bandwidth_gbps": self.bandwidth_gbps,
            "created_at": self.created_at,
            "expires_at": self.expires_at,
            "backup_path": self.backup_path,
            "backup_modulation": self.backup_modulation,
            "is_protected": self.is_protected,
            "active_path": self.active_path,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Lightpath":
        """Create Lightpath from dictionary."""
        return cls(**data)


@dataclass
class LightpathBuilder:
    """
    Builder for creating Lightpath instances.

    Provides a fluent interface for constructing lightpaths,
    especially useful for protected lightpaths.

    Example:
        >>> lp = (
        ...     LightpathBuilder("lp-001")
        ...     .source("A")
        ...     .destination("D")
        ...     .path(["A", "B", "D"])
        ...     .spectrum(10, 16)
        ...     .modulation("QPSK")
        ...     .bandwidth(100)
        ...     .created_at(0.0)
        ...     .with_protection(["A", "C", "D"], "QPSK")
        ...     .build()
        ... )
    """

    _lightpath_id: str
    _source: str | None = None
    _destination: str | None = None
    _path: list[str] | None = None
    _spectrum_start: int | None = None
    _spectrum_end: int | None = None
    _modulation: str | None = None
    _bandwidth_gbps: int | None = None
    _created_at: float | None = None
    _expires_at: float | None = None
    _backup_path: list[str] | None = None
    _backup_modulation: str | None = None

    def source(self, source: str) -> "LightpathBuilder":
        self._source = source
        return self

    def destination(self, destination: str) -> "LightpathBuilder":
        self._destination = destination
        return self

    def path(self, path: list[str]) -> "LightpathBuilder":
        self._path = path
        return self

    def spectrum(self, start: int, end: int) -> "LightpathBuilder":
        self._spectrum_start = start
        self._spectrum_end = end
        return self

    def modulation(self, modulation: str) -> "LightpathBuilder":
        self._modulation = modulation
        return self

    def bandwidth(self, bandwidth_gbps: int) -> "LightpathBuilder":
        self._bandwidth_gbps = bandwidth_gbps
        return self

    def created_at(self, timestamp: float) -> "LightpathBuilder":
        self._created_at = timestamp
        return self

    def expires_at(self, timestamp: float) -> "LightpathBuilder":
        self._expires_at = timestamp
        return self

    def with_protection(
        self,
        backup_path: list[str],
        backup_modulation: str | None = None,
    ) -> "LightpathBuilder":
        """Add protection with backup path."""
        self._backup_path = backup_path
        self._backup_modulation = backup_modulation or self._modulation
        return self

    def build(self) -> Lightpath:
        """Build the Lightpath instance."""
        if self._path is None:
            raise ValueError("path is required")
        if self._spectrum_start is None or self._spectrum_end is None:
            raise ValueError("spectrum range is required")
        if self._modulation is None:
            raise ValueError("modulation is required")
        if self._bandwidth_gbps is None:
            raise ValueError("bandwidth_gbps is required")
        if self._created_at is None:
            raise ValueError("created_at is required")

        return Lightpath(
            lightpath_id=self._lightpath_id,
            source=self._source or self._path[0],
            destination=self._destination or self._path[-1],
            path=self._path,
            spectrum_start=self._spectrum_start,
            spectrum_end=self._spectrum_end,
            modulation=self._modulation,
            bandwidth_gbps=self._bandwidth_gbps,
            created_at=self._created_at,
            expires_at=self._expires_at,
            backup_path=self._backup_path,
            backup_modulation=self._backup_modulation,
            is_protected=self._backup_path is not None,
        )
```

### 3. Extended RouteResult

```python
@dataclass(frozen=True)
class RouteResult:
    """
    Result of route computation.

    Extended with backup path fields for protection.
    """

    paths: list[list[str]]
    modulations: list[list[str | None]]
    weights_km: list[float]
    strategy_name: str = ""

    # Protection fields
    backup_paths: list[list[str]] | None = None
    backup_modulations: list[list[str | None]] | None = None
    backup_weights_km: list[float] | None = None

    @property
    def has_protection(self) -> bool:
        """Check if result includes backup paths."""
        return self.backup_paths is not None and len(self.backup_paths) > 0

    def get_path_pair(self, index: int) -> tuple[list[str], list[str] | None]:
        """Get primary and backup path at index."""
        primary = self.paths[index] if index < len(self.paths) else None
        backup = None
        if self.backup_paths and index < len(self.backup_paths):
            backup = self.backup_paths[index]
        return primary, backup
```

### 4. NetworkState Extension

```python
# Additional methods for NetworkState

class NetworkState:
    def create_protected_lightpath(
        self,
        lightpath_id: str,
        primary_path: list[str],
        backup_path: list[str],
        spectrum_start: int,
        spectrum_end: int,
        modulation: str,
        backup_modulation: str,
        bandwidth_gbps: int,
        created_at: float,
        expires_at: float | None = None,
    ) -> Lightpath:
        """
        Create and register a protected lightpath.

        Allocates spectrum on both primary and backup paths.
        """
        lightpath = Lightpath(
            lightpath_id=lightpath_id,
            source=primary_path[0],
            destination=primary_path[-1],
            path=primary_path,
            spectrum_start=spectrum_start,
            spectrum_end=spectrum_end,
            modulation=modulation,
            bandwidth_gbps=bandwidth_gbps,
            created_at=created_at,
            expires_at=expires_at,
            backup_path=backup_path,
            backup_modulation=backup_modulation,
            is_protected=True,
        )

        self._lightpaths[lightpath_id] = lightpath
        return lightpath

    def get_lightpaths_on_link(
        self,
        link: tuple[str, str],
    ) -> list[Lightpath]:
        """Get all lightpaths with current path traversing link."""
        affected = []
        for lp in self._lightpaths.values():
            if lp.contains_link(link):
                affected.append(lp)
        return affected

    def get_protected_lightpaths(self) -> list[Lightpath]:
        """Get all protected lightpaths."""
        return [lp for lp in self._lightpaths.values() if lp.is_protected]
```

---

## Verification

- [ ] Lightpath stores backup_path correctly
- [ ] is_protected auto-set when backup_path provided
- [ ] current_path returns correct path based on active_path
- [ ] switch_to_backup/switch_to_primary work correctly
- [ ] contains_link checks current path
- [ ] LightpathBuilder creates protected lightpaths
- [ ] RouteResult includes backup path fields

---

## Test Cases to Implement

```python
class TestLightpathProtection:
    """Tests for Lightpath protection fields."""

    def test_unprotected_lightpath(self) -> None:
        """Unprotected lightpath has no backup."""
        lp = Lightpath(
            lightpath_id="lp-001",
            source="A",
            destination="D",
            path=["A", "B", "D"],
            spectrum_start=10,
            spectrum_end=16,
            modulation="QPSK",
            bandwidth_gbps=100,
            created_at=0.0,
        )

        assert not lp.is_protected
        assert lp.backup_path is None
        assert lp.current_path == ["A", "B", "D"]

    def test_protected_lightpath(self) -> None:
        """Protected lightpath has backup path."""
        lp = Lightpath(
            lightpath_id="lp-002",
            source="A",
            destination="D",
            path=["A", "B", "D"],
            spectrum_start=10,
            spectrum_end=16,
            modulation="QPSK",
            bandwidth_gbps=100,
            created_at=0.0,
            backup_path=["A", "C", "D"],
            is_protected=True,
        )

        assert lp.is_protected
        assert lp.backup_path == ["A", "C", "D"]
        assert lp.active_path == "primary"
        assert lp.current_path == ["A", "B", "D"]

    def test_switch_to_backup(self) -> None:
        """Should switch to backup path."""
        lp = Lightpath(
            lightpath_id="lp-003",
            source="A",
            destination="D",
            path=["A", "B", "D"],
            spectrum_start=10,
            spectrum_end=16,
            modulation="QPSK",
            bandwidth_gbps=100,
            created_at=0.0,
            backup_path=["A", "C", "D"],
            is_protected=True,
        )

        lp.switch_to_backup()

        assert lp.active_path == "backup"
        assert lp.current_path == ["A", "C", "D"]

    def test_builder_with_protection(self) -> None:
        """Builder should create protected lightpath."""
        lp = (
            LightpathBuilder("lp-004")
            .path(["A", "B", "D"])
            .spectrum(10, 16)
            .modulation("QPSK")
            .bandwidth(100)
            .created_at(0.0)
            .with_protection(["A", "C", "D"])
            .build()
        )

        assert lp.is_protected
        assert lp.backup_path == ["A", "C", "D"]
```

---

## Next Task

Proceed to **P5.4.g** to implement the complete ProtectionPipeline.
