# Task ID: P5.4.e - Design Failure Handling Mechanism

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the failure detection and switchover mechanism for 1+1 dedicated protection, enabling fast recovery when the primary path fails.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.b_design_protection_pipeline.md`
- `fusion/modules/routing/one_plus_one_protection.py` (handle_failure method)

---

## Outputs

### 1. Failure Handling Overview

```
1+1 Protection Switchover Process
=================================

Normal Operation:
  Primary Path:  A ──► B ──► D  [ACTIVE]
  Backup Path:   A ──► C ──► D  [STANDBY]

Link B-D Fails:
  1. Failure detected (signal loss)
  2. Switchover triggered
  3. Receiver switches to backup signal
  4. Recovery time: ~50ms

After Switchover:
  Primary Path:  A ──► B ──X D  [FAILED]
  Backup Path:   A ──► C ──► D  [ACTIVE]
```

### 2. FailureHandler Class Design

```python
"""
Failure handling for 1+1 dedicated protection.

This module provides failure detection and switchover mechanisms
for protected lightpaths.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.domain.lightpath import Lightpath
    from fusion.domain.network_state import NetworkState

logger = logging.getLogger(__name__)


class FailureType(Enum):
    """Type of network failure."""

    LINK = "link"
    NODE = "node"
    SRLG = "srlg"  # Shared Risk Link Group


class ActivePath(Enum):
    """Which path is currently active."""

    PRIMARY = "primary"
    BACKUP = "backup"


@dataclass(frozen=True)
class FailureEvent:
    """
    Represents a network failure event.

    Attributes:
        failure_type: Type of failure (link, node, srlg)
        failed_element: The failed element (link tuple or node id)
        timestamp: When failure occurred
    """

    failure_type: FailureType
    failed_element: tuple[str, str] | str
    timestamp: float


@dataclass(frozen=True)
class SwitchoverAction:
    """
    Record of a protection switchover action.

    Attributes:
        lightpath_id: ID of affected lightpath
        from_path: Path switched from
        to_path: Path switched to
        latency_ms: Switchover latency
        timestamp: When switchover occurred
    """

    lightpath_id: str
    from_path: str
    to_path: str
    latency_ms: float
    timestamp: float


@dataclass
class RecoveryResult:
    """
    Result of failure recovery.

    Attributes:
        failure: The failure event
        switchovers: List of switchover actions
        lost_lightpaths: Lightpaths that could not be recovered
        recovery_time_ms: Total recovery time
    """

    failure: FailureEvent
    switchovers: list[SwitchoverAction] = field(default_factory=list)
    lost_lightpaths: list[str] = field(default_factory=list)
    recovery_time_ms: float = 0.0


class FailureHandler:
    """
    Handle network failures and trigger protection switchovers.

    Detects which lightpaths are affected by a failure and
    switches protected lightpaths to their backup paths.

    Attributes:
        switchover_time_ms: Time for protection switchover
        revert_after_repair: Whether to revert to primary after repair

    Example:
        >>> handler = FailureHandler(switchover_time_ms=50.0)
        >>> result = handler.handle_link_failure(
        ...     failed_link=("B", "D"),
        ...     network_state=network_state,
        ...     current_time=100.0,
        ... )
        >>> for action in result.switchovers:
        ...     print(f"Switched {action.lightpath_id} to backup")
    """

    def __init__(
        self,
        switchover_time_ms: float = 50.0,
        revert_after_repair: bool = False,
    ) -> None:
        """
        Initialize failure handler.

        Args:
            switchover_time_ms: Protection switchover latency
            revert_after_repair: Revert to primary after repair
        """
        self.switchover_time_ms = switchover_time_ms
        self.revert_after_repair = revert_after_repair

        # Statistics
        self._total_failures = 0
        self._successful_switchovers = 0
        self._lost_lightpaths = 0

    def handle_link_failure(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
        current_time: float,
    ) -> RecoveryResult:
        """
        Handle a link failure event.

        Identifies affected lightpaths and switches protected ones
        to their backup paths.

        Args:
            failed_link: The failed link (node_a, node_b)
            network_state: Current network state
            current_time: Current simulation time

        Returns:
            RecoveryResult with switchover details
        """
        self._total_failures += 1

        failure = FailureEvent(
            failure_type=FailureType.LINK,
            failed_element=failed_link,
            timestamp=current_time,
        )

        # Find affected lightpaths
        affected = self._find_affected_lightpaths(
            failed_link, network_state
        )

        switchovers = []
        lost = []

        for lightpath in affected:
            if self._can_switchover(lightpath, failed_link):
                action = self._perform_switchover(
                    lightpath, current_time, network_state
                )
                switchovers.append(action)
                self._successful_switchovers += 1
            else:
                lost.append(lightpath.lightpath_id)
                self._lost_lightpaths += 1

        recovery_time = self.switchover_time_ms if switchovers else 0.0

        return RecoveryResult(
            failure=failure,
            switchovers=switchovers,
            lost_lightpaths=lost,
            recovery_time_ms=recovery_time,
        )

    def handle_node_failure(
        self,
        failed_node: str,
        network_state: NetworkState,
        current_time: float,
    ) -> RecoveryResult:
        """
        Handle a node failure event.

        For node failures, all links connected to the node fail.
        Protected lightpaths can only survive if using node-disjoint
        backup paths.

        Args:
            failed_node: The failed node identifier
            network_state: Current network state
            current_time: Current simulation time

        Returns:
            RecoveryResult with switchover details
        """
        self._total_failures += 1

        failure = FailureEvent(
            failure_type=FailureType.NODE,
            failed_element=failed_node,
            timestamp=current_time,
        )

        # Find all lightpaths traversing the failed node
        affected = self._find_lightpaths_through_node(
            failed_node, network_state
        )

        switchovers = []
        lost = []

        for lightpath in affected:
            if self._can_switchover_node_failure(lightpath, failed_node):
                action = self._perform_switchover(
                    lightpath, current_time, network_state
                )
                switchovers.append(action)
                self._successful_switchovers += 1
            else:
                lost.append(lightpath.lightpath_id)
                self._lost_lightpaths += 1

        recovery_time = self.switchover_time_ms if switchovers else 0.0

        return RecoveryResult(
            failure=failure,
            switchovers=switchovers,
            lost_lightpaths=lost,
            recovery_time_ms=recovery_time,
        )

    def handle_repair(
        self,
        repaired_element: tuple[str, str] | str,
        network_state: NetworkState,
        current_time: float,
    ) -> list[SwitchoverAction]:
        """
        Handle repair event (optional revert to primary).

        If revert_after_repair is enabled, switches lightpaths
        back to their primary paths.

        Args:
            repaired_element: The repaired link or node
            network_state: Current network state
            current_time: Current simulation time

        Returns:
            List of reversion actions
        """
        if not self.revert_after_repair:
            return []

        reversions = []

        for lightpath in network_state.active_lightpaths:
            if self._should_revert(lightpath, repaired_element):
                action = SwitchoverAction(
                    lightpath_id=lightpath.lightpath_id,
                    from_path="backup",
                    to_path="primary",
                    latency_ms=self.switchover_time_ms,
                    timestamp=current_time,
                )
                lightpath.active_path = ActivePath.PRIMARY.value
                reversions.append(action)

        return reversions

    def _find_affected_lightpaths(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
    ) -> list[Lightpath]:
        """Find lightpaths using the failed link on their active path."""
        affected = []

        for lightpath in network_state.active_lightpaths:
            current_path = lightpath.current_path
            if self._path_contains_link(current_path, failed_link):
                affected.append(lightpath)

        return affected

    def _find_lightpaths_through_node(
        self,
        failed_node: str,
        network_state: NetworkState,
    ) -> list[Lightpath]:
        """Find lightpaths with active path through failed node."""
        affected = []

        for lightpath in network_state.active_lightpaths:
            current_path = lightpath.current_path
            # Check intermediate nodes (not source/destination)
            if failed_node in current_path[1:-1]:
                affected.append(lightpath)

        return affected

    def _can_switchover(
        self,
        lightpath: Lightpath,
        failed_link: tuple[str, str],
    ) -> bool:
        """
        Check if lightpath can switch to backup.

        Switchover is possible if:
        1. Lightpath is protected
        2. Currently on primary
        3. Backup path doesn't contain the failed link
        """
        if not lightpath.is_protected:
            return False

        if lightpath.active_path != "primary":
            # Already on backup, no further recovery
            return False

        # Check backup doesn't contain failed link
        return not self._path_contains_link(
            lightpath.backup_path, failed_link
        )

    def _can_switchover_node_failure(
        self,
        lightpath: Lightpath,
        failed_node: str,
    ) -> bool:
        """
        Check if lightpath can switch on node failure.

        Only possible with node-disjoint backup path.
        """
        if not lightpath.is_protected:
            return False

        if lightpath.active_path != "primary":
            return False

        # Check backup doesn't traverse failed node
        backup = lightpath.backup_path
        return failed_node not in backup[1:-1]

    def _perform_switchover(
        self,
        lightpath: Lightpath,
        current_time: float,
        network_state: NetworkState,
    ) -> SwitchoverAction:
        """Execute switchover and record action."""
        action = SwitchoverAction(
            lightpath_id=lightpath.lightpath_id,
            from_path="primary",
            to_path="backup",
            latency_ms=self.switchover_time_ms,
            timestamp=current_time,
        )

        # Update lightpath state
        lightpath.active_path = ActivePath.BACKUP.value

        logger.info(
            f"Switchover: {lightpath.lightpath_id} "
            f"primary -> backup ({self.switchover_time_ms}ms)"
        )

        return action

    def _path_contains_link(
        self,
        path: list[str],
        link: tuple[str, str],
    ) -> bool:
        """Check if path contains the given link."""
        if path is None:
            return False

        for i in range(len(path) - 1):
            edge = (path[i], path[i + 1])
            if edge == link or edge == (link[1], link[0]):
                return True

        return False

    def _should_revert(
        self,
        lightpath: Lightpath,
        repaired_element: tuple[str, str] | str,
    ) -> bool:
        """Check if lightpath should revert to primary after repair."""
        if not lightpath.is_protected:
            return False

        if lightpath.active_path != "backup":
            return False

        # Check if primary path would now work
        if isinstance(repaired_element, tuple):
            # Link repair - check if primary contains the link
            return self._path_contains_link(
                lightpath.path, repaired_element
            )
        else:
            # Node repair - check if primary traverses the node
            return repaired_element in lightpath.path[1:-1]

    def get_metrics(self) -> dict[str, any]:
        """Get failure handling metrics."""
        success_rate = (
            self._successful_switchovers / self._total_failures
            if self._total_failures > 0
            else 1.0
        )

        return {
            "total_failures": self._total_failures,
            "successful_switchovers": self._successful_switchovers,
            "lost_lightpaths": self._lost_lightpaths,
            "switchover_success_rate": success_rate,
            "switchover_time_ms": self.switchover_time_ms,
            "revert_after_repair": self.revert_after_repair,
        }

    def reset_metrics(self) -> None:
        """Reset all metrics."""
        self._total_failures = 0
        self._successful_switchovers = 0
        self._lost_lightpaths = 0
```

### 3. Failure Scenarios

| Scenario | Primary Affected | Backup Affected | Outcome |
|----------|------------------|-----------------|---------|
| Single link, link-disjoint | Yes | No | Switchover succeeds |
| Single link, both paths | Yes | Yes | Lightpath lost |
| Single node, node-disjoint | Yes | No | Switchover succeeds |
| Single node, link-disjoint | Yes | Maybe | Depends on topology |
| Dual failure | Yes | Yes | Lightpath lost |

### 4. Integration with ProtectionPipeline

```python
class ProtectionPipeline:
    def __init__(self, config: ProtectionConfig) -> None:
        self.config = config
        self._failure_handler = FailureHandler(
            switchover_time_ms=config.switchover_time_ms,
            revert_after_repair=config.revert_after_repair,
        )

    def handle_failure(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
        current_time: float,
    ) -> RecoveryResult:
        """Handle failure using internal handler."""
        return self._failure_handler.handle_link_failure(
            failed_link, network_state, current_time
        )
```

### 5. Event Integration

```python
# In simulation event loop
def process_failure_event(event: FailureEvent, sim_state: SimulationState):
    """Process a failure event in the simulation."""
    handler = sim_state.protection_pipeline._failure_handler

    if event.failure_type == FailureType.LINK:
        result = handler.handle_link_failure(
            event.failed_element,
            sim_state.network_state,
            event.timestamp,
        )
    elif event.failure_type == FailureType.NODE:
        result = handler.handle_node_failure(
            event.failed_element,
            sim_state.network_state,
            event.timestamp,
        )

    # Record metrics
    sim_state.metrics.record_failure(result)

    return result
```

---

## Verification

- [ ] Link failures trigger switchover for affected lightpaths
- [ ] Node failures handled correctly
- [ ] Unprotected lightpaths marked as lost
- [ ] Backup path verified not affected before switchover
- [ ] Switchover latency recorded correctly
- [ ] Revert-after-repair works when enabled
- [ ] Metrics track success/failure rates

---

## Test Cases to Implement

```python
class TestFailureHandler:
    """Tests for FailureHandler."""

    def test_link_failure_switchover(self) -> None:
        """Should switch protected lightpath to backup on link failure."""
        handler = FailureHandler(switchover_time_ms=50.0)

        result = handler.handle_link_failure(
            failed_link=("B", "D"),
            network_state=state_with_protected_lightpath,
            current_time=100.0,
        )

        assert len(result.switchovers) == 1
        assert result.switchovers[0].to_path == "backup"
        assert result.recovery_time_ms == 50.0

    def test_unprotected_lightpath_lost(self) -> None:
        """Should mark unprotected lightpath as lost."""
        handler = FailureHandler()

        result = handler.handle_link_failure(
            failed_link=("A", "B"),
            network_state=state_with_unprotected_lightpath,
            current_time=100.0,
        )

        assert len(result.lost_lightpaths) == 1
        assert len(result.switchovers) == 0

    def test_node_failure_node_disjoint(self) -> None:
        """Should survive node failure with node-disjoint backup."""
        handler = FailureHandler()

        result = handler.handle_node_failure(
            failed_node="B",
            network_state=state_with_node_disjoint,
            current_time=100.0,
        )

        assert len(result.switchovers) == 1

    def test_revert_after_repair(self) -> None:
        """Should revert to primary after repair when enabled."""
        handler = FailureHandler(
            switchover_time_ms=50.0,
            revert_after_repair=True,
        )

        # First: failure and switchover
        handler.handle_link_failure(("B", "D"), state, 100.0)

        # Then: repair
        reversions = handler.handle_repair(("B", "D"), state, 200.0)

        assert len(reversions) == 1
        assert reversions[0].to_path == "primary"
```

---

## Next Task

Proceed to **P5.4.f** to extend the Lightpath model with protection fields.
