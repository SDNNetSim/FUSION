# P5.4 Shared Context: Protection Logic

**Sub-phase:** P5.4
**Scope:** 1+1 Dedicated Path Protection

---

## Overview

This document captures the shared context for 1+1 dedicated path protection implementation. All micro-tasks in P5.4 should reference this context.

---

## 1+1 Protection Fundamentals

### Definition

1+1 dedicated protection allocates resources on TWO disjoint paths simultaneously:
- **Primary path**: Normal traffic transmission
- **Backup path**: Standby for failover

Traffic is transmitted on both paths. The receiver monitors the primary signal and switches to backup upon failure detection.

### Key Properties

| Property | Value |
|----------|-------|
| Protection type | Dedicated (1+1) |
| Spectrum usage | Dual allocation |
| Switchover trigger | Signal loss detection |
| Recovery time | Configurable (default 50ms) |
| Disjointness | Link or Node |

---

## Disjointness Types

### Link-Disjoint

Paths share no common links but may share intermediate nodes.

```
Example:
Primary:  A -- B -- C -- D
Backup:   A -- E -- F -- D

Shared nodes: A, D (source/destination)
Shared links: None
```

### Node-Disjoint

Paths share no common intermediate nodes (stronger protection).

```
Example:
Primary:  A -- B -- C -- D
Backup:   A -- E -- F -- D

Shared nodes: A, D (source/destination only)
Shared intermediate nodes: None
```

---

## Existing Implementation Reference

### OnePlusOneProtection Router

Located at `fusion/modules/routing/one_plus_one_protection.py`:

```python
# Key method: find_all_disjoint_paths
def find_all_disjoint_paths(self, source, destination) -> list[list[int]]:
    """Uses nx.edge_disjoint_paths (Suurballe's algorithm)."""
    paths = list(nx.edge_disjoint_paths(
        self.topology, source, destination
    ))
    return [list(path) for path in paths]

# Route method selects FIRST feasible pair
def route(self, source, destination, request):
    all_disjoint_paths = self.find_all_disjoint_paths(source, destination)

    # Try pairs until both paths are feasible
    for i in range(len(all_disjoint_paths)):
        for j in range(i + 1, len(all_disjoint_paths)):
            primary_mods = self._get_modulation_formats_for_path(all_disjoint_paths[i])
            backup_mods = self._get_modulation_formats_for_path(all_disjoint_paths[j])

            if any(primary_mods) and any(backup_mods):
                # Found feasible pair
                ...
```

### OnePlusOnePolicy

Located at `fusion/modules/rl/policies/one_plus_one_policy.py`:

```python
class OnePlusOnePolicy(PathPolicy):
    """1+1 policy: use primary if feasible, else backup."""

    def select_path(self, state, action_mask) -> int:
        # Try primary (index 0) first
        if action_mask[0]:
            return 0
        # Fall back to backup (index 1)
        if len(action_mask) > 1 and action_mask[1]:
            return 1
        return -1
```

---

## Protection Data Structures

### SDNProps Protection Fields

```python
# Set by OnePlusOneProtection.route()
sdn_props.primary_path = [0, 1, 2, 5]
sdn_props.backup_path = [0, 3, 4, 5]
sdn_props.is_protected = True
sdn_props.active_path = "primary"  # or "backup"
```

### RouteProps Backup Fields

```python
route_props.paths_matrix = [[0, 1, 2, 5]]           # Primary
route_props.backup_paths_matrix = [[0, 3, 4, 5]]    # Backup
route_props.modulation_formats_matrix = [["QPSK"]]  # Primary mods
route_props.backup_modulation_formats_matrix = [["QPSK"]]  # Backup mods
```

---

## Spectrum Allocation for 1+1

### Allocation Strategy

For 1+1 protection, the SAME spectrum slots are allocated on BOTH paths:

```
Primary path (A-B-C-D):
  Link A-B: slots [10-15]
  Link B-C: slots [10-15]
  Link C-D: slots [10-15]

Backup path (A-E-F-D):
  Link A-E: slots [10-15]
  Link E-F: slots [10-15]
  Link F-D: slots [10-15]
```

### Why Same Slots?

1. **Simpler switchover**: Receiver doesn't need to retune
2. **Faster recovery**: No spectrum reconfiguration needed
3. **Trade-off**: Higher spectrum usage (2x resources)

---

## Failure Handling

### Detection

Failure detected via:
- Signal loss (optical power drop)
- BER threshold exceeded
- SNR degradation

### Switchover Process

```
1. Failure detected on primary path
2. Receiver switches to backup signal
3. Switchover latency: ~50ms (configurable)
4. Traffic continues on backup
5. Optional: Revert to primary after repair
```

### Recovery Metrics

```python
# From OnePlusOneProtection.handle_failure()
recovery_actions.append({
    "request_id": request["id"],
    "action": "switchover",
    "recovery_time_ms": self.protection_switchover_ms,
    "from_path": "primary",
    "to_path": "backup",
})
```

---

## Configuration Options

### Current Config (engine_props)

```python
protection_settings = {
    "protection_switchover_ms": 50.0,
    "revert_to_primary": False,
}
```

### Target Config (SimulationConfig)

```ini
[protection]
enabled = true
disjointness = link          ; link or node
switchover_time_ms = 50
revert_after_repair = false
```

---

## PathOption Extension for Protection

From P5.1 design, PathOption includes protection fields:

```python
@dataclass(frozen=True)
class PathOption:
    path_index: int
    path: tuple[str, ...]
    weight_km: float
    is_feasible: bool
    modulation: str | None
    slots_needed: int | None
    congestion: float
    # Protection fields
    backup_path: tuple[str, ...] | None = None
    backup_feasible: bool | None = None
    is_protected: bool = False

    @property
    def both_paths_feasible(self) -> bool:
        """Check if both primary and backup are feasible."""
        if not self.is_protected:
            return self.is_feasible
        return self.is_feasible and (self.backup_feasible is True)
```

---

## Integration Points

### With RoutingPipeline

```python
# ProtectionPipeline implements RoutingPipeline interface
class ProtectionPipeline:
    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> RouteResult:
        ...
```

### With SpectrumAssignment

```python
# Must allocate on both paths
result = spectrum_assigner.assign(
    primary_path=route.paths[0],
    backup_path=route.backup_paths[0],
    slots_needed=slots,
    network_state=network_state,
)
```

### With Orchestrator

```python
# Orchestrator checks protection status
if config.protection_enabled:
    routes = protection_pipeline.find_protected_routes(...)
else:
    routes = routing_pipeline.find_routes(...)
```

---

## Edge Cases

1. **No disjoint paths exist**: Block request (return empty RouteResult)
2. **Primary feasible, backup infeasible**: Block (need both for 1+1)
3. **Both paths fail**: Request terminated (no further backup)
4. **Spectrum available on primary only**: Block (need both)
5. **Node failure in node-disjoint**: Backup survives
6. **Node failure in link-disjoint**: May affect both paths

---

## References

- `fusion/modules/routing/one_plus_one_protection.py`
- `fusion/modules/rl/policies/one_plus_one_policy.py`
- `fusion/modules/routing/tests/test_one_plus_one_protection.py`
- `.claude/v4-docs/migration/phase_5_ml_protection.md`
