# Task ID: P5.4.c - Design DisjointPathFinder

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the `DisjointPathFinder` class that implements algorithms for finding link-disjoint and node-disjoint path pairs for 1+1 protection.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.b_design_protection_pipeline.md`
- `fusion/modules/routing/one_plus_one_protection.py` (find_all_disjoint_paths method)

---

## Outputs

### 1. Disjoint Path Algorithms Background

#### Link-Disjoint Paths

Two paths are **link-disjoint** if they share no common edges:
- Can share intermediate nodes
- Protects against single link failures
- Uses `nx.edge_disjoint_paths` (Suurballe's algorithm)

#### Node-Disjoint Paths

Two paths are **node-disjoint** if they share no common intermediate nodes:
- Stronger protection than link-disjoint
- Protects against single node failures
- Uses `nx.node_disjoint_paths`

### 2. DisjointPathFinder Class Design

```python
"""
Disjoint path finding for 1+1 protection.

This module provides algorithms for finding link-disjoint and node-disjoint
path pairs using NetworkX graph algorithms.
"""

from __future__ import annotations

import logging
from enum import Enum
from typing import TYPE_CHECKING

import networkx as nx

if TYPE_CHECKING:
    pass

logger = logging.getLogger(__name__)


class DisjointnessType(Enum):
    """Type of path disjointness."""

    LINK = "link"
    NODE = "node"


class DisjointPathFinder:
    """
    Find disjoint paths for protection routing.

    Implements link-disjoint and node-disjoint path finding using
    NetworkX algorithms (Suurballe's algorithm for edge-disjoint,
    node-disjoint variant for node separation).

    Attributes:
        disjointness: Type of disjointness (link or node)

    Example:
        >>> finder = DisjointPathFinder(DisjointnessType.LINK)
        >>> paths = finder.find_all_disjoint_paths(topology, "A", "D")
        >>> print(paths)
        [['A', 'B', 'D'], ['A', 'C', 'D']]
    """

    def __init__(self, disjointness: DisjointnessType = DisjointnessType.LINK) -> None:
        """
        Initialize disjoint path finder.

        Args:
            disjointness: Type of disjointness to enforce
        """
        self.disjointness = disjointness

    def find_all_disjoint_paths(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> list[list[str]]:
        """
        Find all disjoint paths between source and destination.

        Uses max-flow based algorithms to find the maximum set of
        disjoint paths.

        Args:
            topology: Network topology graph
            source: Source node identifier
            destination: Destination node identifier

        Returns:
            List of disjoint paths (may be empty if none exist)

        Example:
            >>> paths = finder.find_all_disjoint_paths(G, "A", "D")
            >>> # Paths are guaranteed disjoint by type
        """
        try:
            if self.disjointness == DisjointnessType.LINK:
                return self._find_edge_disjoint_paths(topology, source, destination)
            else:
                return self._find_node_disjoint_paths(topology, source, destination)
        except (nx.NetworkXNoPath, nx.NetworkXError) as e:
            logger.debug(f"No disjoint paths {source} -> {destination}: {e}")
            return []

    def _find_edge_disjoint_paths(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> list[list[str]]:
        """
        Find all edge-disjoint (link-disjoint) paths.

        Uses NetworkX's edge_disjoint_paths which implements
        Suurballe's algorithm for optimal disjoint path finding.

        Args:
            topology: Network topology
            source: Source node
            destination: Destination node

        Returns:
            List of edge-disjoint paths
        """
        paths = list(
            nx.edge_disjoint_paths(
                topology,
                source,
                destination,
                flow_func=None,  # Default: shortest augmenting path
            )
        )
        return [list(path) for path in paths]

    def _find_node_disjoint_paths(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> list[list[str]]:
        """
        Find all node-disjoint paths.

        Uses NetworkX's node_disjoint_paths which implements
        a max-flow based algorithm on the node-split graph.

        Args:
            topology: Network topology
            source: Source node
            destination: Destination node

        Returns:
            List of node-disjoint paths
        """
        paths = list(
            nx.node_disjoint_paths(
                topology,
                source,
                destination,
            )
        )
        return [list(path) for path in paths]

    def find_disjoint_pair(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> tuple[list[str] | None, list[str] | None]:
        """
        Find a single disjoint path pair.

        Convenience method that returns the first two disjoint paths
        found, suitable for simple 1+1 protection scenarios.

        Args:
            topology: Network topology
            source: Source node
            destination: Destination node

        Returns:
            Tuple of (primary_path, backup_path), or (None, None) if
            fewer than 2 disjoint paths exist

        Example:
            >>> primary, backup = finder.find_disjoint_pair(G, "A", "D")
            >>> if primary and backup:
            ...     print("Protection available")
        """
        all_paths = self.find_all_disjoint_paths(topology, source, destination)

        if len(all_paths) >= 2:
            return all_paths[0], all_paths[1]

        return None, None

    def verify_disjointness(
        self,
        path1: list[str],
        path2: list[str],
    ) -> bool:
        """
        Verify that two paths are disjoint according to configured type.

        Args:
            path1: First path
            path2: Second path

        Returns:
            True if paths are disjoint, False otherwise

        Example:
            >>> finder = DisjointPathFinder(DisjointnessType.LINK)
            >>> finder.verify_disjointness(["A","B","D"], ["A","C","D"])
            True
        """
        if self.disjointness == DisjointnessType.LINK:
            return self._verify_edge_disjoint(path1, path2)
        else:
            return self._verify_node_disjoint(path1, path2)

    def _verify_edge_disjoint(
        self,
        path1: list[str],
        path2: list[str],
    ) -> bool:
        """Verify paths share no common edges."""
        edges1 = self._get_edges(path1)
        edges2 = self._get_edges(path2)

        # Check both directions for undirected graph
        for edge in edges1:
            if edge in edges2 or (edge[1], edge[0]) in edges2:
                return False

        return True

    def _verify_node_disjoint(
        self,
        path1: list[str],
        path2: list[str],
    ) -> bool:
        """Verify paths share no common intermediate nodes."""
        # Intermediate nodes (exclude source/destination)
        intermediate1 = set(path1[1:-1])
        intermediate2 = set(path2[1:-1])

        return intermediate1.isdisjoint(intermediate2)

    def _get_edges(self, path: list[str]) -> set[tuple[str, str]]:
        """Extract edges from path as set of tuples."""
        return {(path[i], path[i + 1]) for i in range(len(path) - 1)}

    def check_connectivity(
        self,
        topology: nx.Graph,
        min_disjoint: int = 2,
    ) -> bool:
        """
        Check if topology supports required level of disjointness.

        For 1+1 protection, we need at least 2 disjoint paths between
        any communicating pair. This requires:
        - Edge connectivity >= 2 for link-disjoint
        - Node connectivity >= 2 for node-disjoint

        Args:
            topology: Network topology
            min_disjoint: Minimum required disjoint paths

        Returns:
            True if topology supports required connectivity

        Example:
            >>> if not finder.check_connectivity(topology):
            ...     logger.warning("Topology cannot support 1+1 protection")
        """
        if not nx.is_connected(topology):
            return False

        if self.disjointness == DisjointnessType.LINK:
            connectivity = nx.edge_connectivity(topology)
        else:
            connectivity = nx.node_connectivity(topology)

        return connectivity >= min_disjoint

    def count_disjoint_paths(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> int:
        """
        Count the number of disjoint paths between nodes.

        Useful for determining maximum protection level available.

        Args:
            topology: Network topology
            source: Source node
            destination: Destination node

        Returns:
            Number of disjoint paths available
        """
        return len(self.find_all_disjoint_paths(topology, source, destination))


class DisjointPathValidator:
    """
    Validate disjoint path properties.

    Provides methods to verify disjointness and check for
    common failure points (shared risk).
    """

    @staticmethod
    def are_link_disjoint(path1: list[str], path2: list[str]) -> bool:
        """Check if two paths are link-disjoint."""
        finder = DisjointPathFinder(DisjointnessType.LINK)
        return finder.verify_disjointness(path1, path2)

    @staticmethod
    def are_node_disjoint(path1: list[str], path2: list[str]) -> bool:
        """Check if two paths are node-disjoint."""
        finder = DisjointPathFinder(DisjointnessType.NODE)
        return finder.verify_disjointness(path1, path2)

    @staticmethod
    def find_shared_links(
        path1: list[str],
        path2: list[str],
    ) -> set[tuple[str, str]]:
        """Find links shared by both paths."""
        edges1 = {(path1[i], path1[i + 1]) for i in range(len(path1) - 1)}
        edges2 = {(path2[i], path2[i + 1]) for i in range(len(path2) - 1)}

        shared = set()
        for edge in edges1:
            if edge in edges2 or (edge[1], edge[0]) in edges2:
                shared.add(edge)

        return shared

    @staticmethod
    def find_shared_nodes(
        path1: list[str],
        path2: list[str],
    ) -> set[str]:
        """Find intermediate nodes shared by both paths."""
        intermediate1 = set(path1[1:-1])
        intermediate2 = set(path2[1:-1])
        return intermediate1.intersection(intermediate2)
```

### 3. Algorithm Comparison

| Algorithm | NetworkX Function | Complexity | Best For |
|-----------|-------------------|------------|----------|
| Edge-Disjoint | `nx.edge_disjoint_paths` | O(VE^2) | Link protection |
| Node-Disjoint | `nx.node_disjoint_paths` | O(VE^2) | Node protection |

### 4. Usage Examples

```python
# Link-disjoint for typical 1+1 protection
finder = DisjointPathFinder(DisjointnessType.LINK)
paths = finder.find_all_disjoint_paths(topology, "A", "D")

# Node-disjoint for stronger protection
finder = DisjointPathFinder(DisjointnessType.NODE)
paths = finder.find_all_disjoint_paths(topology, "A", "D")

# Quick pair finding
primary, backup = finder.find_disjoint_pair(topology, "A", "D")

# Validation
if finder.verify_disjointness(primary, backup):
    print("Paths are truly disjoint")

# Connectivity check before protection routing
if finder.check_connectivity(topology, min_disjoint=2):
    print("Topology supports 1+1 protection")
```

### 5. Integration with ProtectionPipeline

```python
class ProtectionPipeline:
    def __init__(self, config: ProtectionConfig) -> None:
        self.config = config
        self._disjoint_finder = DisjointPathFinder(config.disjointness)

    def find_protected_routes(self, source, destination, bandwidth, state):
        # Use finder to get disjoint paths
        disjoint_paths = self._disjoint_finder.find_all_disjoint_paths(
            state.topology, source, destination
        )
        ...
```

---

## Verification

- [ ] Link-disjoint paths found correctly
- [ ] Node-disjoint paths found correctly
- [ ] Disjointness verification works
- [ ] Connectivity checking works
- [ ] Empty result for non-existent paths
- [ ] Handles NetworkX exceptions gracefully

---

## Test Cases to Implement

```python
class TestDisjointPathFinder:
    """Tests for DisjointPathFinder."""

    def test_find_edge_disjoint_diamond(self) -> None:
        """Should find 2 edge-disjoint paths in diamond topology."""
        # Diamond: A -- B -- D, A -- C -- D
        G = nx.Graph()
        G.add_edges_from([("A", "B"), ("B", "D"), ("A", "C"), ("C", "D")])

        finder = DisjointPathFinder(DisjointnessType.LINK)
        paths = finder.find_all_disjoint_paths(G, "A", "D")

        assert len(paths) == 2
        assert finder.verify_disjointness(paths[0], paths[1])

    def test_find_node_disjoint(self) -> None:
        """Should find node-disjoint paths."""
        # Topology with node-disjoint paths
        G = nx.Graph()
        G.add_edges_from([
            ("A", "B"), ("B", "D"),
            ("A", "C"), ("C", "D"),
        ])

        finder = DisjointPathFinder(DisjointnessType.NODE)
        paths = finder.find_all_disjoint_paths(G, "A", "D")

        assert len(paths) == 2
        # Verify no shared intermediate nodes
        intermediate1 = set(paths[0][1:-1])
        intermediate2 = set(paths[1][1:-1])
        assert intermediate1.isdisjoint(intermediate2)

    def test_linear_topology_no_disjoint(self) -> None:
        """Should return empty for linear topology (no disjoint paths)."""
        G = nx.path_graph(5)  # 0 -- 1 -- 2 -- 3 -- 4

        finder = DisjointPathFinder(DisjointnessType.LINK)
        paths = finder.find_all_disjoint_paths(G, 0, 4)

        assert len(paths) < 2

    def test_check_connectivity(self) -> None:
        """Should verify topology supports protection."""
        # 2-connected graph
        G = nx.cycle_graph(4)  # Ring: 0-1-2-3-0

        finder = DisjointPathFinder(DisjointnessType.LINK)
        assert finder.check_connectivity(G, min_disjoint=2)

    def test_verify_disjointness(self) -> None:
        """Should correctly verify path disjointness."""
        finder = DisjointPathFinder(DisjointnessType.LINK)

        # Disjoint paths
        path1 = ["A", "B", "D"]
        path2 = ["A", "C", "D"]
        assert finder.verify_disjointness(path1, path2)

        # Non-disjoint paths
        path3 = ["A", "B", "D"]
        path4 = ["A", "B", "C", "D"]
        assert not finder.verify_disjointness(path3, path4)
```

---

## Next Task

Proceed to **P5.4.d** to design protected spectrum allocation.
