# P5.4 Protection Pipeline

**Phase:** 5 - ML Control + Protection
**Sub-phase:** P5.4
**Scope:** 1+1 Dedicated Path Protection Integration

**REVISION NOTE**: This file has been updated to include complete DisjointPathFinder algorithm design, allocate_protected() method, NetworkState extensions, and domain model extensions per V4 specification requirements.

---

## Goals

1. Implement ProtectionPipeline for 1+1 dedicated path protection
2. Design DisjointPathFinder with both link-disjoint and node-disjoint algorithms
3. Implement allocate_protected() for dual spectrum allocation
4. Implement failure detection and switchover mechanism
5. Extend Lightpath model with protection fields
6. Extend RouteResult and AllocationResult for protection
7. Extend NetworkState with create_protected_lightpath and get_lightpaths_on_link

---

## Key Deliverables

| # | Deliverable | Description |
|---|-------------|-------------|
| 1 | `fusion/pipelines/protection_pipeline.py` | ProtectionPipeline orchestrating protection |
| 2 | `fusion/pipelines/disjoint_path_finder.py` | **NEW**: DisjointPathFinder algorithms |
| 3 | `ProtectionPipeline.allocate_protected()` | **NEW**: Dual spectrum allocation method |
| 4 | `FailureHandler` class | Failure detection and switchover |
| 5 | Extended `Lightpath` | Backup path, active path, is_protected fields |
| 6 | Extended `RouteResult` | Backup paths and modulations |
| 7 | Extended `AllocationResult` | backup_path, is_protected fields |
| 8 | `NetworkState.create_protected_lightpath()` | **NEW**: NetworkState extension |
| 9 | `NetworkState.get_lightpaths_on_link()` | **NEW**: NetworkState extension |

---

## Constraints

- Must integrate with existing routing pipeline
- Must support both link-disjoint and node-disjoint modes
- Must allocate same spectrum on both paths (1+1 dedicated)
- Switchover latency must be configurable (default 50ms)
- Must validate both paths are feasible before allocation

---

## Dependencies

| Dependency | From |
|------------|------|
| `ControlPolicy` protocol | P5.1 |
| `PathOption` with protection fields | P5.1 |
| `NetworkState` | Phase 2 |
| `RoutingPipeline` | Phase 3 |
| `SpectrumAssignment` | Phase 3 |

---

## Micro-Tasks

| Task ID | Type | Description | Output |
|---------|------|-------------|--------|
| P5.4.a | context-extraction | Extract existing 1+1 protection patterns | Protection pattern catalog |
| P5.4.b | design | Design ProtectionPipeline class | Class specification |
| P5.4.c | design | Design DisjointPathFinder | **UPDATED**: Complete algorithm |
| P5.4.d | design | Design allocate_protected() | **UPDATED**: Full allocation logic |
| P5.4.e | design | Design failure handling mechanism | Switchover protocol |
| P5.4.f | design | Extend domain models | **UPDATED**: Lightpath, RouteResult, AllocationResult |
| P5.4.g | design | NetworkState extensions | **NEW**: Protection-related methods |
| P5.4.h | wiring-plan | Implement ProtectionPipeline | Full implementation |
| P5.4.i | verification-plan | Create verification plan | Test suite |

---

## DisjointPathFinder Design

The DisjointPathFinder implements algorithms for finding link-disjoint and node-disjoint path pairs:

```python
"""
Disjoint path finding algorithms for 1+1 protection.

This module provides algorithms for finding link-disjoint and node-disjoint
path pairs required for 1+1 dedicated protection.
"""

from __future__ import annotations

import logging
from enum import Enum
from typing import TYPE_CHECKING

import networkx as nx

if TYPE_CHECKING:
    pass

logger = logging.getLogger(__name__)


class DisjointnessType(Enum):
    """Type of path disjointness."""

    LINK = "link"
    NODE = "node"


class DisjointPathFinder:
    """
    Finds disjoint path pairs for 1+1 protection.

    Supports two disjointness modes:
    - LINK: Paths share no common edges (may share intermediate nodes)
    - NODE: Paths share no common intermediate nodes (stronger guarantee)

    Uses Suurballe's algorithm for finding minimum-weight disjoint paths.

    Attributes:
        disjointness: Type of disjointness (LINK or NODE)

    Example:
        >>> finder = DisjointPathFinder(DisjointnessType.LINK)
        >>> paths = finder.find_disjoint_pair(topology, "A", "D")
        >>> if paths:
        ...     primary, backup = paths
    """

    def __init__(self, disjointness: DisjointnessType = DisjointnessType.LINK) -> None:
        """
        Initialize DisjointPathFinder.

        Args:
            disjointness: Type of disjointness to enforce
        """
        self.disjointness = disjointness

    def find_disjoint_pair(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> tuple[list[str], list[str]] | None:
        """
        Find a disjoint path pair between source and destination.

        Args:
            topology: Network topology graph
            source: Source node identifier
            destination: Destination node identifier

        Returns:
            Tuple of (primary_path, backup_path) or None if not possible
        """
        if self.disjointness == DisjointnessType.LINK:
            return self._find_link_disjoint(topology, source, destination)
        else:
            return self._find_node_disjoint(topology, source, destination)

    def find_all_disjoint_paths(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
        max_paths: int = 10,
    ) -> list[list[str]]:
        """
        Find all disjoint paths between source and destination.

        Args:
            topology: Network topology graph
            source: Source node
            destination: Destination node
            max_paths: Maximum paths to return

        Returns:
            List of disjoint paths
        """
        if self.disjointness == DisjointnessType.LINK:
            return self._find_all_link_disjoint(
                topology, source, destination, max_paths
            )
        else:
            return self._find_all_node_disjoint(
                topology, source, destination, max_paths
            )

    def _find_link_disjoint(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> tuple[list[str], list[str]] | None:
        """
        Find link-disjoint path pair using edge-disjoint shortest paths.

        Algorithm:
        1. Find shortest path (primary)
        2. Remove edges of primary path from graph
        3. Find shortest path in residual graph (backup)
        4. If backup exists, paths are link-disjoint
        """
        try:
            # Find primary (shortest) path
            primary = nx.shortest_path(
                topology, source, destination, weight="weight"
            )

            # Create residual graph without primary edges
            residual = topology.copy()
            for i in range(len(primary) - 1):
                u, v = primary[i], primary[i + 1]
                if residual.has_edge(u, v):
                    residual.remove_edge(u, v)

            # Find backup path in residual graph
            try:
                backup = nx.shortest_path(
                    residual, source, destination, weight="weight"
                )
                return (primary, backup)
            except nx.NetworkXNoPath:
                logger.debug(
                    f"No link-disjoint backup for {source}->{destination}"
                )
                return None

        except nx.NetworkXNoPath:
            logger.debug(f"No path exists from {source} to {destination}")
            return None

    def _find_node_disjoint(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
    ) -> tuple[list[str], list[str]] | None:
        """
        Find node-disjoint path pair.

        Algorithm:
        1. Find shortest path (primary)
        2. Remove intermediate nodes of primary from graph
        3. Find shortest path in residual graph (backup)
        """
        try:
            # Find primary path
            primary = nx.shortest_path(
                topology, source, destination, weight="weight"
            )

            # Create residual graph without intermediate nodes
            residual = topology.copy()
            for node in primary[1:-1]:  # Exclude source and destination
                residual.remove_node(node)

            # Find backup in residual
            try:
                backup = nx.shortest_path(
                    residual, source, destination, weight="weight"
                )
                return (primary, backup)
            except nx.NetworkXNoPath:
                logger.debug(
                    f"No node-disjoint backup for {source}->{destination}"
                )
                return None

        except nx.NetworkXNoPath:
            logger.debug(f"No path exists from {source} to {destination}")
            return None

    def _find_all_link_disjoint(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
        max_paths: int,
    ) -> list[list[str]]:
        """Find all link-disjoint paths using iterative removal."""
        paths = []
        residual = topology.copy()

        while len(paths) < max_paths:
            try:
                path = nx.shortest_path(
                    residual, source, destination, weight="weight"
                )
                paths.append(path)

                # Remove edges of this path
                for i in range(len(path) - 1):
                    u, v = path[i], path[i + 1]
                    if residual.has_edge(u, v):
                        residual.remove_edge(u, v)

            except nx.NetworkXNoPath:
                break

        return paths

    def _find_all_node_disjoint(
        self,
        topology: nx.Graph,
        source: str,
        destination: str,
        max_paths: int,
    ) -> list[list[str]]:
        """Find all node-disjoint paths."""
        paths = []
        residual = topology.copy()

        while len(paths) < max_paths:
            try:
                path = nx.shortest_path(
                    residual, source, destination, weight="weight"
                )
                paths.append(path)

                # Remove intermediate nodes
                for node in path[1:-1]:
                    if residual.has_node(node):
                        residual.remove_node(node)

            except nx.NetworkXNoPath:
                break

        return paths

    def are_link_disjoint(
        self, path1: list[str], path2: list[str]
    ) -> bool:
        """Check if two paths are link-disjoint."""
        edges1 = {(path1[i], path1[i + 1]) for i in range(len(path1) - 1)}
        edges1.update((path1[i + 1], path1[i]) for i in range(len(path1) - 1))
        edges2 = {(path2[i], path2[i + 1]) for i in range(len(path2) - 1)}
        edges2.update((path2[i + 1], path2[i]) for i in range(len(path2) - 1))
        return not edges1.intersection(edges2)

    def are_node_disjoint(
        self, path1: list[str], path2: list[str]
    ) -> bool:
        """Check if two paths are node-disjoint (except endpoints)."""
        nodes1 = set(path1[1:-1])
        nodes2 = set(path2[1:-1])
        return not nodes1.intersection(nodes2)
```

---

## allocate_protected() Method

The `allocate_protected()` method handles dual spectrum allocation:

```python
def allocate_protected(
    self,
    primary_path: list[str],
    backup_path: list[str],
    slots_needed: int,
    network_state: NetworkState,
) -> AllocationResult:
    """
    Allocate spectrum on both primary and backup paths.

    For 1+1 dedicated protection, allocates the SAME spectrum slots
    on both paths to enable fast switchover.

    Args:
        primary_path: Primary path node sequence
        backup_path: Backup path node sequence
        slots_needed: Number of spectrum slots needed
        network_state: Current network state

    Returns:
        AllocationResult with spectrum assignment or failure reason

    Algorithm:
        1. Find common free spectrum blocks on both paths
        2. Select first-fit block that satisfies slots_needed
        3. Mark spectrum as allocated on both paths
        4. Return allocation details
    """
    # Get spectrum availability on both paths
    primary_spectrum = self._get_path_spectrum(primary_path, network_state)
    backup_spectrum = self._get_path_spectrum(backup_path, network_state)

    # Find common free blocks
    common_free = primary_spectrum & backup_spectrum  # Bitwise AND

    # Find contiguous block using first-fit
    start_slot = self._find_first_fit_block(common_free, slots_needed)

    if start_slot < 0:
        return AllocationResult(
            success=False,
            block_reason=BlockReason.NO_COMMON_SPECTRUM,
        )

    end_slot = start_slot + slots_needed - 1

    # Mark spectrum as allocated on both paths
    self._allocate_spectrum(primary_path, start_slot, end_slot, network_state)
    self._allocate_spectrum(backup_path, start_slot, end_slot, network_state)

    return AllocationResult(
        success=True,
        spectrum_start=start_slot,
        spectrum_end=end_slot,
        is_protected=True,
    )

def _get_path_spectrum(
    self,
    path: list[str],
    network_state: NetworkState,
) -> np.ndarray:
    """Get combined spectrum availability for a path (AND of all links)."""
    num_slots = network_state.num_spectrum_slots
    combined = np.ones(num_slots, dtype=bool)

    for i in range(len(path) - 1):
        link = (path[i], path[i + 1])
        link_spectrum = network_state.get_link_spectrum(link)
        if link_spectrum is not None:
            # 0 = free, 1 = used; invert for availability
            available = ~link_spectrum.astype(bool)
            combined &= available

    return combined

def _find_first_fit_block(
    self,
    available: np.ndarray,
    slots_needed: int,
) -> int:
    """Find first contiguous block of free slots."""
    consecutive = 0
    start = -1

    for i, free in enumerate(available):
        if free:
            if consecutive == 0:
                start = i
            consecutive += 1
            if consecutive >= slots_needed:
                return start
        else:
            consecutive = 0
            start = -1

    return -1

def _allocate_spectrum(
    self,
    path: list[str],
    start_slot: int,
    end_slot: int,
    network_state: NetworkState,
) -> None:
    """Mark spectrum as allocated on all links of path."""
    for i in range(len(path) - 1):
        link = (path[i], path[i + 1])
        network_state.allocate_spectrum(link, start_slot, end_slot)
```

---

## NetworkState Extensions

Extensions to `fusion/domain/network_state.py`:

```python
def create_protected_lightpath(
    self,
    lightpath_id: str,
    primary_path: list[str],
    backup_path: list[str],
    spectrum_start: int,
    spectrum_end: int,
    modulation: str,
    backup_modulation: str,
    bandwidth_gbps: int,
    created_at: float,
    expires_at: float | None = None,
) -> Lightpath:
    """
    Create a protected lightpath with primary and backup paths.

    Allocates spectrum on both paths and creates a Lightpath with
    protection fields populated.

    Args:
        lightpath_id: Unique identifier for the lightpath
        primary_path: Primary path node sequence
        backup_path: Backup (disjoint) path node sequence
        spectrum_start: Starting spectrum slot (same on both paths)
        spectrum_end: Ending spectrum slot
        modulation: Primary path modulation
        backup_modulation: Backup path modulation
        bandwidth_gbps: Bandwidth in Gbps
        created_at: Creation timestamp
        expires_at: Expiration timestamp (optional)

    Returns:
        Created Lightpath with protection fields

    Raises:
        ValueError: If paths are not valid or spectrum unavailable
    """
    # Validate paths
    if not primary_path or not backup_path:
        raise ValueError("Both primary and backup paths required")

    # Create protected lightpath
    lightpath = Lightpath(
        lightpath_id=lightpath_id,
        source=primary_path[0],
        destination=primary_path[-1],
        path=primary_path,
        spectrum_start=spectrum_start,
        spectrum_end=spectrum_end,
        modulation=modulation,
        bandwidth_gbps=bandwidth_gbps,
        created_at=created_at,
        expires_at=expires_at,
        # Protection fields
        backup_path=backup_path,
        backup_spectrum_start=spectrum_start,  # Same for 1+1
        backup_spectrum_end=spectrum_end,
        is_protected=True,
        active_path="primary",
    )

    # Register in state
    self._lightpaths[lightpath_id] = lightpath

    return lightpath


def get_lightpaths_on_link(
    self,
    link: tuple[str, str],
) -> list[Lightpath]:
    """
    Get all lightpaths traversing a specific link.

    Checks both primary and backup paths for protected lightpaths.

    Args:
        link: The link as (node_a, node_b) tuple

    Returns:
        List of lightpaths using this link (on either primary or backup)
    """
    affected = []
    link_set = {link, (link[1], link[0])}  # Both directions

    for lightpath in self._lightpaths.values():
        # Check primary path
        path = lightpath.path
        for i in range(len(path) - 1):
            if (path[i], path[i + 1]) in link_set:
                affected.append(lightpath)
                break

        # Check backup path if protected
        if lightpath.is_protected and lightpath.backup_path:
            backup = lightpath.backup_path
            for i in range(len(backup) - 1):
                if (backup[i], backup[i + 1]) in link_set:
                    if lightpath not in affected:
                        affected.append(lightpath)
                    break

    return affected


def switch_to_backup(self, lightpath_id: str) -> bool:
    """
    Switch a protected lightpath to use its backup path.

    Args:
        lightpath_id: ID of lightpath to switch

    Returns:
        True if switch successful, False if not protected or not found
    """
    lightpath = self._lightpaths.get(lightpath_id)
    if lightpath is None:
        return False

    if not lightpath.is_protected:
        return False

    # Update active path
    lightpath.active_path = "backup"
    return True


def switch_to_primary(self, lightpath_id: str) -> bool:
    """
    Switch a protected lightpath back to its primary path.

    Args:
        lightpath_id: ID of lightpath to switch

    Returns:
        True if switch successful
    """
    lightpath = self._lightpaths.get(lightpath_id)
    if lightpath is None:
        return False

    if not lightpath.is_protected:
        return False

    lightpath.active_path = "primary"
    return True
```

---

## Domain Model Extensions

### Lightpath Extension

```python
@dataclass
class Lightpath:
    """Represents an established lightpath."""

    # Core fields (existing)
    lightpath_id: str
    source: str
    destination: str
    path: list[str]
    spectrum_start: int
    spectrum_end: int
    modulation: str
    bandwidth_gbps: int
    created_at: float
    expires_at: float | None = None

    # Protection fields (Phase 5)
    backup_path: list[str] | None = None
    backup_spectrum_start: int | None = None
    backup_spectrum_end: int | None = None
    backup_modulation: str | None = None
    is_protected: bool = False
    active_path: str = "primary"  # "primary" or "backup"

    @property
    def current_path(self) -> list[str]:
        """Return currently active path."""
        if self.is_protected and self.active_path == "backup":
            return self.backup_path or self.path
        return self.path

    @property
    def num_slots(self) -> int:
        """Number of spectrum slots used."""
        return self.spectrum_end - self.spectrum_start + 1
```

### RouteResult Extension

```python
@dataclass(frozen=True)
class RouteResult:
    """Result from routing pipeline."""

    paths: list[list[str]]
    modulations: list[list[str | None]]
    weights_km: list[float]
    strategy_name: str = ""

    # Protection fields (Phase 5)
    backup_paths: list[list[str]] | None = None
    backup_modulations: list[list[str | None]] | None = None
    backup_weights_km: list[float] | None = None

    @property
    def has_protection(self) -> bool:
        """Check if route result includes protection paths."""
        return self.backup_paths is not None and len(self.backup_paths) > 0
```

### AllocationResult Extension

```python
@dataclass(frozen=True)
class AllocationResult:
    """Result from spectrum allocation."""

    success: bool
    lightpath_id: str | None = None
    path: list[str] | None = None
    spectrum_start: int | None = None
    spectrum_end: int | None = None
    modulation: str | None = None
    block_reason: BlockReason | None = None

    # Protection fields (Phase 5)
    backup_path: list[str] | None = None
    is_protected: bool = False
```

### BlockReason Extension

```python
class BlockReason(Enum):
    """Reasons for request blocking."""

    NO_PATH = "no_path"
    NO_SPECTRUM = "no_spectrum"
    SNR_FAILED = "snr_failed"
    INVALID_ACTION = "invalid_action"

    # Protection-specific (Phase 5)
    NO_DISJOINT_PATHS = "no_disjoint_paths"
    NO_COMMON_SPECTRUM = "no_common_spectrum"
    PROTECTION_INFEASIBLE = "protection_infeasible"
```

---

## Exit Criteria

- [ ] ProtectionPipeline finds disjoint path pairs
- [ ] DisjointPathFinder supports link-disjoint mode
- [ ] DisjointPathFinder supports node-disjoint mode
- [ ] allocate_protected() finds common spectrum blocks
- [ ] allocate_protected() allocates same slots on both paths
- [ ] Failure triggers switchover to backup path
- [ ] Switchover latency is configurable
- [ ] Lightpath model supports protection fields
- [ ] RouteResult supports backup_paths
- [ ] AllocationResult supports protection fields
- [ ] NetworkState.create_protected_lightpath() works
- [ ] NetworkState.get_lightpaths_on_link() works
- [ ] NetworkState.switch_to_backup() works
- [ ] All tests pass
- [ ] Integration with orchestrator verified

---

## Execution Order

```
P5.4.a (context) --> P5.4.b (ProtectionPipeline design)
                         |
                         +--> P5.4.c (DisjointPathFinder) [UPDATED]
                         |
                         +--> P5.4.d (allocate_protected) [UPDATED]
                         |
                         +--> P5.4.e (FailureHandling)
                         |
                         +--> P5.4.f (Domain model extensions) [UPDATED]
                         |
                         +--> P5.4.g (NetworkState extensions) [NEW]
                         |
                         v
                     P5.4.h (implementation)
                         |
                         v
                     P5.4.i (verification)
```

---

## Next Sub-Phase

After P5.4 completion, proceed to **P5.5 Orchestrator Integration** to wire policies and protection into the orchestrator.
