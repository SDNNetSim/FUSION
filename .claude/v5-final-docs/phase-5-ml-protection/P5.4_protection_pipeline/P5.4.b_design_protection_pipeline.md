# Task ID: P5.4.b - Design ProtectionPipeline Class

**Sub-phase:** P5.4
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the `ProtectionPipeline` class that orchestrates 1+1 dedicated path protection, including disjoint path finding, dual spectrum allocation, and failure handling.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.shared_context_protection_logic.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.a_context_extraction_1plus1.md`
- `fusion/modules/routing/one_plus_one_protection.py`

---

## Outputs

### 1. ProtectionPipeline Class Design

```python
"""
Protection pipeline for 1+1 dedicated path protection.

This module provides the ProtectionPipeline class that orchestrates
disjoint path finding, dual spectrum allocation, and failure handling
for 1+1 dedicated protection.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from enum import Enum
from typing import TYPE_CHECKING

import networkx as nx

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import RouteResult

logger = logging.getLogger(__name__)


class DisjointnessType(Enum):
    """Type of path disjointness for protection."""

    LINK = "link"
    NODE = "node"


@dataclass
class ProtectionConfig:
    """Configuration for protection pipeline."""

    enabled: bool = False
    disjointness: DisjointnessType = DisjointnessType.LINK
    switchover_time_ms: float = 50.0
    revert_after_repair: bool = False

    @classmethod
    def from_simulation_config(cls, config: SimulationConfig) -> "ProtectionConfig":
        """Create ProtectionConfig from SimulationConfig."""
        return cls(
            enabled=getattr(config, "protection_enabled", False),
            disjointness=DisjointnessType(
                getattr(config, "protection_disjointness", "link")
            ),
            switchover_time_ms=getattr(config, "protection_switchover_ms", 50.0),
            revert_after_repair=getattr(config, "protection_revert_after_repair", False),
        )


class ProtectionPipeline:
    """
    Pipeline for 1+1 dedicated path protection.

    Provides disjoint path finding, dual spectrum allocation,
    and failure switchover for protected lightpaths.

    1+1 Protection Characteristics:
    - Allocates spectrum on BOTH primary and backup paths
    - Same slots used on both paths (dedicated protection)
    - Receiver monitors primary, switches to backup on failure
    - Fast switchover (configurable latency, default 50ms)

    Attributes:
        config: Protection configuration
        disjoint_finder: Disjoint path finding algorithm
        _metrics: Protection statistics

    Example:
        >>> pipeline = ProtectionPipeline(protection_config)
        >>> routes = pipeline.find_protected_routes(
        ...     source="A",
        ...     destination="D",
        ...     bandwidth_gbps=100,
        ...     network_state=network_state,
        ... )
        >>> # routes contains paired primary/backup paths
    """

    def __init__(self, config: ProtectionConfig) -> None:
        """
        Initialize protection pipeline.

        Args:
            config: Protection configuration
        """
        self.config = config
        self._disjoint_finder = DisjointPathFinder(config.disjointness)

        # Metrics
        self._total_requests = 0
        self._protected_allocations = 0
        self._protection_failures = 0
        self._switchovers = 0

    def find_protected_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> RouteResult:
        """
        Find protected routes with disjoint primary and backup paths.

        Searches for disjoint path pairs where both paths have feasible
        modulation formats for the given bandwidth requirement.

        Args:
            source: Source node identifier
            destination: Destination node identifier
            bandwidth_gbps: Required bandwidth in Gbps
            network_state: Current network state

        Returns:
            RouteResult with paired primary/backup paths, or empty if
            no feasible protected route exists

        Example:
            >>> routes = pipeline.find_protected_routes("A", "D", 100, state)
            >>> if routes.paths:
            ...     primary = routes.paths[0]
            ...     backup = routes.backup_paths[0]
        """
        self._total_requests += 1
        topology = network_state.topology

        # Find all disjoint paths
        disjoint_paths = self._disjoint_finder.find_all_disjoint_paths(
            topology, source, destination
        )

        if len(disjoint_paths) < 2:
            logger.debug(
                f"No disjoint paths found for {source} -> {destination}"
            )
            self._protection_failures += 1
            return self._empty_result()

        # Find feasible path pairs
        feasible_pairs = self._find_feasible_pairs(
            disjoint_paths, bandwidth_gbps, network_state
        )

        if not feasible_pairs:
            logger.debug(
                f"No feasible path pair for {source} -> {destination}"
            )
            self._protection_failures += 1
            return self._empty_result()

        # Select best pair (shortest combined length)
        best_pair = self._select_best_pair(feasible_pairs, network_state)
        self._protected_allocations += 1

        return self._build_route_result(best_pair, network_state)

    def _find_feasible_pairs(
        self,
        disjoint_paths: list[list[str]],
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> list[tuple[PathInfo, PathInfo]]:
        """
        Find all feasible primary/backup path pairs.

        A pair is feasible if both paths have valid modulation formats
        for the given bandwidth and path length.

        Args:
            disjoint_paths: All disjoint paths found
            bandwidth_gbps: Required bandwidth
            network_state: Current network state

        Returns:
            List of (primary_info, backup_info) tuples
        """
        feasible_pairs = []

        for i in range(len(disjoint_paths)):
            for j in range(i + 1, len(disjoint_paths)):
                primary_info = self._evaluate_path(
                    disjoint_paths[i], bandwidth_gbps, network_state
                )
                backup_info = self._evaluate_path(
                    disjoint_paths[j], bandwidth_gbps, network_state
                )

                if primary_info.is_feasible and backup_info.is_feasible:
                    feasible_pairs.append((primary_info, backup_info))

        return feasible_pairs

    def _evaluate_path(
        self,
        path: list[str],
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> PathInfo:
        """
        Evaluate a path for feasibility.

        Args:
            path: Node sequence
            bandwidth_gbps: Required bandwidth
            network_state: Current network state

        Returns:
            PathInfo with feasibility and modulation info
        """
        weight_km = self._compute_path_weight(path, network_state)
        modulations = self._get_valid_modulations(
            path, bandwidth_gbps, network_state
        )
        is_feasible = len(modulations) > 0

        return PathInfo(
            path=tuple(path),
            weight_km=weight_km,
            modulations=modulations,
            is_feasible=is_feasible,
        )

    def _select_best_pair(
        self,
        feasible_pairs: list[tuple[PathInfo, PathInfo]],
        network_state: NetworkState,
    ) -> tuple[PathInfo, PathInfo]:
        """
        Select the best path pair from feasible options.

        Selection criteria: Shortest combined path length.

        Args:
            feasible_pairs: List of feasible pairs
            network_state: Current network state

        Returns:
            Best (primary, backup) pair
        """
        return min(
            feasible_pairs,
            key=lambda pair: pair[0].weight_km + pair[1].weight_km,
        )

    def _compute_path_weight(
        self,
        path: list[str],
        network_state: NetworkState,
    ) -> float:
        """Compute path weight in kilometers."""
        topology = network_state.topology
        weight = 0.0

        for i in range(len(path) - 1):
            edge_data = topology.get_edge_data(path[i], path[i + 1])
            if edge_data:
                weight += edge_data.get("weight", 1.0)

        return weight

    def _get_valid_modulations(
        self,
        path: list[str],
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> list[str]:
        """Get valid modulation formats for path and bandwidth."""
        path_length = self._compute_path_weight(path, network_state)

        # Use network state's modulation capabilities
        valid_mods = []
        mod_formats = network_state.modulation_formats

        for mod_name, mod_info in mod_formats.items():
            max_reach = mod_info.get("max_length", float("inf"))
            if path_length <= max_reach:
                valid_mods.append(mod_name)

        return valid_mods

    def _build_route_result(
        self,
        pair: tuple[PathInfo, PathInfo],
        network_state: NetworkState,
    ) -> RouteResult:
        """Build RouteResult from selected path pair."""
        from fusion.domain.results import RouteResult

        primary, backup = pair

        return RouteResult(
            paths=[list(primary.path)],
            modulations=[primary.modulations],
            weights_km=[primary.weight_km],
            backup_paths=[list(backup.path)],
            backup_modulations=[backup.modulations],
            backup_weights_km=[backup.weight_km],
            strategy_name="1plus1_protection",
        )

    def _empty_result(self) -> RouteResult:
        """Return empty RouteResult for failed protection."""
        from fusion.domain.results import RouteResult

        return RouteResult(
            paths=[],
            modulations=[],
            weights_km=[],
            strategy_name="1plus1_protection",
        )

    def handle_failure(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
    ) -> list[SwitchoverAction]:
        """
        Handle link failure by switching affected lightpaths.

        Args:
            failed_link: The failed link (node_a, node_b)
            network_state: Current network state

        Returns:
            List of switchover actions performed
        """
        affected = network_state.get_lightpaths_on_link(failed_link)
        switchovers = []

        for lightpath in affected:
            if lightpath.is_protected and lightpath.active_path == "primary":
                if self._path_contains_link(lightpath.path, failed_link):
                    switchovers.append(
                        SwitchoverAction(
                            lightpath_id=lightpath.lightpath_id,
                            from_path="primary",
                            to_path="backup",
                            latency_ms=self.config.switchover_time_ms,
                        )
                    )
                    self._switchovers += 1

        return switchovers

    def _path_contains_link(
        self,
        path: list[str],
        link: tuple[str, str],
    ) -> bool:
        """Check if path contains the given link."""
        for i in range(len(path) - 1):
            edge = (path[i], path[i + 1])
            if edge == link or edge == (link[1], link[0]):
                return True
        return False

    def get_metrics(self) -> dict[str, any]:
        """Get protection pipeline metrics."""
        success_rate = (
            self._protected_allocations / self._total_requests
            if self._total_requests > 0
            else 0.0
        )

        return {
            "total_requests": self._total_requests,
            "protected_allocations": self._protected_allocations,
            "protection_failures": self._protection_failures,
            "switchovers": self._switchovers,
            "success_rate": success_rate,
            "disjointness_type": self.config.disjointness.value,
            "switchover_time_ms": self.config.switchover_time_ms,
        }

    def reset_metrics(self) -> None:
        """Reset all metrics counters."""
        self._total_requests = 0
        self._protected_allocations = 0
        self._protection_failures = 0
        self._switchovers = 0


@dataclass
class PathInfo:
    """Information about a candidate path."""

    path: tuple[str, ...]
    weight_km: float
    modulations: list[str]
    is_feasible: bool


@dataclass
class SwitchoverAction:
    """Record of a protection switchover."""

    lightpath_id: str
    from_path: str
    to_path: str
    latency_ms: float
```

### 2. Design Rationale Table

| Decision | Rationale |
|----------|-----------|
| **ProtectionConfig dataclass** | Separate config from pipeline logic |
| **DisjointnessType enum** | Type-safe disjointness selection |
| **PathInfo dataclass** | Bundle path evaluation results |
| **SwitchoverAction dataclass** | Structured switchover records |
| **Metrics tracking** | Monitor protection effectiveness |
| **Best pair = shortest combined** | Minimize resource usage |
| **Lazy RouteResult import** | Avoid circular imports |

### 3. Interface Summary

```python
class ProtectionPipeline:
    """Public interface for protection pipeline."""

    def __init__(self, config: ProtectionConfig) -> None: ...

    def find_protected_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> RouteResult: ...

    def handle_failure(
        self,
        failed_link: tuple[str, str],
        network_state: NetworkState,
    ) -> list[SwitchoverAction]: ...

    def get_metrics(self) -> dict[str, any]: ...

    def reset_metrics(self) -> None: ...
```

### 4. State Diagram

```
find_protected_routes()
    │
    ├── Find disjoint paths
    │       │
    │       └── < 2 paths? ──► Return empty result
    │
    ├── Find feasible pairs
    │       │
    │       └── No feasible? ──► Return empty result
    │
    ├── Select best pair
    │
    └── Build RouteResult
            │
            └── Return with backup_paths
```

```
handle_failure()
    │
    ├── Get affected lightpaths
    │
    ├── For each protected lightpath:
    │       │
    │       ├── On primary path?
    │       │       │
    │       │       └── Yes ──► Create switchover action
    │       │
    │       └── Continue
    │
    └── Return switchover actions
```

---

## Verification

- [ ] ProtectionConfig captures all settings
- [ ] find_protected_routes returns paired paths
- [ ] handle_failure creates switchover actions
- [ ] Metrics track success/failure rates
- [ ] Both link and node disjoint supported
- [ ] Best pair selection minimizes resource usage

---

## Test Cases to Implement

```python
class TestProtectionPipeline:
    """Tests for ProtectionPipeline."""

    def test_find_protected_routes_success(self) -> None:
        """Should find feasible primary/backup pair."""
        pipeline = ProtectionPipeline(ProtectionConfig(enabled=True))
        result = pipeline.find_protected_routes("A", "D", 100, network_state)

        assert len(result.paths) == 1
        assert len(result.backup_paths) == 1
        assert result.paths[0] != result.backup_paths[0]

    def test_no_disjoint_paths(self) -> None:
        """Should return empty when no disjoint paths exist."""
        # Linear topology: A -- B -- C
        pipeline = ProtectionPipeline(ProtectionConfig(enabled=True))
        result = pipeline.find_protected_routes("A", "C", 100, linear_state)

        assert result.paths == []

    def test_handle_failure_triggers_switchover(self) -> None:
        """Should switch affected lightpaths to backup."""
        pipeline = ProtectionPipeline(ProtectionConfig(enabled=True))
        switchovers = pipeline.handle_failure(("A", "B"), network_state)

        assert len(switchovers) > 0
        assert all(s.to_path == "backup" for s in switchovers)
```

---

## Next Task

Proceed to **P5.4.c** to design the DisjointPathFinder in detail.
