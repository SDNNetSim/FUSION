# Task ID: P5.5.e - Verification Plan for Orchestrator Integration

**Sub-phase:** P5.5
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** verification-plan

---

## Purpose

Define the verification plan for orchestrator integration with policies and protection.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.c_wire_policy_to_orchestrator.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.d_wire_protection_flows.md`

---

## Outputs

### 1. Test File Structure

```
fusion/core/tests/
├── test_orchestrator_policy.py
├── test_policy_factory.py
├── test_failure_handling.py
└── conftest.py
```

### 2. Test Fixtures

```python
"""
Test fixtures for orchestrator integration tests.
"""

import pytest
import networkx as nx
import numpy as np
from dataclasses import dataclass
from unittest.mock import Mock, MagicMock


@pytest.fixture
def mock_config():
    """Mock simulation config."""
    config = Mock()
    config.policy_type = "first_feasible"
    config.protection_enabled = False
    config.protection_disjointness = "link"
    config.protection_switchover_ms = 50.0
    return config


@pytest.fixture
def mock_config_protected():
    """Mock config with protection enabled."""
    config = Mock()
    config.policy_type = "shortest_feasible"
    config.protection_enabled = True
    config.protection_disjointness = "link"
    config.protection_switchover_ms = 50.0
    return config


@pytest.fixture
def mock_config_ml():
    """Mock config for ML policy."""
    config = Mock()
    config.policy_type = "ml"
    config.policy_model_path = "test_model.pt"
    config.policy_device = "cpu"
    config.protection_enabled = False
    return config


@pytest.fixture
def mock_pipelines():
    """Mock pipeline set."""
    pipelines = Mock()
    pipelines.routing = Mock()
    pipelines.spectrum = Mock()
    pipelines.snr = Mock()
    return pipelines


@pytest.fixture
def mock_network_state():
    """Mock network state."""
    state = Mock()
    state.topology = nx.Graph()
    state.topology.add_edges_from([
        ("A", "B", {"weight": 100}),
        ("B", "D", {"weight": 100}),
        ("A", "C", {"weight": 100}),
        ("C", "D", {"weight": 100}),
    ])
    state.get_link_spectrum = Mock(return_value=np.zeros(100))
    state.create_lightpath = Mock()
    state.create_protected_lightpath = Mock()
    state.get_lightpath = Mock()
    state.release_lightpath = Mock()
    state.active_lightpaths = []
    return state


@pytest.fixture
def mock_request():
    """Mock request."""
    request = Mock()
    request.source = "A"
    request.destination = "D"
    request.bandwidth_gbps = 100
    request.arrival_time = 0.0
    request.holding_time = 100.0
    return request


@pytest.fixture
def mock_path_options():
    """Mock path options."""
    from fusion.rl.adapter import PathOption

    return [
        PathOption(
            path_index=0,
            path=("A", "B", "D"),
            weight_km=200.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=8,
            congestion=0.3,
        ),
        PathOption(
            path_index=1,
            path=("A", "C", "D"),
            weight_km=200.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=8,
            congestion=0.5,
        ),
    ]


@pytest.fixture
def mock_protected_options():
    """Mock protected path options."""
    from fusion.rl.adapter import PathOption

    return [
        PathOption(
            path_index=0,
            path=("A", "B", "D"),
            weight_km=200.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=8,
            congestion=0.3,
            backup_path=("A", "C", "D"),
            backup_feasible=True,
            is_protected=True,
        ),
    ]
```

### 3. Orchestrator Policy Tests

```python
"""Tests for orchestrator policy integration."""

import pytest
from unittest.mock import Mock, patch

from fusion.core.orchestrator import SDNOrchestrator, AllocationResult, BlockReason
from fusion.policies.heuristic_policy import (
    FirstFeasiblePolicy,
    ShortestFeasiblePolicy,
)


class TestOrchestratorPolicy:
    """Test suite for orchestrator policy integration."""

    def test_default_policy_first_feasible(
        self, mock_config, mock_pipelines
    ) -> None:
        """Should use FirstFeasiblePolicy when none provided."""
        orchestrator = SDNOrchestrator(
            config=mock_config,
            pipelines=mock_pipelines,
            policy=None,
        )

        assert isinstance(orchestrator.policy, FirstFeasiblePolicy)

    def test_custom_policy_used(
        self, mock_config, mock_pipelines
    ) -> None:
        """Should use provided policy."""
        policy = ShortestFeasiblePolicy()
        orchestrator = SDNOrchestrator(
            config=mock_config,
            pipelines=mock_pipelines,
            policy=policy,
        )

        assert orchestrator.policy is policy

    def test_policy_select_action_called(
        self, mock_config, mock_pipelines, mock_network_state,
        mock_request, mock_path_options
    ) -> None:
        """Should call policy.select_action during handling."""
        policy = Mock()
        policy.get_name = Mock(return_value="MockPolicy")
        policy.select_action = Mock(return_value=0)
        policy.update = Mock()

        orchestrator = SDNOrchestrator(
            config=mock_config,
            pipelines=mock_pipelines,
            policy=policy,
        )

        # Mock adapter
        adapter = Mock()
        adapter.get_path_options = Mock(return_value=mock_path_options)
        adapter.apply_action = Mock(return_value=(
            AllocationResult(success=True, lightpath_id="lp-001"),
            1.0,
        ))
        orchestrator.set_adapter(adapter)

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        policy.select_action.assert_called_once()
        policy.update.assert_called_once()

    def test_policy_update_called_with_reward(
        self, mock_config, mock_pipelines, mock_network_state,
        mock_request, mock_path_options
    ) -> None:
        """Should call policy.update with correct reward."""
        policy = Mock()
        policy.get_name = Mock(return_value="MockPolicy")
        policy.select_action = Mock(return_value=0)
        policy.update = Mock()

        orchestrator = SDNOrchestrator(
            config=mock_config,
            pipelines=mock_pipelines,
            policy=policy,
        )

        adapter = Mock()
        adapter.get_path_options = Mock(return_value=mock_path_options)
        expected_reward = 0.8
        adapter.apply_action = Mock(return_value=(
            AllocationResult(success=True, lightpath_id="lp-001"),
            expected_reward,
        ))
        orchestrator.set_adapter(adapter)

        orchestrator.handle_arrival(mock_request, mock_network_state)

        # Check update was called with correct reward
        call_args = policy.update.call_args
        assert call_args[0][2] == expected_reward

    def test_invalid_action_fallback(
        self, mock_config, mock_pipelines, mock_network_state,
        mock_request, mock_path_options
    ) -> None:
        """Should fallback when policy returns invalid action."""
        policy = Mock()
        policy.get_name = Mock(return_value="MockPolicy")
        policy.select_action = Mock(return_value=-1)  # Invalid
        policy.update = Mock()

        orchestrator = SDNOrchestrator(
            config=mock_config,
            pipelines=mock_pipelines,
            policy=policy,
        )

        adapter = Mock()
        adapter.get_path_options = Mock(return_value=mock_path_options)
        adapter.apply_action = Mock(return_value=(
            AllocationResult(success=True, lightpath_id="lp-001"),
            1.0,
        ))
        orchestrator.set_adapter(adapter)

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        # Should still succeed via fallback
        # apply_action should be called with first feasible (0)
        apply_call_args = adapter.apply_action.call_args
        assert apply_call_args[0][0] == 0  # First feasible index

    def test_no_feasible_options_blocks(
        self, mock_config, mock_pipelines, mock_network_state, mock_request
    ) -> None:
        """Should block when no feasible options."""
        orchestrator = SDNOrchestrator(
            config=mock_config,
            pipelines=mock_pipelines,
        )

        # Mock adapter returns infeasible options
        adapter = Mock()
        adapter.get_path_options = Mock(return_value=[
            Mock(is_feasible=False, path_index=0),
        ])
        orchestrator.set_adapter(adapter)

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        assert not result.success
        assert result.block_reason == BlockReason.NO_SPECTRUM
```

### 4. PolicyFactory Tests

```python
"""Tests for PolicyFactory."""

import pytest
from unittest.mock import Mock, patch

from fusion.policies.policy_factory import PolicyFactory, PolicyType


class TestPolicyFactory:
    """Test suite for PolicyFactory."""

    def test_create_first_feasible(self, mock_config) -> None:
        """Should create FirstFeasiblePolicy."""
        mock_config.policy_type = "first_feasible"
        policy = PolicyFactory.create(mock_config)

        from fusion.policies.heuristic_policy import FirstFeasiblePolicy
        assert isinstance(policy, FirstFeasiblePolicy)

    def test_create_shortest_feasible(self, mock_config) -> None:
        """Should create ShortestFeasiblePolicy."""
        mock_config.policy_type = "shortest_feasible"
        policy = PolicyFactory.create(mock_config)

        from fusion.policies.heuristic_policy import ShortestFeasiblePolicy
        assert isinstance(policy, ShortestFeasiblePolicy)

    def test_create_least_congested(self, mock_config) -> None:
        """Should create LeastCongestedPolicy."""
        mock_config.policy_type = "least_congested"
        policy = PolicyFactory.create(mock_config)

        from fusion.policies.heuristic_policy import LeastCongestedPolicy
        assert isinstance(policy, LeastCongestedPolicy)

    def test_create_random_with_seed(self, mock_config) -> None:
        """Should create RandomFeasiblePolicy with seed."""
        mock_config.policy_type = "random"
        mock_config.policy_random_seed = 42
        policy = PolicyFactory.create(mock_config)

        from fusion.policies.heuristic_policy import RandomFeasiblePolicy
        assert isinstance(policy, RandomFeasiblePolicy)

    def test_create_ml_requires_path(self, mock_config) -> None:
        """Should raise when ML policy has no model_path."""
        mock_config.policy_type = "ml"
        mock_config.policy_model_path = None

        with pytest.raises(ValueError, match="model_path"):
            PolicyFactory.create(mock_config)

    def test_unknown_type_fallback(self, mock_config) -> None:
        """Should fallback to first_feasible for unknown type."""
        mock_config.policy_type = "unknown_policy_xyz"
        policy = PolicyFactory.create(mock_config)

        from fusion.policies.heuristic_policy import FirstFeasiblePolicy
        assert isinstance(policy, FirstFeasiblePolicy)

    def test_create_by_type(self) -> None:
        """Should create policy by explicit type."""
        policy = PolicyFactory.create_by_type(PolicyType.LEAST_CONGESTED)

        from fusion.policies.heuristic_policy import LeastCongestedPolicy
        assert isinstance(policy, LeastCongestedPolicy)

    def test_get_available_types(self) -> None:
        """Should list available policy types."""
        types = PolicyFactory.get_available_types()

        assert "first_feasible" in types
        assert "shortest_feasible" in types
        assert "ml" in types
```

### 5. Protection Integration Tests

```python
"""Tests for protection integration in orchestrator."""

import pytest
from unittest.mock import Mock, patch

from fusion.core.orchestrator import SDNOrchestrator, AllocationResult, BlockReason
from fusion.pipelines.protection_pipeline import (
    ProtectionPipeline,
    ProtectionConfig,
    RecoveryResult,
    SwitchoverAction,
)


class TestProtectionIntegration:
    """Test suite for protection integration."""

    def test_protection_enabled_flag(
        self, mock_config_protected, mock_pipelines
    ) -> None:
        """Should detect protection enabled."""
        protection_pipeline = Mock()
        orchestrator = SDNOrchestrator(
            config=mock_config_protected,
            pipelines=mock_pipelines,
            protection_pipeline=protection_pipeline,
        )

        assert orchestrator._protection_enabled

    def test_protected_arrival_uses_protection_pipeline(
        self, mock_config_protected, mock_pipelines, mock_network_state,
        mock_request, mock_protected_options
    ) -> None:
        """Should use ProtectionPipeline for protected arrivals."""
        protection_pipeline = Mock()
        route_result = Mock()
        route_result.paths = [["A", "B", "D"]]
        route_result.backup_paths = [["A", "C", "D"]]
        route_result.weights_km = [200.0]
        route_result.modulations = [["QPSK"]]
        route_result.backup_modulations = [["QPSK"]]
        protection_pipeline.find_protected_routes = Mock(return_value=route_result)

        allocation_result = Mock()
        allocation_result.success = True
        allocation_result.start_slot = 10
        allocation_result.end_slot = 18
        protection_pipeline.allocate_protected = Mock(return_value=allocation_result)

        policy = Mock()
        policy.get_name = Mock(return_value="MockPolicy")
        policy.select_action = Mock(return_value=0)
        policy.update = Mock()

        orchestrator = SDNOrchestrator(
            config=mock_config_protected,
            pipelines=mock_pipelines,
            policy=policy,
            protection_pipeline=protection_pipeline,
        )

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        protection_pipeline.find_protected_routes.assert_called_once()
        protection_pipeline.allocate_protected.assert_called_once()

    def test_no_disjoint_paths_blocks(
        self, mock_config_protected, mock_pipelines, mock_network_state, mock_request
    ) -> None:
        """Should block when no disjoint paths found."""
        protection_pipeline = Mock()
        route_result = Mock()
        route_result.paths = []
        protection_pipeline.find_protected_routes = Mock(return_value=route_result)

        orchestrator = SDNOrchestrator(
            config=mock_config_protected,
            pipelines=mock_pipelines,
            protection_pipeline=protection_pipeline,
        )

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        assert not result.success
        assert result.block_reason == BlockReason.NO_DISJOINT_PATHS

    def test_failure_triggers_switchover(
        self, mock_config_protected, mock_pipelines, mock_network_state
    ) -> None:
        """Should trigger switchover on failure event."""
        protection_pipeline = Mock()
        recovery_result = RecoveryResult(
            failure_type=Mock(),
            failed_element=("A", "B"),
            timestamp=100.0,
            switchovers=[
                SwitchoverAction(
                    lightpath_id="lp-001",
                    from_path="primary",
                    to_path="backup",
                    latency_ms=50.0,
                    timestamp=100.0,
                ),
            ],
        )
        protection_pipeline.handle_link_failure = Mock(return_value=recovery_result)

        orchestrator = SDNOrchestrator(
            config=mock_config_protected,
            pipelines=mock_pipelines,
            protection_pipeline=protection_pipeline,
        )

        # Call failure handler directly
        result = orchestrator.protection_pipeline.handle_link_failure(
            ("A", "B"), mock_network_state, 100.0
        )

        assert len(result.switchovers) == 1
        assert result.switchovers[0].to_path == "backup"

    def test_metrics_tracked(
        self, mock_config, mock_pipelines, mock_network_state,
        mock_request, mock_path_options
    ) -> None:
        """Should track orchestrator metrics."""
        orchestrator = SDNOrchestrator(
            config=mock_config,
            pipelines=mock_pipelines,
        )

        adapter = Mock()
        adapter.get_path_options = Mock(return_value=mock_path_options)
        adapter.apply_action = Mock(return_value=(
            AllocationResult(success=True, lightpath_id="lp-001"),
            1.0,
        ))
        orchestrator.set_adapter(adapter)

        # Handle one arrival
        orchestrator.handle_arrival(mock_request, mock_network_state)

        metrics = orchestrator.get_metrics()
        assert metrics["arrivals_handled"] == 1
        assert metrics["successful_allocations"] == 1
        assert metrics["blocked_requests"] == 0
```

### 6. Acceptance Criteria

| Criterion | Test Coverage |
|-----------|---------------|
| Default policy is FirstFeasible | `test_default_policy_first_feasible` |
| Policy.select_action called | `test_policy_select_action_called` |
| Policy.update called with reward | `test_policy_update_called_with_reward` |
| Invalid action triggers fallback | `test_invalid_action_fallback` |
| PolicyFactory creates all types | `test_create_*` tests |
| Protection uses pipeline | `test_protected_arrival_uses_protection_pipeline` |
| Failure triggers switchover | `test_failure_triggers_switchover` |
| Metrics tracked | `test_metrics_tracked` |

---

## Verification Commands

```bash
# Run orchestrator tests
pytest fusion/core/tests/test_orchestrator_policy.py -v

# Run policy factory tests
pytest fusion/core/tests/test_policy_factory.py -v

# Run all with coverage
pytest fusion/core/tests/ -v --cov=fusion/core --cov-report=term-missing

# Type checking
mypy fusion/core/orchestrator.py
mypy fusion/policies/policy_factory.py

# Lint checking
ruff check fusion/core/
ruff check fusion/policies/
```

---

## Exit Criteria for P5.5

- [ ] All unit tests pass
- [ ] Orchestrator uses configured policy
- [ ] PolicyFactory creates all policy types
- [ ] Protection pipeline integrated when enabled
- [ ] Failure handling triggers switchovers
- [ ] Metrics tracked accurately
- [ ] Type checking passes
- [ ] Lint checking passes

---

## Next Sub-Phase

After P5.5 verification, proceed to **P5.6 Configuration Extension**.
