# P5.5 Shared Context: Orchestrator Flow

**Sub-phase:** P5.5
**Scope:** Orchestrator Integration

---

## Overview

This document captures the shared context for integrating policies and protection into the SDNOrchestrator.

---

## Current Orchestrator Architecture

### SDNOrchestrator Role

The SDNOrchestrator coordinates:
- Request arrival handling
- Routing decisions
- Spectrum assignment
- Lightpath establishment
- Departure handling

### Current Request Flow

```
Request Arrival
    │
    ▼
SDNOrchestrator.handle_arrival()
    │
    ├── Routing Pipeline: Find paths
    │
    ├── Spectrum Pipeline: Assign spectrum
    │
    └── NetworkState: Create lightpath
    │
    ▼
AllocationResult
```

---

## Target Architecture with Policy

### New Request Flow

```
Request Arrival
    │
    ▼
SDNOrchestrator.handle_arrival_with_policy()
    │
    ├── RLSimulationAdapter.get_path_options()
    │       │
    │       └── Returns list[PathOption]
    │
    ├── ControlPolicy.select_action()
    │       │
    │       └── Returns action index
    │
    ├── RLSimulationAdapter.apply_action()
    │       │
    │       └── Allocate selected path
    │
    └── ControlPolicy.update() (optional)
    │
    ▼
AllocationResult
```

---

## Key Integration Points

### 1. Policy Injection

```python
class SDNOrchestrator:
    def __init__(
        self,
        config: SimulationConfig,
        pipelines: PipelineSet,
        policy: ControlPolicy | None = None,  # NEW
    ):
        self.policy = policy or FirstFeasiblePolicy()
```

### 2. PathOption Generation

Uses RLSimulationAdapter to convert routing results to PathOptions:

```python
def get_path_options(
    self,
    source: str,
    destination: str,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> list[PathOption]:
    """Generate PathOptions from routing pipeline."""
    route_result = self._routing.find_routes(
        source, destination, bandwidth_gbps, network_state
    )

    options = []
    for i, path in enumerate(route_result.paths):
        # Evaluate feasibility, congestion, etc.
        option = PathOption(
            path_index=i,
            path=tuple(path),
            weight_km=route_result.weights_km[i],
            is_feasible=self._check_feasibility(path, bandwidth_gbps),
            modulation=route_result.modulations[i][0],
            slots_needed=self._calculate_slots(bandwidth_gbps, mod),
            congestion=self._calculate_congestion(path, network_state),
        )
        options.append(option)

    return options
```

### 3. Action Application

```python
def apply_action(
    self,
    action: int,
    request: Request,
    options: list[PathOption],
    network_state: NetworkState,
) -> tuple[AllocationResult, float]:
    """Apply selected action and compute reward."""
    if action < 0 or action >= len(options):
        return AllocationResult(success=False), -1.0

    opt = options[action]
    if not opt.is_feasible:
        return AllocationResult(success=False), -1.0

    # Allocate spectrum
    result = self._allocate_path(opt, request, network_state)

    # Compute reward
    reward = self._compute_reward(result, opt)

    return result, reward
```

---

## Protection Integration

### When Protection Enabled

```python
class SDNOrchestrator:
    def handle_arrival_with_policy(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        # Check if protection enabled
        if self.config.protection_enabled:
            return self._handle_protected_arrival(request, network_state)
        else:
            return self._handle_unprotected_arrival(request, network_state)

    def _handle_protected_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """Handle arrival with protection."""
        # Use protection pipeline
        route_result = self._protection_pipeline.find_protected_routes(
            request.source,
            request.destination,
            request.bandwidth_gbps,
            network_state,
        )

        if not route_result.paths:
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_DISJOINT_PATHS,
            )

        # Build options with backup paths
        options = self._build_protected_options(route_result, network_state)

        # Use policy to select
        action = self.policy.select_action(request, options, network_state)

        # Apply action (allocates both paths)
        return self._apply_protected_action(action, request, options, network_state)
```

### Protected PathOption

```python
def _build_protected_options(
    self,
    route_result: RouteResult,
    network_state: NetworkState,
) -> list[PathOption]:
    """Build PathOptions with backup information."""
    options = []

    for i in range(len(route_result.paths)):
        primary = route_result.paths[i]
        backup = route_result.backup_paths[i] if route_result.backup_paths else None

        option = PathOption(
            path_index=i,
            path=tuple(primary),
            weight_km=route_result.weights_km[i],
            is_feasible=self._check_protected_feasibility(primary, backup),
            modulation=route_result.modulations[i][0],
            slots_needed=self._calculate_slots(...),
            congestion=self._calculate_congestion(primary, network_state),
            backup_path=tuple(backup) if backup else None,
            backup_feasible=self._check_feasibility(backup) if backup else None,
            is_protected=backup is not None,
        )
        options.append(option)

    return options
```

---

## PolicyFactory Design

### Factory Pattern

```python
class PolicyFactory:
    """Factory for creating control policies."""

    @staticmethod
    def create(config: SimulationConfig) -> ControlPolicy:
        """Create policy from configuration."""
        policy_type = config.policy_type

        if policy_type == "first_feasible":
            return FirstFeasiblePolicy()
        elif policy_type == "shortest_feasible":
            return ShortestFeasiblePolicy()
        elif policy_type == "least_congested":
            return LeastCongestedPolicy()
        elif policy_type == "random":
            seed = config.policy_random_seed
            return RandomFeasiblePolicy(seed=seed)
        elif policy_type == "load_balanced":
            alpha = config.policy_load_balance_alpha
            return LoadBalancedPolicy(alpha=alpha)
        elif policy_type == "ml":
            return MLControlPolicy(
                model_path=config.policy_model_path,
                device=config.policy_device,
            )
        else:
            logger.warning(f"Unknown policy type: {policy_type}, using default")
            return FirstFeasiblePolicy()
```

---

## PipelineFactory Extension

### Creating Orchestrator with Policy

```python
class PipelineFactory:
    @staticmethod
    def create_orchestrator(config: SimulationConfig) -> SDNOrchestrator:
        """Create orchestrator with all pipelines and policy."""
        # Create pipelines
        pipelines = PipelineSet(
            routing=PipelineFactory.create_routing(config),
            spectrum=PipelineFactory.create_spectrum(config),
            snr=PipelineFactory.create_snr(config),
        )

        # Create policy
        policy = PolicyFactory.create(config)

        # Create protection pipeline if enabled
        protection = None
        if config.protection_enabled:
            protection = ProtectionPipeline(
                ProtectionConfig.from_simulation_config(config)
            )

        return SDNOrchestrator(
            config=config,
            pipelines=pipelines,
            policy=policy,
            protection_pipeline=protection,
        )
```

---

## Configuration Mapping

| Config Field | Policy/Pipeline |
|--------------|-----------------|
| `policy_type` | Which ControlPolicy to instantiate |
| `policy_model_path` | MLControlPolicy model file |
| `policy_device` | MLControlPolicy inference device |
| `policy_random_seed` | RandomFeasiblePolicy seed |
| `policy_load_balance_alpha` | LoadBalancedPolicy alpha |
| `protection_enabled` | Whether to use ProtectionPipeline |
| `protection_disjointness` | Link or node disjoint |
| `protection_switchover_ms` | Switchover latency |

---

## Backward Compatibility

### Legacy Support

The orchestrator must support both:
1. **New path**: `handle_arrival_with_policy()` using ControlPolicy
2. **Legacy path**: `handle_arrival()` using existing logic

```python
class SDNOrchestrator:
    def handle_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """Legacy arrival handling (for backward compatibility)."""
        if self.policy is not None:
            return self.handle_arrival_with_policy(request, network_state)

        # Original logic
        return self._legacy_handle_arrival(request, network_state)
```

---

## References

- `fusion/core/orchestrator.py` (current implementation)
- `fusion/modules/rl/adapter.py` (RLSimulationAdapter)
- `fusion/core/pipeline_factory.py` (current factory)
- `.claude/v4-docs/migration/phase_5_ml_protection.md`
