# Task ID: P5.5.d - Wire Protection Flows

**Sub-phase:** P5.5
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** wiring-plan

---

## Purpose

Wire the ProtectionPipeline into the orchestrator and simulation loop for failure handling and protected lightpath management.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.c_wire_policy_to_orchestrator.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.g_implement_protection_pipeline.md`

---

## Outputs

### 1. Protection Flow Integration Points

```
Simulation Event Loop
    │
    ├── ARRIVAL Event
    │       │
    │       └── orchestrator.handle_arrival()
    │               │
    │               └── [protection_enabled?]
    │                       │
    │                       ├── Yes: _handle_protected_arrival()
    │                       │         └── ProtectionPipeline.find_protected_routes()
    │                       │         └── ProtectionPipeline.allocate_protected()
    │                       │
    │                       └── No: _handle_unprotected_arrival()
    │
    ├── DEPARTURE Event
    │       │
    │       └── orchestrator.handle_departure()
    │               │
    │               └── [is_protected?]
    │                       │
    │                       ├── Yes: release both paths
    │                       │
    │                       └── No: release single path
    │
    └── FAILURE Event
            │
            └── orchestrator.handle_failure()
                    │
                    └── ProtectionPipeline.handle_link_failure()
                            │
                            └── Switchover actions
```

### 2. Failure Event Handling

```python
"""
Failure event handling integration.
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from enum import Enum
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.core.orchestrator import SDNOrchestrator
    from fusion.domain.network_state import NetworkState
    from fusion.pipelines.protection_pipeline import RecoveryResult

logger = logging.getLogger(__name__)


class EventType(Enum):
    """Types of simulation events."""

    ARRIVAL = "arrival"
    DEPARTURE = "departure"
    FAILURE = "failure"
    REPAIR = "repair"


@dataclass
class FailureEvent:
    """Network failure event."""

    event_type: EventType = EventType.FAILURE
    timestamp: float = 0.0
    failure_type: str = "link"  # "link" or "node"
    failed_element: tuple[str, str] | str = None  # Link tuple or node ID


@dataclass
class RepairEvent:
    """Network repair event."""

    event_type: EventType = EventType.REPAIR
    timestamp: float = 0.0
    repaired_element: tuple[str, str] | str = None


class FailureEventHandler:
    """
    Handle failure events in simulation.

    Coordinates failure detection, switchover triggering,
    and recovery metric recording.

    Attributes:
        orchestrator: SDN orchestrator reference
        network_state: Network state reference

    Example:
        >>> handler = FailureEventHandler(orchestrator, network_state)
        >>> result = handler.process_failure(failure_event)
    """

    def __init__(
        self,
        orchestrator: SDNOrchestrator,
        network_state: NetworkState,
    ) -> None:
        """Initialize handler."""
        self.orchestrator = orchestrator
        self.network_state = network_state

        # Track failures
        self._failure_count = 0
        self._recovery_count = 0
        self._lost_count = 0

    def process_failure(self, event: FailureEvent) -> RecoveryResult | None:
        """
        Process a failure event.

        Args:
            event: Failure event to process

        Returns:
            RecoveryResult if protection enabled, None otherwise
        """
        self._failure_count += 1

        if not self.orchestrator._protection_enabled:
            # Without protection, mark affected lightpaths as failed
            self._handle_unprotected_failure(event)
            return None

        # Use protection pipeline
        if event.failure_type == "link":
            result = self.orchestrator.protection_pipeline.handle_link_failure(
                failed_link=event.failed_element,
                network_state=self.network_state,
                current_time=event.timestamp,
            )
        else:
            result = self.orchestrator.protection_pipeline.handle_node_failure(
                failed_node=event.failed_element,
                network_state=self.network_state,
                current_time=event.timestamp,
            )

        # Update statistics
        self._recovery_count += len(result.switchovers)
        self._lost_count += len(result.lost_lightpaths)

        # Log results
        if result.switchovers:
            logger.info(
                f"Failure at {event.failed_element}: "
                f"{len(result.switchovers)} switchovers, "
                f"{len(result.lost_lightpaths)} lost"
            )

        return result

    def _handle_unprotected_failure(self, event: FailureEvent) -> None:
        """Handle failure without protection."""
        affected = self.network_state.get_lightpaths_on_link(event.failed_element)
        for lp in affected:
            self.network_state.mark_lightpath_failed(lp.lightpath_id)
            self._lost_count += 1
            logger.info(f"Lightpath {lp.lightpath_id} lost (no protection)")

    def process_repair(self, event: RepairEvent) -> list:
        """
        Process a repair event.

        Args:
            event: Repair event

        Returns:
            List of reversion actions (if revert enabled)
        """
        if not self.orchestrator._protection_enabled:
            return []

        # Handle repair with optional revert
        return self.orchestrator.protection_pipeline._failure_handler.handle_repair(
            repaired_element=event.repaired_element,
            network_state=self.network_state,
            current_time=event.timestamp,
        )

    def get_metrics(self) -> dict:
        """Get failure handling metrics."""
        return {
            "failure_count": self._failure_count,
            "recovery_count": self._recovery_count,
            "lost_count": self._lost_count,
            "recovery_rate": (
                self._recovery_count / self._failure_count
                if self._failure_count > 0 else 0.0
            ),
        }
```

### 3. Extended Simulation Loop

```python
"""
Simulation main loop with full protection support.
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING

from fusion.core.orchestrator import SDNOrchestrator, PipelineSet
from fusion.core.pipeline_factory import PipelineFactory
from fusion.policies.policy_factory import PolicyFactory
from fusion.pipelines.protection_pipeline import ProtectionPipeline, ProtectionConfig

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig

logger = logging.getLogger(__name__)


class Simulation:
    """
    Main simulation class with protection support.

    Orchestrates the complete simulation including:
    - Request arrivals and departures
    - Policy-based path selection
    - Protection and failure handling

    Example:
        >>> sim = Simulation(config)
        >>> results = sim.run()
    """

    def __init__(self, config: SimulationConfig) -> None:
        """Initialize simulation."""
        self.config = config

        # Create orchestrator with all components
        self.orchestrator = self._create_orchestrator()

        # Create network state
        self.network_state = self._create_network_state()

        # Set up failure handler
        self.failure_handler = FailureEventHandler(
            self.orchestrator,
            self.network_state,
        )

        # Event queue
        self.event_queue = EventQueue()

        # Results tracking
        self._results = SimulationResults()

    def _create_orchestrator(self) -> SDNOrchestrator:
        """Create fully configured orchestrator."""
        # Create pipelines
        pipelines = PipelineSet(
            routing=PipelineFactory.create_routing(self.config),
            spectrum=PipelineFactory.create_spectrum(self.config),
            snr=PipelineFactory.create_snr(self.config),
        )

        # Create policy
        policy = PolicyFactory.create(self.config)

        # Create protection pipeline if enabled
        protection_pipeline = None
        if getattr(self.config, "protection_enabled", False):
            protection_config = ProtectionConfig(
                enabled=True,
                disjointness=DisjointnessType(
                    getattr(self.config, "protection_disjointness", "link")
                ),
                switchover_time_ms=getattr(
                    self.config, "protection_switchover_ms", 50.0
                ),
                revert_after_repair=getattr(
                    self.config, "protection_revert_after_repair", False
                ),
            )
            protection_pipeline = ProtectionPipeline(protection_config)

        return SDNOrchestrator(
            config=self.config,
            pipelines=pipelines,
            policy=policy,
            protection_pipeline=protection_pipeline,
        )

    def _create_network_state(self) -> NetworkState:
        """Create network state from config."""
        from fusion.domain.network_state import NetworkState
        return NetworkState(self.config)

    def run(self) -> SimulationResults:
        """
        Run the simulation.

        Returns:
            Simulation results
        """
        logger.info(f"Starting simulation with policy={self.orchestrator.policy.get_name()}")

        # Generate events
        self._generate_events()

        # Process events
        while not self.event_queue.is_empty():
            event = self.event_queue.pop()
            self._process_event(event)

        # Finalize results
        self._results.finalize(
            orchestrator_metrics=self.orchestrator.get_metrics(),
            failure_metrics=self.failure_handler.get_metrics(),
        )

        logger.info(f"Simulation complete: {self._results.summary()}")

        return self._results

    def _generate_events(self) -> None:
        """Generate all simulation events."""
        # Generate arrival/departure events
        self._generate_traffic_events()

        # Generate failure events if configured
        if getattr(self.config, "failure_enabled", False):
            self._generate_failure_events()

    def _generate_traffic_events(self) -> None:
        """Generate traffic arrival and departure events."""
        # Traffic generation logic
        ...

    def _generate_failure_events(self) -> None:
        """Generate failure events based on configuration."""
        failure_config = getattr(self.config, "failure_config", None)
        if failure_config is None:
            return

        # Generate failures based on MTTF
        ...

    def _process_event(self, event: Event) -> None:
        """Process a single event."""
        if event.event_type == EventType.ARRIVAL:
            result = self.orchestrator.handle_arrival(
                event.request, self.network_state
            )
            self._results.record_arrival(result)

        elif event.event_type == EventType.DEPARTURE:
            self.orchestrator.handle_departure(
                event.lightpath_id, self.network_state
            )
            self._results.record_departure(event.lightpath_id)

        elif event.event_type == EventType.FAILURE:
            result = self.failure_handler.process_failure(event)
            if result:
                self._results.record_failure(result)

        elif event.event_type == EventType.REPAIR:
            reversions = self.failure_handler.process_repair(event)
            self._results.record_repair(reversions)


@dataclass
class SimulationResults:
    """Simulation results container."""

    arrivals: int = 0
    blocked: int = 0
    successful: int = 0
    failures: int = 0
    switchovers: int = 0
    lost_lightpaths: int = 0

    def record_arrival(self, result: AllocationResult) -> None:
        """Record arrival result."""
        self.arrivals += 1
        if result.success:
            self.successful += 1
        else:
            self.blocked += 1

    def record_departure(self, lightpath_id: str) -> None:
        """Record departure."""
        pass

    def record_failure(self, result: RecoveryResult) -> None:
        """Record failure result."""
        self.failures += 1
        self.switchovers += len(result.switchovers)
        self.lost_lightpaths += len(result.lost_lightpaths)

    def record_repair(self, reversions: list) -> None:
        """Record repair reversions."""
        pass

    def finalize(
        self,
        orchestrator_metrics: dict,
        failure_metrics: dict,
    ) -> None:
        """Finalize results."""
        self._orchestrator_metrics = orchestrator_metrics
        self._failure_metrics = failure_metrics

    @property
    def blocking_probability(self) -> float:
        """Calculate blocking probability."""
        if self.arrivals == 0:
            return 0.0
        return self.blocked / self.arrivals

    @property
    def recovery_rate(self) -> float:
        """Calculate recovery rate."""
        total_affected = self.switchovers + self.lost_lightpaths
        if total_affected == 0:
            return 1.0
        return self.switchovers / total_affected

    def summary(self) -> str:
        """Get summary string."""
        return (
            f"arrivals={self.arrivals}, "
            f"blocked={self.blocked} ({self.blocking_probability:.2%}), "
            f"failures={self.failures}, "
            f"switchovers={self.switchovers}, "
            f"recovery_rate={self.recovery_rate:.2%}"
        )
```

### 4. Departure Handling with Protection

```python
# Extended handle_departure in orchestrator

def handle_departure(
    self,
    lightpath_id: str,
    network_state: NetworkState,
) -> bool:
    """
    Handle lightpath departure.

    For protected lightpaths, releases spectrum on both paths.

    Args:
        lightpath_id: Lightpath to release
        network_state: Current state

    Returns:
        True if successful
    """
    lightpath = network_state.get_lightpath(lightpath_id)
    if lightpath is None:
        return False

    # Release spectrum
    if lightpath.is_protected and self._protection_enabled:
        # Release both paths
        self.protection_pipeline._spectrum_allocator.deallocate(
            primary_path=lightpath.path,
            backup_path=lightpath.backup_path,
            start_slot=lightpath.spectrum_start,
            end_slot=lightpath.spectrum_end,
            network_state=network_state,
        )
    else:
        # Release single path
        for i in range(len(lightpath.path) - 1):
            link = (lightpath.path[i], lightpath.path[i + 1])
            network_state.deallocate_spectrum(
                link,
                lightpath.spectrum_start,
                lightpath.spectrum_end,
            )

    # Remove lightpath
    network_state.remove_lightpath(lightpath_id)

    return True
```

---

## Verification

- [ ] Failure events processed correctly
- [ ] Switchovers triggered for protected lightpaths
- [ ] Unprotected lightpaths marked as lost
- [ ] Departures release both paths if protected
- [ ] Repair events handled when revert enabled
- [ ] Metrics track all recovery statistics

---

## Next Task

Proceed to **P5.5.e** to create the verification plan.
