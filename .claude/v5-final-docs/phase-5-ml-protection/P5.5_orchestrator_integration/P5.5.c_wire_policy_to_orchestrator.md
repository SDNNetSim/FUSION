# Task ID: P5.5.c - Wire Policy to Orchestrator

**Sub-phase:** P5.5
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** wiring-plan

---

## Purpose

Provide the complete wiring plan for integrating ControlPolicy into the SDNOrchestrator and simulation loop.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.a_design_policy_in_orchestrator.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.b_design_policy_factory.md`

---

## Outputs

### 1. File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `fusion/core/orchestrator.py` | Modify | Add policy integration |
| `fusion/core/pipeline_factory.py` | Modify | Add policy creation |
| `fusion/policies/__init__.py` | Create | Export policies |
| `fusion/policies/policy_factory.py` | Create | PolicyFactory class |
| `fusion/core/simulation.py` | Modify | Use policy-based handling |

### 2. Complete Orchestrator Implementation

**File:** `fusion/core/orchestrator.py`

```python
"""
SDN Orchestrator for network resource management.

This module provides the SDNOrchestrator class that coordinates
routing, spectrum assignment, and lightpath establishment,
with support for policy-based decision making.
"""

from __future__ import annotations

import logging
import uuid
from dataclasses import dataclass
from enum import Enum
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.interfaces.control_policy import ControlPolicy
    from fusion.pipelines.protection_pipeline import ProtectionPipeline
    from fusion.rl.adapter import PathOption, RLSimulationAdapter

logger = logging.getLogger(__name__)


class BlockReason(Enum):
    """Reasons for request blocking."""

    NO_PATH = "no_path"
    NO_SPECTRUM = "no_spectrum"
    SNR_FAILED = "snr_failed"
    INVALID_ACTION = "invalid_action"
    NO_DISJOINT_PATHS = "no_disjoint_paths"
    PROTECTION_INFEASIBLE = "protection_infeasible"


@dataclass(frozen=True)
class AllocationResult:
    """Result of lightpath allocation attempt."""

    success: bool
    lightpath_id: str | None = None
    path: list[str] | None = None
    spectrum_start: int | None = None
    spectrum_end: int | None = None
    modulation: str | None = None
    block_reason: BlockReason | None = None
    backup_path: list[str] | None = None
    is_protected: bool = False


@dataclass
class PipelineSet:
    """Collection of processing pipelines."""

    routing: Any
    spectrum: Any
    snr: Any | None = None


class SDNOrchestrator:
    """
    SDN Orchestrator for network resource management.

    Coordinates routing, spectrum assignment, and lightpath
    establishment with policy-based decision making.

    Attributes:
        config: Simulation configuration
        routing: Routing pipeline
        spectrum: Spectrum assignment pipeline
        snr: SNR measurement pipeline
        policy: Control policy for path selection
        protection_pipeline: Optional 1+1 protection pipeline

    Example:
        >>> orchestrator = SDNOrchestrator(
        ...     config=config,
        ...     pipelines=pipelines,
        ...     policy=FirstFeasiblePolicy(),
        ... )
        >>> result = orchestrator.handle_arrival(request, network_state)
    """

    def __init__(
        self,
        config: SimulationConfig,
        pipelines: PipelineSet,
        policy: ControlPolicy | None = None,
        protection_pipeline: ProtectionPipeline | None = None,
    ) -> None:
        """
        Initialize orchestrator.

        Args:
            config: Simulation configuration
            pipelines: Processing pipelines
            policy: Control policy (default: FirstFeasiblePolicy)
            protection_pipeline: Optional protection pipeline
        """
        self.config = config
        self.routing = pipelines.routing
        self.spectrum = pipelines.spectrum
        self.snr = pipelines.snr

        # Initialize policy
        if policy is None:
            from fusion.policies.heuristic_policy import FirstFeasiblePolicy
            policy = FirstFeasiblePolicy()
        self.policy = policy

        # Protection
        self.protection_pipeline = protection_pipeline
        self._protection_enabled = protection_pipeline is not None

        # Adapter for PathOption generation
        self._adapter: RLSimulationAdapter | None = None

        # Metrics
        self._arrivals_handled = 0
        self._successful_allocations = 0
        self._blocked_requests = 0

        logger.info(
            f"Orchestrator initialized: policy={policy.get_name()}, "
            f"protection={'enabled' if self._protection_enabled else 'disabled'}"
        )

    def set_adapter(self, adapter: RLSimulationAdapter) -> None:
        """Set RL simulation adapter for PathOption generation."""
        self._adapter = adapter

    def handle_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """
        Handle request arrival using configured policy.

        Main entry point for request handling. Delegates to
        appropriate handler based on protection configuration.

        Args:
            request: Incoming request
            network_state: Current network state

        Returns:
            AllocationResult with outcome
        """
        self._arrivals_handled += 1

        if self._protection_enabled:
            result = self._handle_protected_arrival(request, network_state)
        else:
            result = self._handle_unprotected_arrival(request, network_state)

        if result.success:
            self._successful_allocations += 1
        else:
            self._blocked_requests += 1

        return result

    def _handle_unprotected_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """Handle unprotected request using policy."""
        # Ensure adapter is available
        if self._adapter is None:
            return self._handle_arrival_legacy(request, network_state)

        # Generate PathOptions
        options = self._adapter.get_path_options(
            request.source,
            request.destination,
            request.bandwidth_gbps,
            network_state,
        )

        if not options:
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_PATH,
            )

        if not any(opt.is_feasible for opt in options):
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_SPECTRUM,
            )

        # Use policy to select action
        action = self.policy.select_action(request, options, network_state)

        # Validate action
        if not self._is_valid_action(action, options):
            action = self._find_first_feasible(options)
            if action < 0:
                return AllocationResult(
                    success=False,
                    block_reason=BlockReason.NO_SPECTRUM,
                )

        # Apply action
        result, reward = self._adapter.apply_action(
            action, request, options, network_state
        )

        # Update policy
        self.policy.update(request, action, reward)

        return result

    def _handle_protected_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """Handle protected request using protection pipeline."""
        # Find protected routes
        route_result = self.protection_pipeline.find_protected_routes(
            request.source,
            request.destination,
            request.bandwidth_gbps,
            network_state,
        )

        if not route_result.paths:
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_DISJOINT_PATHS,
            )

        # Build protected PathOptions
        options = self._build_protected_options(
            route_result, request, network_state
        )

        if not any(opt.both_paths_feasible for opt in options):
            return AllocationResult(
                success=False,
                block_reason=BlockReason.PROTECTION_INFEASIBLE,
            )

        # Policy selection
        action = self.policy.select_action(request, options, network_state)

        # Validate
        if action < 0 or not options[action].both_paths_feasible:
            action = self._find_first_protected_feasible(options)
            if action < 0:
                return AllocationResult(
                    success=False,
                    block_reason=BlockReason.PROTECTION_INFEASIBLE,
                )

        # Apply protected action
        return self._apply_protected_action(
            action, request, options, network_state
        )

    def _handle_arrival_legacy(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """Legacy arrival handling without adapter."""
        # Direct routing and allocation
        route_result = self.routing.find_routes(
            request.source,
            request.destination,
            request.bandwidth_gbps,
            network_state,
        )

        if not route_result.paths:
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_PATH,
            )

        # Try first feasible path
        for i, path in enumerate(route_result.paths):
            modulation = route_result.modulations[i][0] if route_result.modulations[i] else None
            if modulation is None:
                continue

            # Try spectrum assignment
            spectrum_result = self.spectrum.assign(
                path=path,
                slots_needed=self._calculate_slots(request.bandwidth_gbps, modulation),
                network_state=network_state,
            )

            if spectrum_result.success:
                # Create lightpath
                lightpath_id = f"lp-{uuid.uuid4().hex[:8]}"
                network_state.create_lightpath(
                    lightpath_id=lightpath_id,
                    source=request.source,
                    destination=request.destination,
                    path=path,
                    spectrum_start=spectrum_result.start_slot,
                    spectrum_end=spectrum_result.end_slot,
                    modulation=modulation,
                    bandwidth_gbps=request.bandwidth_gbps,
                    created_at=request.arrival_time,
                )

                return AllocationResult(
                    success=True,
                    lightpath_id=lightpath_id,
                    path=path,
                    spectrum_start=spectrum_result.start_slot,
                    spectrum_end=spectrum_result.end_slot,
                    modulation=modulation,
                )

        return AllocationResult(
            success=False,
            block_reason=BlockReason.NO_SPECTRUM,
        )

    def _build_protected_options(
        self,
        route_result: Any,
        request: Request,
        network_state: NetworkState,
    ) -> list[PathOption]:
        """Build PathOptions with protection info."""
        from fusion.rl.adapter import PathOption

        options = []
        for i in range(len(route_result.paths)):
            primary = route_result.paths[i]
            backup = route_result.backup_paths[i] if route_result.backup_paths else None

            modulation = route_result.modulations[i][0] if route_result.modulations[i] else "QPSK"

            option = PathOption(
                path_index=i,
                path=tuple(primary),
                weight_km=route_result.weights_km[i],
                is_feasible=True,  # Pre-validated by protection pipeline
                modulation=modulation,
                slots_needed=self._calculate_slots(request.bandwidth_gbps, modulation),
                congestion=self._calculate_congestion(primary, network_state),
                backup_path=tuple(backup) if backup else None,
                backup_feasible=True if backup else None,
                is_protected=backup is not None,
            )
            options.append(option)

        return options

    def _apply_protected_action(
        self,
        action: int,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> AllocationResult:
        """Apply protected action with dual allocation."""
        opt = options[action]

        # Allocate on both paths
        allocation = self.protection_pipeline.allocate_protected(
            primary_path=list(opt.path),
            backup_path=list(opt.backup_path),
            slots_needed=opt.slots_needed,
            network_state=network_state,
        )

        if not allocation.success:
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_SPECTRUM,
            )

        # Create protected lightpath
        lightpath_id = f"lp-{uuid.uuid4().hex[:8]}"
        network_state.create_protected_lightpath(
            lightpath_id=lightpath_id,
            primary_path=list(opt.path),
            backup_path=list(opt.backup_path),
            spectrum_start=allocation.start_slot,
            spectrum_end=allocation.end_slot,
            modulation=opt.modulation,
            backup_modulation=opt.modulation,
            bandwidth_gbps=request.bandwidth_gbps,
            created_at=request.arrival_time,
            expires_at=request.arrival_time + request.holding_time if request.holding_time else None,
        )

        # Compute reward
        reward = 1.0 - (opt.weight_km / 10000.0)
        self.policy.update(request, action, reward)

        return AllocationResult(
            success=True,
            lightpath_id=lightpath_id,
            path=list(opt.path),
            spectrum_start=allocation.start_slot,
            spectrum_end=allocation.end_slot,
            modulation=opt.modulation,
            backup_path=list(opt.backup_path),
            is_protected=True,
        )

    def _is_valid_action(self, action: int, options: list[PathOption]) -> bool:
        """Check if action is valid."""
        if action < 0 or action >= len(options):
            return False
        return options[action].is_feasible

    def _find_first_feasible(self, options: list[PathOption]) -> int:
        """Find first feasible option."""
        for i, opt in enumerate(options):
            if opt.is_feasible:
                return i
        return -1

    def _find_first_protected_feasible(self, options: list[PathOption]) -> int:
        """Find first option with both paths feasible."""
        for i, opt in enumerate(options):
            if opt.both_paths_feasible:
                return i
        return -1

    def _calculate_slots(self, bandwidth_gbps: int, modulation: str) -> int:
        """Calculate required spectrum slots."""
        slots_map = {"BPSK": 16, "QPSK": 8, "8QAM": 6, "16QAM": 4}
        return slots_map.get(modulation, 8)

    def _calculate_congestion(
        self,
        path: list[str],
        network_state: NetworkState,
    ) -> float:
        """Calculate path congestion."""
        if not path:
            return 1.0

        total_used = 0
        total_capacity = 0

        for i in range(len(path) - 1):
            link = (path[i], path[i + 1])
            spectrum = network_state.get_link_spectrum(link)
            if spectrum is not None:
                total_used += spectrum.sum()
                total_capacity += len(spectrum)

        return total_used / total_capacity if total_capacity > 0 else 1.0

    def handle_departure(
        self,
        lightpath_id: str,
        network_state: NetworkState,
    ) -> bool:
        """Handle lightpath departure."""
        lightpath = network_state.get_lightpath(lightpath_id)
        if lightpath is None:
            return False

        # Release spectrum
        network_state.release_lightpath(lightpath_id)
        return True

    def get_metrics(self) -> dict[str, Any]:
        """Get orchestrator metrics."""
        return {
            "arrivals_handled": self._arrivals_handled,
            "successful_allocations": self._successful_allocations,
            "blocked_requests": self._blocked_requests,
            "blocking_probability": (
                self._blocked_requests / self._arrivals_handled
                if self._arrivals_handled > 0 else 0.0
            ),
            "policy": self.policy.get_name(),
            "protection_enabled": self._protection_enabled,
        }
```

### 3. Simulation Loop Integration

```python
# In simulation main loop
def run_simulation(config: SimulationConfig) -> SimulationResult:
    """Run simulation with policy-based handling."""
    # Create orchestrator with policy
    orchestrator = PipelineFactory.create_orchestrator(config)

    # Create network state
    network_state = NetworkState(config)

    # Set up adapter
    adapter = RLSimulationAdapter(config, orchestrator)
    orchestrator.set_adapter(adapter)

    # Event loop
    for event in event_queue:
        if event.type == EventType.ARRIVAL:
            result = orchestrator.handle_arrival(event.request, network_state)
            record_result(result)

        elif event.type == EventType.DEPARTURE:
            orchestrator.handle_departure(event.lightpath_id, network_state)

        elif event.type == EventType.FAILURE:
            if orchestrator._protection_enabled:
                recovery = orchestrator.protection_pipeline.handle_link_failure(
                    event.failed_link,
                    network_state,
                    event.timestamp,
                )
                record_recovery(recovery)

    return compute_final_results(orchestrator, network_state)
```

---

## Verification

- [ ] Orchestrator uses configured policy
- [ ] PathOptions generated correctly
- [ ] Policy.select_action called
- [ ] Policy.update called after action
- [ ] Protected handling works
- [ ] Legacy fallback works without adapter
- [ ] Metrics tracked correctly

---

## Next Task

Proceed to **P5.5.d** to wire protection flows.
