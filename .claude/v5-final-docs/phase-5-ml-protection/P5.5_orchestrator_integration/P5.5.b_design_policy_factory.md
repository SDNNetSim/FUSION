# Task ID: P5.5.b - Design PolicyFactory

**Sub-phase:** P5.5
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the PolicyFactory class that creates ControlPolicy instances from configuration.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.shared_context_orchestrator_flow.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.e_implement_heuristic_policies.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.3_ml_policy_support/P5.3.e_implement_ml_policy.md`

---

## Outputs

### 1. PolicyFactory Class Design

```python
"""
Factory for creating control policies from configuration.

This module provides the PolicyFactory class that instantiates
appropriate ControlPolicy implementations based on configuration.
"""

from __future__ import annotations

import logging
from enum import Enum
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.interfaces.control_policy import ControlPolicy

logger = logging.getLogger(__name__)


class PolicyType(Enum):
    """Supported policy types."""

    FIRST_FEASIBLE = "first_feasible"
    SHORTEST_FEASIBLE = "shortest_feasible"
    LEAST_CONGESTED = "least_congested"
    RANDOM = "random"
    LOAD_BALANCED = "load_balanced"
    ML = "ml"
    RL = "rl"

    @classmethod
    def from_string(cls, value: str) -> "PolicyType":
        """Create PolicyType from string, with fallback."""
        try:
            return cls(value.lower())
        except ValueError:
            logger.warning(f"Unknown policy type '{value}', using first_feasible")
            return cls.FIRST_FEASIBLE


class PolicyFactory:
    """
    Factory for creating ControlPolicy instances.

    Creates policy instances based on configuration settings.
    Supports heuristic, ML, and RL policy types.

    Example:
        >>> policy = PolicyFactory.create(config)
        >>> # Or with explicit type
        >>> policy = PolicyFactory.create_by_type(
        ...     PolicyType.LEAST_CONGESTED
        ... )
    """

    @staticmethod
    def create(config: SimulationConfig) -> ControlPolicy:
        """
        Create policy from simulation configuration.

        Args:
            config: Simulation configuration with policy settings

        Returns:
            Configured ControlPolicy instance

        Example:
            >>> config = SimulationConfig(policy_type="shortest_feasible")
            >>> policy = PolicyFactory.create(config)
            >>> isinstance(policy, ShortestFeasiblePolicy)
            True
        """
        policy_type = PolicyType.from_string(
            getattr(config, "policy_type", "first_feasible")
        )

        return PolicyFactory.create_by_type(policy_type, config)

    @staticmethod
    def create_by_type(
        policy_type: PolicyType,
        config: SimulationConfig | None = None,
    ) -> ControlPolicy:
        """
        Create policy by explicit type.

        Args:
            policy_type: Type of policy to create
            config: Optional configuration for policy parameters

        Returns:
            ControlPolicy instance
        """
        if policy_type == PolicyType.FIRST_FEASIBLE:
            return PolicyFactory._create_first_feasible()

        elif policy_type == PolicyType.SHORTEST_FEASIBLE:
            return PolicyFactory._create_shortest_feasible()

        elif policy_type == PolicyType.LEAST_CONGESTED:
            return PolicyFactory._create_least_congested()

        elif policy_type == PolicyType.RANDOM:
            seed = getattr(config, "policy_random_seed", None) if config else None
            return PolicyFactory._create_random(seed)

        elif policy_type == PolicyType.LOAD_BALANCED:
            alpha = getattr(config, "policy_load_balance_alpha", 0.5) if config else 0.5
            return PolicyFactory._create_load_balanced(alpha)

        elif policy_type == PolicyType.ML:
            if config is None:
                raise ValueError("ML policy requires configuration")
            return PolicyFactory._create_ml(config)

        elif policy_type == PolicyType.RL:
            if config is None:
                raise ValueError("RL policy requires configuration")
            return PolicyFactory._create_rl(config)

        else:
            logger.warning(f"Unknown policy type: {policy_type}, using first_feasible")
            return PolicyFactory._create_first_feasible()

    @staticmethod
    def _create_first_feasible() -> ControlPolicy:
        """Create FirstFeasiblePolicy."""
        from fusion.policies.heuristic_policy import FirstFeasiblePolicy
        return FirstFeasiblePolicy()

    @staticmethod
    def _create_shortest_feasible() -> ControlPolicy:
        """Create ShortestFeasiblePolicy."""
        from fusion.policies.heuristic_policy import ShortestFeasiblePolicy
        return ShortestFeasiblePolicy()

    @staticmethod
    def _create_least_congested() -> ControlPolicy:
        """Create LeastCongestedPolicy."""
        from fusion.policies.heuristic_policy import LeastCongestedPolicy
        return LeastCongestedPolicy()

    @staticmethod
    def _create_random(seed: int | None = None) -> ControlPolicy:
        """Create RandomFeasiblePolicy."""
        from fusion.policies.heuristic_policy import RandomFeasiblePolicy
        return RandomFeasiblePolicy(seed=seed)

    @staticmethod
    def _create_load_balanced(alpha: float = 0.5) -> ControlPolicy:
        """Create LoadBalancedPolicy."""
        from fusion.policies.heuristic_policy import LoadBalancedPolicy
        return LoadBalancedPolicy(alpha=alpha)

    @staticmethod
    def _create_ml(config: SimulationConfig) -> ControlPolicy:
        """Create MLControlPolicy from config."""
        from fusion.policies.ml_policy import MLControlPolicy

        model_path = getattr(config, "policy_model_path", None)
        if not model_path:
            raise ValueError("ML policy requires policy_model_path in config")

        device = getattr(config, "policy_device", "cpu")
        fallback_type = getattr(config, "policy_fallback_type", "first_feasible")
        k_paths = getattr(config, "k_paths", 5)

        return MLControlPolicy(
            model_path=model_path,
            device=device,
            fallback_type=fallback_type,
            k_paths=k_paths,
        )

    @staticmethod
    def _create_rl(config: SimulationConfig) -> ControlPolicy:
        """Create RL-based policy from config."""
        from fusion.policies.ml_policy import MLControlPolicy

        model_path = getattr(config, "policy_model_path", None)
        if not model_path:
            raise ValueError("RL policy requires policy_model_path in config")

        device = getattr(config, "policy_device", "cpu")

        # RL policies use same MLControlPolicy with PyTorch model
        return MLControlPolicy(
            model_path=model_path,
            device=device,
            model_type="pytorch",
        )

    @staticmethod
    def get_available_types() -> list[str]:
        """Get list of available policy type names."""
        return [pt.value for pt in PolicyType]

    @staticmethod
    def create_with_fallback(
        primary_type: PolicyType,
        fallback_type: PolicyType = PolicyType.FIRST_FEASIBLE,
        config: SimulationConfig | None = None,
    ) -> ControlPolicy:
        """
        Create policy with fallback on failure.

        Attempts to create primary policy type. If it fails (e.g., missing
        model file for ML policy), creates fallback policy instead.

        Args:
            primary_type: Preferred policy type
            fallback_type: Fallback policy type
            config: Configuration

        Returns:
            Created policy (primary or fallback)
        """
        try:
            return PolicyFactory.create_by_type(primary_type, config)
        except Exception as e:
            logger.warning(
                f"Failed to create {primary_type.value} policy: {e}, "
                f"using {fallback_type.value}"
            )
            return PolicyFactory.create_by_type(fallback_type, config)


class PolicyRegistry:
    """
    Registry for custom policy types.

    Allows registration of custom policy classes that can be
    instantiated via the factory.

    Example:
        >>> PolicyRegistry.register("custom", MyCustomPolicy)
        >>> policy = PolicyRegistry.create("custom", **kwargs)
    """

    _registry: dict[str, type] = {}

    @classmethod
    def register(cls, name: str, policy_class: type) -> None:
        """
        Register a custom policy class.

        Args:
            name: Name to register under
            policy_class: Policy class (must implement ControlPolicy)
        """
        cls._registry[name.lower()] = policy_class
        logger.info(f"Registered policy: {name}")

    @classmethod
    def create(cls, name: str, **kwargs: Any) -> ControlPolicy:
        """
        Create policy from registry.

        Args:
            name: Registered policy name
            **kwargs: Arguments to pass to policy constructor

        Returns:
            Policy instance

        Raises:
            KeyError: If policy name not registered
        """
        name_lower = name.lower()
        if name_lower not in cls._registry:
            raise KeyError(f"Policy '{name}' not registered")

        return cls._registry[name_lower](**kwargs)

    @classmethod
    def list_registered(cls) -> list[str]:
        """List registered policy names."""
        return list(cls._registry.keys())

    @classmethod
    def is_registered(cls, name: str) -> bool:
        """Check if policy name is registered."""
        return name.lower() in cls._registry
```

### 2. Integration with PipelineFactory

```python
# In fusion/core/pipeline_factory.py

class PipelineFactory:
    """Extended to include policy creation."""

    @staticmethod
    def create_orchestrator(config: SimulationConfig) -> SDNOrchestrator:
        """
        Create fully configured SDNOrchestrator.

        Args:
            config: Simulation configuration

        Returns:
            Configured orchestrator with policy and pipelines
        """
        from fusion.policies.policy_factory import PolicyFactory
        from fusion.pipelines.protection_pipeline import (
            ProtectionPipeline,
            ProtectionConfig,
        )

        # Create pipelines
        pipelines = PipelineSet(
            routing=PipelineFactory.create_routing(config),
            spectrum=PipelineFactory.create_spectrum(config),
            snr=PipelineFactory.create_snr(config),
        )

        # Create policy
        policy = PolicyFactory.create(config)

        # Create protection pipeline if enabled
        protection_pipeline = None
        if getattr(config, "protection_enabled", False):
            protection_config = ProtectionConfig.from_dict({
                "enabled": True,
                "disjointness": getattr(config, "protection_disjointness", "link"),
                "switchover_time_ms": getattr(config, "protection_switchover_ms", 50.0),
                "revert_after_repair": getattr(config, "protection_revert_after_repair", False),
            })
            protection_pipeline = ProtectionPipeline(protection_config)

        return SDNOrchestrator(
            config=config,
            pipelines=pipelines,
            policy=policy,
            protection_pipeline=protection_pipeline,
        )
```

### 3. Usage Examples

```python
# Creating policies

# From config
config = SimulationConfig(policy_type="shortest_feasible")
policy = PolicyFactory.create(config)

# By explicit type
policy = PolicyFactory.create_by_type(PolicyType.LEAST_CONGESTED)

# ML policy
config = SimulationConfig(
    policy_type="ml",
    policy_model_path="models/bc_policy.pt",
    policy_device="cuda",
)
policy = PolicyFactory.create(config)

# With fallback
policy = PolicyFactory.create_with_fallback(
    primary_type=PolicyType.ML,
    fallback_type=PolicyType.FIRST_FEASIBLE,
    config=config,
)

# Custom policy via registry
PolicyRegistry.register("my_policy", MyCustomPolicy)
policy = PolicyRegistry.create("my_policy", param1=value1)
```

### 4. Design Rationale

| Decision | Rationale |
|----------|-----------|
| PolicyType enum | Type-safe policy selection |
| Static factory methods | Simple API, no state needed |
| Lazy imports | Avoid circular imports |
| create_with_fallback | Graceful degradation |
| PolicyRegistry | Support custom policies |
| Config parameter extraction | Flexible configuration |

---

## Verification

- [ ] All heuristic policies creatable
- [ ] ML policy requires model_path
- [ ] Unknown types fallback to first_feasible
- [ ] create_with_fallback handles errors
- [ ] Registry allows custom policies
- [ ] PipelineFactory integration works

---

## Test Cases to Implement

```python
class TestPolicyFactory:
    """Tests for PolicyFactory."""

    def test_create_first_feasible(self) -> None:
        """Should create FirstFeasiblePolicy."""
        config = SimulationConfig(policy_type="first_feasible")
        policy = PolicyFactory.create(config)
        assert isinstance(policy, FirstFeasiblePolicy)

    def test_create_shortest_feasible(self) -> None:
        """Should create ShortestFeasiblePolicy."""
        policy = PolicyFactory.create_by_type(PolicyType.SHORTEST_FEASIBLE)
        assert isinstance(policy, ShortestFeasiblePolicy)

    def test_create_ml_requires_path(self) -> None:
        """Should raise when ML policy has no model_path."""
        config = SimulationConfig(policy_type="ml")
        with pytest.raises(ValueError, match="policy_model_path"):
            PolicyFactory.create(config)

    def test_unknown_type_fallback(self) -> None:
        """Should fallback to first_feasible for unknown type."""
        config = SimulationConfig(policy_type="unknown_policy")
        policy = PolicyFactory.create(config)
        assert isinstance(policy, FirstFeasiblePolicy)

    def test_create_with_fallback(self) -> None:
        """Should use fallback on primary failure."""
        config = SimulationConfig(policy_type="ml")  # No model_path
        policy = PolicyFactory.create_with_fallback(
            PolicyType.ML,
            PolicyType.LEAST_CONGESTED,
            config,
        )
        assert isinstance(policy, LeastCongestedPolicy)

    def test_registry(self) -> None:
        """Should create policy from registry."""

        class CustomPolicy:
            def select_action(self, *args):
                return 0
            def update(self, *args):
                pass

        PolicyRegistry.register("custom", CustomPolicy)
        policy = PolicyRegistry.create("custom")
        assert isinstance(policy, CustomPolicy)
```

---

## Next Task

Proceed to **P5.5.c** to wire the policy to the orchestrator.
