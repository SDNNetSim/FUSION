# Task ID: P5.5.a - Design Policy Integration in Orchestrator

**Sub-phase:** P5.5
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design how the ControlPolicy integrates into SDNOrchestrator for policy-based request handling.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.shared_context_orchestrator_flow.md`
- `fusion/core/orchestrator.py` (if exists)
- `.claude/v5-final-docs/phase-5-ml-protection/P5.1_control_policy_protocol/P5.1.b_design_control_policy_protocol.md`

---

## Outputs

### 1. SDNOrchestrator Extension Design

```python
"""
SDNOrchestrator with ControlPolicy integration.

This module extends the SDNOrchestrator to support policy-based
request handling using the ControlPolicy protocol.
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import AllocationResult
    from fusion.interfaces.control_policy import ControlPolicy
    from fusion.pipelines.protection_pipeline import ProtectionPipeline
    from fusion.rl.adapter import PathOption

logger = logging.getLogger(__name__)


class SDNOrchestrator:
    """
    SDN Orchestrator for network resource management.

    Coordinates routing, spectrum assignment, and lightpath
    establishment. Extended to support ControlPolicy-based
    decision making for path selection.

    Attributes:
        config: Simulation configuration
        routing: Routing pipeline
        spectrum: Spectrum assignment pipeline
        policy: Control policy for path selection
        protection_pipeline: Optional protection pipeline
        adapter: RL simulation adapter for PathOption generation

    Example:
        >>> orchestrator = SDNOrchestrator(
        ...     config=config,
        ...     pipelines=pipelines,
        ...     policy=FirstFeasiblePolicy(),
        ... )
        >>> result = orchestrator.handle_arrival_with_policy(request, state)
    """

    def __init__(
        self,
        config: SimulationConfig,
        pipelines: PipelineSet,
        policy: ControlPolicy | None = None,
        protection_pipeline: ProtectionPipeline | None = None,
    ) -> None:
        """
        Initialize orchestrator with pipelines and policy.

        Args:
            config: Simulation configuration
            pipelines: Set of processing pipelines
            policy: Control policy for path selection (default: FirstFeasiblePolicy)
            protection_pipeline: Optional 1+1 protection pipeline
        """
        self.config = config
        self.routing = pipelines.routing
        self.spectrum = pipelines.spectrum
        self.snr = pipelines.snr

        # Policy defaults to FirstFeasiblePolicy
        if policy is None:
            from fusion.policies.heuristic_policy import FirstFeasiblePolicy
            policy = FirstFeasiblePolicy()
        self.policy = policy

        # Optional protection
        self.protection_pipeline = protection_pipeline
        self._protection_enabled = protection_pipeline is not None

        # Create adapter for PathOption generation
        self._adapter = RLSimulationAdapter(config, self)

        logger.info(
            f"SDNOrchestrator initialized with policy={policy.get_name()}, "
            f"protection={'enabled' if self._protection_enabled else 'disabled'}"
        )

    def handle_arrival_with_policy(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """
        Handle request arrival using configured policy.

        This is the main entry point for policy-based request handling.
        It generates PathOptions, uses the policy to select an action,
        and applies the selected action.

        Args:
            request: Incoming request
            network_state: Current network state

        Returns:
            AllocationResult indicating success or failure

        Example:
            >>> result = orchestrator.handle_arrival_with_policy(request, state)
            >>> if result.success:
            ...     print(f"Allocated lightpath: {result.lightpath_id}")
        """
        # Route to appropriate handler based on protection
        if self._protection_enabled:
            return self._handle_protected_arrival(request, network_state)
        else:
            return self._handle_unprotected_arrival(request, network_state)

    def _handle_unprotected_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """
        Handle unprotected request arrival.

        Args:
            request: Incoming request
            network_state: Current network state

        Returns:
            AllocationResult
        """
        # Generate PathOptions
        options = self._adapter.get_path_options(
            request.source,
            request.destination,
            request.bandwidth_gbps,
            network_state,
        )

        # Check if any options are feasible
        if not options or not any(opt.is_feasible for opt in options):
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_SPECTRUM,
            )

        # Use policy to select action
        action = self.policy.select_action(request, options, network_state)

        # Validate action
        if action < 0 or action >= len(options):
            return AllocationResult(
                success=False,
                block_reason=BlockReason.INVALID_ACTION,
            )

        if not options[action].is_feasible:
            logger.warning(
                f"Policy selected infeasible action {action}, "
                "falling back to first feasible"
            )
            action = self._find_first_feasible(options)
            if action < 0:
                return AllocationResult(
                    success=False,
                    block_reason=BlockReason.NO_SPECTRUM,
                )

        # Apply action
        result, reward = self._adapter.apply_action(
            action, request, options, network_state
        )

        # Update policy (for learning policies)
        self.policy.update(request, action, reward)

        return result

    def _handle_protected_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """
        Handle protected request arrival using ProtectionPipeline.

        Args:
            request: Incoming request
            network_state: Current network state

        Returns:
            AllocationResult with protected lightpath
        """
        # Find protected routes
        route_result = self.protection_pipeline.find_protected_routes(
            request.source,
            request.destination,
            request.bandwidth_gbps,
            network_state,
        )

        if not route_result.paths:
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_DISJOINT_PATHS,
            )

        # Build PathOptions with protection info
        options = self._build_protected_options(route_result, network_state)

        if not options or not any(opt.both_paths_feasible for opt in options):
            return AllocationResult(
                success=False,
                block_reason=BlockReason.PROTECTION_INFEASIBLE,
            )

        # Use policy to select
        action = self.policy.select_action(request, options, network_state)

        # Validate
        if action < 0 or not options[action].both_paths_feasible:
            action = self._find_first_protected_feasible(options)
            if action < 0:
                return AllocationResult(
                    success=False,
                    block_reason=BlockReason.PROTECTION_INFEASIBLE,
                )

        # Apply protected action
        result, reward = self._apply_protected_action(
            action, request, options, network_state
        )

        self.policy.update(request, action, reward)

        return result

    def _build_protected_options(
        self,
        route_result: RouteResult,
        network_state: NetworkState,
    ) -> list[PathOption]:
        """Build PathOptions with backup path information."""
        from fusion.rl.adapter import PathOption

        options = []

        for i in range(len(route_result.paths)):
            primary = route_result.paths[i]
            backup = route_result.backup_paths[i] if route_result.backup_paths else None

            # Check feasibility of both paths
            primary_feasible = self._check_feasibility(
                primary, route_result.modulations[i]
            )
            backup_feasible = (
                self._check_feasibility(backup, route_result.backup_modulations[i])
                if backup else False
            )

            option = PathOption(
                path_index=i,
                path=tuple(primary),
                weight_km=route_result.weights_km[i],
                is_feasible=primary_feasible,
                modulation=route_result.modulations[i][0] if route_result.modulations[i] else None,
                slots_needed=self._calculate_slots(
                    route_result.modulations[i][0] if route_result.modulations[i] else "QPSK"
                ),
                congestion=self._calculate_congestion(primary, network_state),
                backup_path=tuple(backup) if backup else None,
                backup_feasible=backup_feasible,
                is_protected=backup is not None,
            )
            options.append(option)

        return options

    def _apply_protected_action(
        self,
        action: int,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> tuple[AllocationResult, float]:
        """Apply protected action (allocate both paths)."""
        opt = options[action]

        # Allocate spectrum on both paths
        allocation = self.protection_pipeline.allocate_protected(
            primary_path=list(opt.path),
            backup_path=list(opt.backup_path),
            slots_needed=opt.slots_needed,
            network_state=network_state,
        )

        if not allocation.success:
            return AllocationResult(
                success=False,
                block_reason=BlockReason.NO_SPECTRUM,
            ), -1.0

        # Create protected lightpath
        lightpath = network_state.create_protected_lightpath(
            lightpath_id=self._generate_lightpath_id(),
            primary_path=list(opt.path),
            backup_path=list(opt.backup_path),
            spectrum_start=allocation.start_slot,
            spectrum_end=allocation.end_slot,
            modulation=opt.modulation,
            backup_modulation=opt.modulation,  # Same for 1+1
            bandwidth_gbps=request.bandwidth_gbps,
            created_at=request.arrival_time,
            expires_at=request.arrival_time + request.holding_time,
        )

        result = AllocationResult(
            success=True,
            lightpath_id=lightpath.lightpath_id,
            path=list(opt.path),
            backup_path=list(opt.backup_path),
            spectrum_start=allocation.start_slot,
            spectrum_end=allocation.end_slot,
            is_protected=True,
        )

        reward = self._compute_reward(result, opt)

        return result, reward

    def _find_first_feasible(self, options: list[PathOption]) -> int:
        """Find first feasible option index."""
        for i, opt in enumerate(options):
            if opt.is_feasible:
                return i
        return -1

    def _find_first_protected_feasible(self, options: list[PathOption]) -> int:
        """Find first option with both paths feasible."""
        for i, opt in enumerate(options):
            if opt.both_paths_feasible:
                return i
        return -1

    def _generate_lightpath_id(self) -> str:
        """Generate unique lightpath ID."""
        import uuid
        return f"lp-{uuid.uuid4().hex[:8]}"

    def _compute_reward(
        self,
        result: AllocationResult,
        option: PathOption,
    ) -> float:
        """Compute reward for action."""
        if not result.success:
            return -1.0

        # Reward based on efficiency
        # Shorter paths and less congestion = higher reward
        path_efficiency = 1.0 - (option.weight_km / 10000.0)
        congestion_bonus = 1.0 - option.congestion

        return 0.5 * path_efficiency + 0.5 * congestion_bonus

    def _check_feasibility(
        self,
        path: list[str],
        modulations: list[str],
    ) -> bool:
        """Check if path is feasible."""
        if not path or not modulations:
            return False
        return any(mod is not None for mod in modulations)

    def _calculate_slots(self, modulation: str) -> int:
        """Calculate slots needed for modulation."""
        # Simplified calculation
        slots_map = {"BPSK": 16, "QPSK": 8, "8QAM": 6, "16QAM": 4}
        return slots_map.get(modulation, 8)

    def _calculate_congestion(
        self,
        path: list[str],
        network_state: NetworkState,
    ) -> float:
        """Calculate path congestion (0-1)."""
        if not path:
            return 1.0

        total_used = 0
        total_capacity = 0

        for i in range(len(path) - 1):
            link = (path[i], path[i + 1])
            spectrum = network_state.get_link_spectrum(link)
            if spectrum is not None:
                total_used += spectrum.sum()
                total_capacity += len(spectrum)

        if total_capacity == 0:
            return 1.0

        return total_used / total_capacity

    # Legacy method for backward compatibility
    def handle_arrival(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> AllocationResult:
        """
        Handle arrival (backward compatible).

        Delegates to handle_arrival_with_policy if policy is set.
        """
        return self.handle_arrival_with_policy(request, network_state)
```

### 2. BlockReason Extension

```python
from enum import Enum


class BlockReason(Enum):
    """Reasons for request blocking."""

    NO_PATH = "no_path"
    NO_SPECTRUM = "no_spectrum"
    SNR_FAILED = "snr_failed"
    INVALID_ACTION = "invalid_action"
    # Protection-specific
    NO_DISJOINT_PATHS = "no_disjoint_paths"
    PROTECTION_INFEASIBLE = "protection_infeasible"
```

### 3. AllocationResult Extension

```python
@dataclass(frozen=True)
class AllocationResult:
    """Result of allocation attempt."""

    success: bool
    lightpath_id: str | None = None
    path: list[str] | None = None
    spectrum_start: int | None = None
    spectrum_end: int | None = None
    block_reason: BlockReason | None = None
    # Protection fields
    backup_path: list[str] | None = None
    is_protected: bool = False
```

### 4. Design Rationale

| Decision | Rationale |
|----------|-----------|
| Policy defaults to FirstFeasible | Safe default, no model required |
| Adapter generates PathOptions | Reuse RL infrastructure |
| Separate protected/unprotected handlers | Clear separation of concerns |
| Fallback on invalid action | Robustness against policy errors |
| Policy update after action | Support learning policies |

---

## Verification

- [ ] Orchestrator accepts ControlPolicy
- [ ] Default policy used when none provided
- [ ] handle_arrival_with_policy works
- [ ] Protected arrivals handled separately
- [ ] Invalid actions trigger fallback
- [ ] Reward computed and passed to policy.update()

---

## Next Task

Proceed to **P5.5.b** to design the PolicyFactory.
