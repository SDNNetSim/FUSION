# Task ID: P5.6.d - Implement Configuration Extension

**Sub-phase:** P5.6
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** wiring-plan

---

## Purpose

Provide the complete implementation of Phase 5 configuration extensions including schema, loader, validation, and CLI integration.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.6_configuration_extension/P5.6.a_design_policy_config.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.6_configuration_extension/P5.6.b_design_protection_config.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.6_configuration_extension/P5.6.c_design_heuristic_config.md`

---

## Outputs

### 1. Extended Configuration Schema

**File:** `fusion/configs/schema.py` (extension)

```python
"""
Configuration schema extension for Phase 5.

Adds [policy], [protection], and [heuristic] configuration sections.
"""

from typing import Any


# Policy configuration schema
POLICY_SCHEMA = {
    "type": {
        "type": str,
        "default": "first_feasible",
        "choices": [
            "first_feasible", "shortest_feasible", "least_congested",
            "random", "load_balanced", "ml", "rl",
        ],
    },
    "model_path": {"type": str, "default": "", "nullable": True},
    "device": {"type": str, "default": "cpu", "choices": ["cpu", "cuda"]},
    "model_type": {
        "type": str,
        "default": "",
        "choices": ["", "pytorch", "sklearn", "onnx"],
        "nullable": True,
    },
    "fallback_type": {
        "type": str,
        "default": "first_feasible",
        "choices": ["first_feasible", "shortest_feasible", "least_congested"],
    },
    "k_paths": {"type": int, "default": 5, "min": 1, "max": 20},
}

# Protection configuration schema
PROTECTION_SCHEMA = {
    "enabled": {"type": bool, "default": False},
    "disjointness": {
        "type": str,
        "default": "link",
        "choices": ["link", "node"],
    },
    "switchover_time_ms": {
        "type": float,
        "default": 50.0,
        "min": 0.0,
        "max": 1000.0,
    },
    "revert_after_repair": {"type": bool, "default": False},
    "guard_band_slots": {"type": int, "default": 1, "min": 0, "max": 5},
}

# Heuristic configuration schema
HEURISTIC_SCHEMA = {
    "load_balance_alpha": {
        "type": float,
        "default": 0.5,
        "min": 0.0,
        "max": 1.0,
    },
    "random_seed": {"type": int, "default": None, "nullable": True},
    "congestion_threshold": {
        "type": float,
        "default": 0.8,
        "min": 0.0,
        "max": 1.0,
    },
    "tie_breaker": {
        "type": str,
        "default": "first",
        "choices": ["first", "random", "shortest"],
    },
}


def register_phase5_schemas() -> None:
    """Register Phase 5 configuration schemas."""
    from fusion.configs.schema import CONFIG_SCHEMA

    CONFIG_SCHEMA["policy"] = POLICY_SCHEMA
    CONFIG_SCHEMA["protection"] = PROTECTION_SCHEMA
    CONFIG_SCHEMA["heuristic"] = HEURISTIC_SCHEMA
```

### 2. Extended SimulationConfig

**File:** `fusion/domain/config.py` (extension)

```python
"""
SimulationConfig extension for Phase 5.

Adds policy, protection, and heuristic configuration fields.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.pipelines.protection_pipeline import ProtectionConfig


@dataclass
class SimulationConfig:
    """
    Complete simulation configuration.

    Includes Phase 5 extensions for policy, protection, and heuristics.
    """

    # ========== Existing fields ==========
    # Simulation
    name: str = "experiment"
    seed: int = 42
    num_requests: int = 10000

    # Network
    topology: str = "NSFNet"
    num_slots: int = 320
    slot_width: float = 12.5

    # Traffic
    arrival_rate: float = 50.0
    holding_time: float = 10.0
    bandwidth_min: int = 25
    bandwidth_max: int = 400

    # Routing
    route_algorithm: str = "k_shortest_path"
    k_paths: int = 5

    # ========== Phase 5: Policy ==========
    policy_type: str = "first_feasible"
    policy_model_path: str | None = None
    policy_device: str = "cpu"
    policy_model_type: str | None = None
    policy_fallback_type: str = "first_feasible"

    # ========== Phase 5: Protection ==========
    protection_enabled: bool = False
    protection_disjointness: str = "link"
    protection_switchover_ms: float = 50.0
    protection_revert_after_repair: bool = False
    protection_guard_band_slots: int = 1

    # ========== Phase 5: Heuristic ==========
    heuristic_load_balance_alpha: float = 0.5
    heuristic_random_seed: int | None = None
    heuristic_congestion_threshold: float = 0.8
    heuristic_tie_breaker: str = "first"

    # ========== Methods ==========

    def get_policy_config(self) -> dict[str, Any]:
        """Get policy configuration as dictionary."""
        return {
            "type": self.policy_type,
            "model_path": self.policy_model_path,
            "device": self.policy_device,
            "model_type": self.policy_model_type,
            "fallback_type": self.policy_fallback_type,
            "k_paths": self.k_paths,
        }

    def get_protection_config(self) -> dict[str, Any]:
        """Get protection configuration as dictionary."""
        return {
            "enabled": self.protection_enabled,
            "disjointness": self.protection_disjointness,
            "switchover_time_ms": self.protection_switchover_ms,
            "revert_after_repair": self.protection_revert_after_repair,
            "guard_band_slots": self.protection_guard_band_slots,
        }

    def get_heuristic_config(self) -> dict[str, Any]:
        """Get heuristic configuration as dictionary."""
        return {
            "load_balance_alpha": self.heuristic_load_balance_alpha,
            "random_seed": self.heuristic_random_seed,
            "congestion_threshold": self.heuristic_congestion_threshold,
            "tie_breaker": self.heuristic_tie_breaker,
        }

    def create_protection_config(self) -> "ProtectionConfig":
        """Create ProtectionConfig from settings."""
        from fusion.pipelines.protection_pipeline import (
            ProtectionConfig,
            DisjointnessType,
        )
        return ProtectionConfig(
            enabled=self.protection_enabled,
            disjointness=DisjointnessType(self.protection_disjointness),
            switchover_time_ms=self.protection_switchover_ms,
            revert_after_repair=self.protection_revert_after_repair,
            guard_band_slots=self.protection_guard_band_slots,
        )
```

### 3. Config Loader Extension

**File:** `fusion/configs/loader.py` (extension)

```python
"""
Configuration loader extension for Phase 5.

Loads [policy], [protection], and [heuristic] sections.
"""

from __future__ import annotations

import logging
from configparser import ConfigParser
from pathlib import Path
from typing import Any

from fusion.domain.config import SimulationConfig

logger = logging.getLogger(__name__)


def load_config(path: str | Path) -> SimulationConfig:
    """
    Load configuration from INI file.

    Args:
        path: Path to configuration file

    Returns:
        SimulationConfig with all settings
    """
    parser = ConfigParser()
    parser.read(path)

    # Load existing sections
    config_dict = load_base_config(parser)

    # Load Phase 5 sections
    config_dict.update(load_policy_config(parser))
    config_dict.update(load_protection_config(parser))
    config_dict.update(load_heuristic_config(parser))

    return SimulationConfig(**config_dict)


def load_base_config(parser: ConfigParser) -> dict[str, Any]:
    """Load base configuration sections."""
    config = {}

    # Simulation section
    if parser.has_section("simulation"):
        config["name"] = parser.get("simulation", "name", fallback="experiment")
        config["seed"] = parser.getint("simulation", "seed", fallback=42)
        config["num_requests"] = parser.getint(
            "simulation", "num_requests", fallback=10000
        )

    # Network section
    if parser.has_section("network"):
        config["topology"] = parser.get("network", "topology", fallback="NSFNet")
        config["num_slots"] = parser.getint("network", "num_slots", fallback=320)

    # ... other base sections ...

    return config


def load_policy_config(parser: ConfigParser) -> dict[str, Any]:
    """Load [policy] section."""
    prefix = "policy_"
    config = {}

    if not parser.has_section("policy"):
        return config

    config[f"{prefix}type"] = parser.get("policy", "type", fallback="first_feasible")

    model_path = parser.get("policy", "model_path", fallback="")
    config[f"{prefix}model_path"] = model_path if model_path else None

    config[f"{prefix}device"] = parser.get("policy", "device", fallback="cpu")

    model_type = parser.get("policy", "model_type", fallback="")
    config[f"{prefix}model_type"] = model_type if model_type else None

    config[f"{prefix}fallback_type"] = parser.get(
        "policy", "fallback_type", fallback="first_feasible"
    )

    return config


def load_protection_config(parser: ConfigParser) -> dict[str, Any]:
    """Load [protection] section."""
    prefix = "protection_"
    config = {}

    if not parser.has_section("protection"):
        return config

    config[f"{prefix}enabled"] = parser.getboolean(
        "protection", "enabled", fallback=False
    )

    config[f"{prefix}disjointness"] = parser.get(
        "protection", "disjointness", fallback="link"
    )

    config[f"{prefix}switchover_ms"] = parser.getfloat(
        "protection", "switchover_time_ms", fallback=50.0
    )

    config[f"{prefix}revert_after_repair"] = parser.getboolean(
        "protection", "revert_after_repair", fallback=False
    )

    config[f"{prefix}guard_band_slots"] = parser.getint(
        "protection", "guard_band_slots", fallback=1
    )

    return config


def load_heuristic_config(parser: ConfigParser) -> dict[str, Any]:
    """Load [heuristic] section."""
    prefix = "heuristic_"
    config = {}

    if not parser.has_section("heuristic"):
        return config

    config[f"{prefix}load_balance_alpha"] = parser.getfloat(
        "heuristic", "load_balance_alpha", fallback=0.5
    )

    seed_str = parser.get("heuristic", "random_seed", fallback="")
    config[f"{prefix}random_seed"] = int(seed_str) if seed_str else None

    config[f"{prefix}congestion_threshold"] = parser.getfloat(
        "heuristic", "congestion_threshold", fallback=0.8
    )

    config[f"{prefix}tie_breaker"] = parser.get(
        "heuristic", "tie_breaker", fallback="first"
    )

    return config
```

### 4. CLI Parameters

**File:** `fusion/cli/parameters/phase5.py`

```python
"""
Phase 5 CLI parameters for policy, protection, and heuristics.
"""

import click
from functools import wraps
from typing import Callable


def phase5_options(func: Callable) -> Callable:
    """Combined decorator for all Phase 5 CLI options."""
    func = policy_options(func)
    func = protection_options(func)
    func = heuristic_options(func)
    return func


def policy_options(func: Callable) -> Callable:
    """Decorator for policy CLI options."""
    @click.option(
        "--policy",
        "policy_type",
        type=click.Choice([
            "first_feasible", "shortest_feasible", "least_congested",
            "random", "load_balanced", "ml", "rl",
        ]),
        help="Control policy type",
    )
    @click.option(
        "--policy-model",
        "policy_model_path",
        type=click.Path(exists=True),
        help="Path to ML model file",
    )
    @click.option(
        "--policy-device",
        "policy_device",
        type=click.Choice(["cpu", "cuda"]),
        help="ML inference device",
    )
    @click.option(
        "--policy-fallback",
        "policy_fallback_type",
        type=click.Choice(["first_feasible", "shortest_feasible", "least_congested"]),
        help="Fallback policy for ML errors",
    )
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper


def protection_options(func: Callable) -> Callable:
    """Decorator for protection CLI options."""
    @click.option(
        "--protection/--no-protection",
        "protection_enabled",
        default=None,
        help="Enable/disable 1+1 protection",
    )
    @click.option(
        "--disjointness",
        "protection_disjointness",
        type=click.Choice(["link", "node"]),
        help="Path disjointness type",
    )
    @click.option(
        "--switchover-ms",
        "protection_switchover_ms",
        type=float,
        help="Switchover time in ms",
    )
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper


def heuristic_options(func: Callable) -> Callable:
    """Decorator for heuristic CLI options."""
    @click.option(
        "--load-balance-alpha",
        "heuristic_load_balance_alpha",
        type=float,
        help="Alpha for load_balanced policy",
    )
    @click.option(
        "--random-seed",
        "heuristic_random_seed",
        type=int,
        help="Seed for random policy",
    )
    @click.option(
        "--tie-breaker",
        "heuristic_tie_breaker",
        type=click.Choice(["first", "random", "shortest"]),
        help="Tie breaking method",
    )
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper


def apply_cli_overrides(
    config: "SimulationConfig",
    cli_params: dict,
) -> "SimulationConfig":
    """
    Apply CLI parameter overrides to config.

    Args:
        config: Base configuration
        cli_params: CLI parameters (may contain None values)

    Returns:
        Updated configuration
    """
    for key, value in cli_params.items():
        if value is not None and hasattr(config, key):
            setattr(config, key, value)

    return config
```

### 5. Configuration Templates

**File:** `fusion/configs/templates/default_phase5.ini`

```ini
# FUSION Default Configuration with Phase 5 Extensions
# ====================================================

[simulation]
name = default_experiment
seed = 42
num_requests = 10000

[network]
topology = NSFNet
num_slots = 320
slot_width = 12.5

[traffic]
arrival_rate = 50
holding_time = 10
bandwidth_min = 25
bandwidth_max = 400

[routing]
algorithm = k_shortest_path
k = 5

[spectrum]
assignment = first_fit

# ========== Phase 5: Policy ==========
[policy]
type = first_feasible
model_path =
device = cpu
fallback_type = first_feasible

# ========== Phase 5: Protection ==========
[protection]
enabled = false
disjointness = link
switchover_time_ms = 50
revert_after_repair = false
guard_band_slots = 1

# ========== Phase 5: Heuristic ==========
[heuristic]
load_balance_alpha = 0.5
random_seed =
congestion_threshold = 0.8
tie_breaker = first
```

**File:** `fusion/configs/templates/ml_policy.ini`

```ini
# ML Policy Configuration
# =======================

[simulation]
name = ml_policy_experiment
seed = 42
num_requests = 10000

[policy]
type = ml
model_path = models/bc_policy.pt
device = cuda
fallback_type = first_feasible

[protection]
enabled = false
```

**File:** `fusion/configs/templates/protected_network.ini`

```ini
# Protected Network Configuration
# ===============================

[simulation]
name = protected_network_experiment
seed = 42
num_requests = 10000

[policy]
type = shortest_feasible

[protection]
enabled = true
disjointness = link
switchover_time_ms = 50
revert_after_repair = false

[heuristic]
tie_breaker = shortest
```

---

## Verification

- [ ] Schema includes all Phase 5 sections
- [ ] SimulationConfig has all Phase 5 fields
- [ ] Config loader reads Phase 5 sections
- [ ] CLI parameters work correctly
- [ ] CLI overrides config file values
- [ ] Templates include examples
- [ ] Backward compatible with old configs

---

## Next Task

Proceed to **P5.6.e** to create the verification plan.
