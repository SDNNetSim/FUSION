# Task ID: P5.6.c - Design [heuristic] Configuration Section

**Sub-phase:** P5.6
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the [heuristic] configuration section for heuristic policy-specific parameters.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.6_configuration_extension/P5.6.shared_context_config_patterns.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.d_design_congestion_policies.md`

---

## Outputs

### 1. [heuristic] Section Specification

```ini
[heuristic]
# Load balance alpha: Weight for LoadBalancedPolicy
# Range: 0.0 (pure congestion) to 1.0 (pure length)
# Default: 0.5
load_balance_alpha = 0.5

# Random seed: Seed for RandomFeasiblePolicy
# Default: (none - use random seed)
random_seed =

# Congestion threshold: Threshold for congestion avoidance
# Range: 0.0 to 1.0
# Default: 0.8
congestion_threshold = 0.8

# Tie breaker: How to break ties between equal options
# Options: first, random, shortest
# Default: first
tie_breaker = first
```

### 2. Schema Definition

```python
"""
Heuristic configuration schema.
"""

HEURISTIC_SCHEMA = {
    "load_balance_alpha": {
        "type": float,
        "default": 0.5,
        "min": 0.0,
        "max": 1.0,
        "description": "Weight for LoadBalancedPolicy (0=congestion, 1=length)",
    },
    "random_seed": {
        "type": int,
        "default": None,
        "nullable": True,
        "description": "Seed for RandomFeasiblePolicy",
    },
    "congestion_threshold": {
        "type": float,
        "default": 0.8,
        "min": 0.0,
        "max": 1.0,
        "description": "Congestion threshold for avoidance",
    },
    "tie_breaker": {
        "type": str,
        "default": "first",
        "choices": ["first", "random", "shortest"],
        "description": "Method for breaking ties",
    },
}
```

### 3. SimulationConfig Fields

```python
@dataclass
class SimulationConfig:
    # ... existing fields ...

    # Heuristic configuration
    heuristic_load_balance_alpha: float = 0.5
    heuristic_random_seed: int | None = None
    heuristic_congestion_threshold: float = 0.8
    heuristic_tie_breaker: str = "first"

    def get_heuristic_config(self) -> dict[str, Any]:
        """Get heuristic configuration as dictionary."""
        return {
            "load_balance_alpha": self.heuristic_load_balance_alpha,
            "random_seed": self.heuristic_random_seed,
            "congestion_threshold": self.heuristic_congestion_threshold,
            "tie_breaker": self.heuristic_tie_breaker,
        }
```

### 4. Validation Functions

```python
"""
Heuristic configuration validation.
"""

from typing import Any


def validate_heuristic_config(config: dict[str, Any]) -> list[str]:
    """
    Validate heuristic configuration.

    Args:
        config: Heuristic configuration dictionary

    Returns:
        List of validation errors (empty if valid)
    """
    errors = []

    # Validate load_balance_alpha
    alpha = config.get("load_balance_alpha", 0.5)
    if not isinstance(alpha, (int, float)):
        errors.append(f"load_balance_alpha must be numeric: {alpha}")
    elif alpha < 0.0 or alpha > 1.0:
        errors.append(f"load_balance_alpha must be in [0, 1]: {alpha}")

    # Validate random_seed (can be None)
    seed = config.get("random_seed")
    if seed is not None and not isinstance(seed, int):
        errors.append(f"random_seed must be int or None: {seed}")

    # Validate congestion_threshold
    threshold = config.get("congestion_threshold", 0.8)
    if not isinstance(threshold, (int, float)):
        errors.append(f"congestion_threshold must be numeric: {threshold}")
    elif threshold < 0.0 or threshold > 1.0:
        errors.append(f"congestion_threshold must be in [0, 1]: {threshold}")

    # Validate tie_breaker
    tie_breaker = config.get("tie_breaker", "first")
    if tie_breaker not in ("first", "random", "shortest"):
        errors.append(f"Invalid tie_breaker: {tie_breaker}")

    return errors
```

### 5. CLI Parameters

```python
"""
Heuristic CLI parameters.
"""

import click


def heuristic_options(func):
    """Decorator for heuristic CLI options."""
    func = click.option(
        "--load-balance-alpha",
        "heuristic_load_balance_alpha",
        type=float,
        default=None,
        help="Alpha for load_balanced policy (0=congestion, 1=length)",
    )(func)

    func = click.option(
        "--random-seed",
        "heuristic_random_seed",
        type=int,
        default=None,
        help="Seed for random policy",
    )(func)

    func = click.option(
        "--congestion-threshold",
        "heuristic_congestion_threshold",
        type=float,
        default=None,
        help="Congestion threshold (0-1)",
    )(func)

    func = click.option(
        "--tie-breaker",
        "heuristic_tie_breaker",
        type=click.Choice(["first", "random", "shortest"]),
        default=None,
        help="Tie breaking method",
    )(func)

    return func
```

### 6. Config Loader Extension

```python
"""
Load heuristic configuration from INI file.
"""

from configparser import ConfigParser


def load_heuristic_config(parser: ConfigParser) -> dict[str, Any]:
    """
    Load [heuristic] section from config parser.

    Args:
        parser: ConfigParser with loaded config

    Returns:
        Heuristic configuration dictionary
    """
    config = {}

    if not parser.has_section("heuristic"):
        # Return defaults if section missing
        return {
            "load_balance_alpha": 0.5,
            "random_seed": None,
            "congestion_threshold": 0.8,
            "tie_breaker": "first",
        }

    config["load_balance_alpha"] = parser.getfloat(
        "heuristic", "load_balance_alpha", fallback=0.5
    )

    # random_seed can be empty (None)
    seed_str = parser.get("heuristic", "random_seed", fallback="")
    config["random_seed"] = int(seed_str) if seed_str else None

    config["congestion_threshold"] = parser.getfloat(
        "heuristic", "congestion_threshold", fallback=0.8
    )

    config["tie_breaker"] = parser.get(
        "heuristic", "tie_breaker", fallback="first"
    )

    return config
```

### 7. Integration with PolicyFactory

```python
# Extended PolicyFactory to use heuristic config

class PolicyFactory:
    @staticmethod
    def _create_load_balanced(
        alpha: float = 0.5,
        tie_breaker: str = "first",
    ) -> ControlPolicy:
        """Create LoadBalancedPolicy with config."""
        from fusion.policies.heuristic_policy import LoadBalancedPolicy
        return LoadBalancedPolicy(alpha=alpha, tie_breaker=tie_breaker)

    @staticmethod
    def _create_random(
        seed: int | None = None,
    ) -> ControlPolicy:
        """Create RandomFeasiblePolicy with config."""
        from fusion.policies.heuristic_policy import RandomFeasiblePolicy
        return RandomFeasiblePolicy(seed=seed)

    @staticmethod
    def create(config: SimulationConfig) -> ControlPolicy:
        """Create policy using both policy and heuristic config."""
        policy_type = config.policy_type
        heuristic = config.get_heuristic_config()

        if policy_type == "load_balanced":
            return PolicyFactory._create_load_balanced(
                alpha=heuristic["load_balance_alpha"],
                tie_breaker=heuristic["tie_breaker"],
            )

        elif policy_type == "random":
            return PolicyFactory._create_random(
                seed=heuristic["random_seed"],
            )

        # ... other policy types
```

### 8. Example Configurations

```ini
# Example 1: Default heuristics
[heuristic]
load_balance_alpha = 0.5
congestion_threshold = 0.8
tie_breaker = first

# Example 2: Prefer shorter paths
[policy]
type = load_balanced

[heuristic]
load_balance_alpha = 0.8  # More weight on length

# Example 3: Reproducible random policy
[policy]
type = random

[heuristic]
random_seed = 42

# Example 4: Aggressive congestion avoidance
[policy]
type = least_congested

[heuristic]
congestion_threshold = 0.5  # Avoid paths > 50% utilized
tie_breaker = shortest
```

### 9. Heuristic Policy Updates

```python
# Updated heuristic policies to accept config

class LoadBalancedPolicy(HeuristicPolicy):
    """Load balanced policy using heuristic config."""

    def __init__(
        self,
        alpha: float = 0.5,
        tie_breaker: str = "first",
    ) -> None:
        self.alpha = alpha
        self.tie_breaker = tie_breaker

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        feasible = [opt for opt in options if opt.is_feasible]
        if not feasible:
            return -1

        # Score = alpha * normalized_length + (1-alpha) * normalized_congestion
        scored = []
        for opt in feasible:
            length_score = opt.weight_km / 10000.0
            congestion_score = opt.congestion
            score = self.alpha * length_score + (1 - self.alpha) * congestion_score
            scored.append((opt, score))

        # Sort by score (lower is better)
        scored.sort(key=lambda x: x[1])

        # Handle ties
        best_score = scored[0][1]
        ties = [opt for opt, score in scored if score == best_score]

        if len(ties) == 1 or self.tie_breaker == "first":
            return ties[0].path_index
        elif self.tie_breaker == "random":
            import random
            return random.choice(ties).path_index
        elif self.tie_breaker == "shortest":
            return min(ties, key=lambda o: o.weight_km).path_index

        return ties[0].path_index
```

---

## Verification

- [ ] load_balance_alpha in [0, 1]
- [ ] random_seed optional (can be None)
- [ ] congestion_threshold in [0, 1]
- [ ] tie_breaker validated
- [ ] Policies use heuristic config
- [ ] CLI parameters work

---

## Next Task

Proceed to **P5.6.d** to implement the complete configuration extension.
