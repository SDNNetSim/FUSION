# Task ID: P5.6.a - Design [policy] Configuration Section

**Sub-phase:** P5.6
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the [policy] configuration section for specifying control policy settings.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.6_configuration_extension/P5.6.shared_context_config_patterns.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.5_orchestrator_integration/P5.5.b_design_policy_factory.md`

---

## Outputs

### 1. [policy] Section Specification

```ini
[policy]
# Policy type: Specifies which control policy to use for path selection
# Options: first_feasible, shortest_feasible, least_congested,
#          random, load_balanced, ml, rl
# Default: first_feasible
type = first_feasible

# Model path: Path to pre-trained model file (required for ml/rl types)
# Supported formats: .pt, .pth (PyTorch), .joblib, .pkl (sklearn), .onnx
# Default: (empty)
model_path =

# Device: Inference device for ML/RL policies
# Options: cpu, cuda
# Default: cpu
device = cpu

# Model type: Explicit model type (auto-detected from extension if not set)
# Options: pytorch, sklearn, onnx
# Default: (auto-detect)
model_type =

# Fallback type: Fallback policy when ML inference fails
# Options: first_feasible, shortest_feasible, least_congested
# Default: first_feasible
fallback_type = first_feasible

# K paths: Expected number of path options (for feature padding in ML)
# Default: 5
k_paths = 5
```

### 2. Schema Definition

```python
"""
Policy configuration schema.
"""

POLICY_SCHEMA = {
    "type": {
        "type": str,
        "default": "first_feasible",
        "choices": [
            "first_feasible",
            "shortest_feasible",
            "least_congested",
            "random",
            "load_balanced",
            "ml",
            "rl",
        ],
        "description": "Control policy type for path selection",
    },
    "model_path": {
        "type": str,
        "default": "",
        "description": "Path to pre-trained model (required for ml/rl)",
    },
    "device": {
        "type": str,
        "default": "cpu",
        "choices": ["cpu", "cuda"],
        "description": "Inference device for ML policies",
    },
    "model_type": {
        "type": str,
        "default": "",
        "choices": ["", "pytorch", "sklearn", "onnx"],
        "description": "Model type (auto-detected if empty)",
    },
    "fallback_type": {
        "type": str,
        "default": "first_feasible",
        "choices": ["first_feasible", "shortest_feasible", "least_congested"],
        "description": "Fallback policy for ML errors",
    },
    "k_paths": {
        "type": int,
        "default": 5,
        "min": 1,
        "max": 20,
        "description": "Expected number of path options",
    },
}
```

### 3. SimulationConfig Fields

```python
@dataclass
class SimulationConfig:
    # ... existing fields ...

    # Policy configuration
    policy_type: str = "first_feasible"
    policy_model_path: str | None = None
    policy_device: str = "cpu"
    policy_model_type: str | None = None
    policy_fallback_type: str = "first_feasible"
    policy_k_paths: int = 5

    def get_policy_config(self) -> dict[str, Any]:
        """Get policy configuration as dictionary."""
        return {
            "type": self.policy_type,
            "model_path": self.policy_model_path,
            "device": self.policy_device,
            "model_type": self.policy_model_type,
            "fallback_type": self.policy_fallback_type,
            "k_paths": self.policy_k_paths,
        }
```

### 4. Validation Functions

```python
"""
Policy configuration validation.
"""

from pathlib import Path
from typing import Any


def validate_policy_config(config: dict[str, Any]) -> list[str]:
    """
    Validate policy configuration.

    Args:
        config: Policy configuration dictionary

    Returns:
        List of validation errors (empty if valid)
    """
    errors = []

    policy_type = config.get("type", "first_feasible")

    # Validate type
    valid_types = [
        "first_feasible", "shortest_feasible", "least_congested",
        "random", "load_balanced", "ml", "rl",
    ]
    if policy_type not in valid_types:
        errors.append(f"Invalid policy type: {policy_type}")

    # ML/RL policies require model_path
    if policy_type in ("ml", "rl"):
        model_path = config.get("model_path", "")
        if not model_path:
            errors.append(f"{policy_type} policy requires model_path")
        elif not Path(model_path).exists():
            errors.append(f"Model file not found: {model_path}")

    # Validate device
    device = config.get("device", "cpu")
    if device not in ("cpu", "cuda"):
        errors.append(f"Invalid device: {device}")

    # Validate k_paths
    k_paths = config.get("k_paths", 5)
    if not isinstance(k_paths, int) or k_paths < 1:
        errors.append(f"k_paths must be positive integer: {k_paths}")

    return errors


def validate_model_path(model_path: str) -> tuple[bool, str | None]:
    """
    Validate model file path.

    Args:
        model_path: Path to model file

    Returns:
        (is_valid, error_message)
    """
    if not model_path:
        return False, "Model path is empty"

    path = Path(model_path)

    if not path.exists():
        return False, f"File not found: {model_path}"

    valid_extensions = {".pt", ".pth", ".joblib", ".pkl", ".onnx"}
    if path.suffix.lower() not in valid_extensions:
        return False, f"Unsupported model format: {path.suffix}"

    return True, None


def infer_model_type(model_path: str) -> str:
    """
    Infer model type from file extension.

    Args:
        model_path: Path to model file

    Returns:
        Model type string
    """
    ext = Path(model_path).suffix.lower()

    extension_map = {
        ".pt": "pytorch",
        ".pth": "pytorch",
        ".joblib": "sklearn",
        ".pkl": "sklearn",
        ".onnx": "onnx",
    }

    return extension_map.get(ext, "pytorch")
```

### 5. CLI Parameters

```python
"""
Policy CLI parameters.
"""

import click


def policy_options(func):
    """Decorator for policy CLI options."""
    func = click.option(
        "--policy",
        "policy_type",
        type=click.Choice([
            "first_feasible", "shortest_feasible", "least_congested",
            "random", "load_balanced", "ml", "rl",
        ]),
        help="Control policy type",
    )(func)

    func = click.option(
        "--policy-model",
        "policy_model_path",
        type=click.Path(exists=True),
        help="Path to ML model file",
    )(func)

    func = click.option(
        "--policy-device",
        "policy_device",
        type=click.Choice(["cpu", "cuda"]),
        default=None,
        help="ML inference device",
    )(func)

    func = click.option(
        "--policy-fallback",
        "policy_fallback_type",
        type=click.Choice(["first_feasible", "shortest_feasible", "least_congested"]),
        default=None,
        help="Fallback policy for ML errors",
    )(func)

    func = click.option(
        "--k-paths",
        "policy_k_paths",
        type=int,
        default=None,
        help="Number of path options",
    )(func)

    return func
```

### 6. Config Loader Extension

```python
"""
Load policy configuration from INI file.
"""

from configparser import ConfigParser


def load_policy_config(parser: ConfigParser) -> dict[str, Any]:
    """
    Load [policy] section from config parser.

    Args:
        parser: ConfigParser with loaded config

    Returns:
        Policy configuration dictionary
    """
    config = {}

    if not parser.has_section("policy"):
        # Return defaults if section missing
        return {
            "type": "first_feasible",
            "model_path": None,
            "device": "cpu",
            "model_type": None,
            "fallback_type": "first_feasible",
            "k_paths": 5,
        }

    config["type"] = parser.get("policy", "type", fallback="first_feasible")

    model_path = parser.get("policy", "model_path", fallback="")
    config["model_path"] = model_path if model_path else None

    config["device"] = parser.get("policy", "device", fallback="cpu")

    model_type = parser.get("policy", "model_type", fallback="")
    config["model_type"] = model_type if model_type else None

    config["fallback_type"] = parser.get(
        "policy", "fallback_type", fallback="first_feasible"
    )

    config["k_paths"] = parser.getint("policy", "k_paths", fallback=5)

    return config
```

### 7. Example Configurations

```ini
# Example 1: Simple heuristic policy
[policy]
type = shortest_feasible

# Example 2: ML policy with PyTorch model
[policy]
type = ml
model_path = models/bc_policy.pt
device = cuda
fallback_type = first_feasible
k_paths = 5

# Example 3: RL policy with sklearn model
[policy]
type = ml
model_path = models/classifier.joblib
model_type = sklearn

# Example 4: Load balanced heuristic
[policy]
type = load_balanced
# Note: alpha parameter is in [heuristic] section
```

---

## Verification

- [ ] All policy types supported
- [ ] model_path required for ml/rl
- [ ] device validated as cpu/cuda
- [ ] model_type auto-detected
- [ ] Validation errors are clear
- [ ] CLI parameters work correctly

---

## Next Task

Proceed to **P5.6.b** to design the [protection] configuration section.
