# Task ID: P5.6.b - Design [protection] Configuration Section

**Sub-phase:** P5.6
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the [protection] configuration section for 1+1 dedicated path protection settings.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.6_configuration_extension/P5.6.shared_context_config_patterns.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.4_protection_pipeline/P5.4.b_design_protection_pipeline.md`

---

## Outputs

### 1. [protection] Section Specification

```ini
[protection]
# Enabled: Whether to enable 1+1 dedicated protection
# Default: false
enabled = false

# Disjointness: Type of path disjointness for protection
# Options: link (edge-disjoint), node (node-disjoint)
# Default: link
disjointness = link

# Switchover time: Protection switchover latency in milliseconds
# Range: 0-1000
# Default: 50
switchover_time_ms = 50

# Revert after repair: Switch back to primary after link repair
# Default: false
revert_after_repair = false

# Guard band: Number of guard band slots between spectrum allocations
# Range: 0-5
# Default: 1
guard_band_slots = 1
```

### 2. Schema Definition

```python
"""
Protection configuration schema.
"""

PROTECTION_SCHEMA = {
    "enabled": {
        "type": bool,
        "default": False,
        "description": "Enable 1+1 dedicated protection",
    },
    "disjointness": {
        "type": str,
        "default": "link",
        "choices": ["link", "node"],
        "description": "Type of path disjointness",
    },
    "switchover_time_ms": {
        "type": float,
        "default": 50.0,
        "min": 0.0,
        "max": 1000.0,
        "description": "Protection switchover latency (ms)",
    },
    "revert_after_repair": {
        "type": bool,
        "default": False,
        "description": "Revert to primary after repair",
    },
    "guard_band_slots": {
        "type": int,
        "default": 1,
        "min": 0,
        "max": 5,
        "description": "Guard band between allocations",
    },
}
```

### 3. SimulationConfig Fields

```python
@dataclass
class SimulationConfig:
    # ... existing fields ...

    # Protection configuration
    protection_enabled: bool = False
    protection_disjointness: str = "link"
    protection_switchover_ms: float = 50.0
    protection_revert_after_repair: bool = False
    protection_guard_band_slots: int = 1

    def get_protection_config(self) -> dict[str, Any]:
        """Get protection configuration as dictionary."""
        return {
            "enabled": self.protection_enabled,
            "disjointness": self.protection_disjointness,
            "switchover_time_ms": self.protection_switchover_ms,
            "revert_after_repair": self.protection_revert_after_repair,
            "guard_band_slots": self.protection_guard_band_slots,
        }

    def create_protection_config(self) -> "ProtectionConfig":
        """Create ProtectionConfig from settings."""
        from fusion.pipelines.protection_pipeline import (
            ProtectionConfig,
            DisjointnessType,
        )
        return ProtectionConfig(
            enabled=self.protection_enabled,
            disjointness=DisjointnessType(self.protection_disjointness),
            switchover_time_ms=self.protection_switchover_ms,
            revert_after_repair=self.protection_revert_after_repair,
            guard_band_slots=self.protection_guard_band_slots,
        )
```

### 4. Validation Functions

```python
"""
Protection configuration validation.
"""

from typing import Any


def validate_protection_config(config: dict[str, Any]) -> list[str]:
    """
    Validate protection configuration.

    Args:
        config: Protection configuration dictionary

    Returns:
        List of validation errors (empty if valid)
    """
    errors = []

    # Validate disjointness
    disjointness = config.get("disjointness", "link")
    if disjointness not in ("link", "node"):
        errors.append(f"Invalid disjointness: {disjointness}")

    # Validate switchover_time_ms
    switchover = config.get("switchover_time_ms", 50.0)
    if not isinstance(switchover, (int, float)) or switchover < 0:
        errors.append(f"switchover_time_ms must be non-negative: {switchover}")
    elif switchover > 1000:
        errors.append(f"switchover_time_ms too high (max 1000): {switchover}")

    # Validate guard_band_slots
    guard_band = config.get("guard_band_slots", 1)
    if not isinstance(guard_band, int) or guard_band < 0:
        errors.append(f"guard_band_slots must be non-negative int: {guard_band}")
    elif guard_band > 5:
        errors.append(f"guard_band_slots too high (max 5): {guard_band}")

    return errors


def validate_protection_topology(
    topology_name: str,
    disjointness: str,
) -> list[str]:
    """
    Validate protection is feasible for topology.

    Args:
        topology_name: Name of topology
        disjointness: Disjointness type

    Returns:
        List of warnings (empty if OK)
    """
    warnings = []

    # Linear topologies don't support protection
    linear_topologies = {"linear", "chain"}
    if topology_name.lower() in linear_topologies:
        warnings.append(
            f"Protection may not work with linear topology: {topology_name}"
        )

    # Node-disjoint needs higher connectivity
    if disjointness == "node":
        low_connectivity = {"star", "tree"}
        if topology_name.lower() in low_connectivity:
            warnings.append(
                f"Node-disjoint protection may fail with {topology_name} topology"
            )

    return warnings
```

### 5. CLI Parameters

```python
"""
Protection CLI parameters.
"""

import click


def protection_options(func):
    """Decorator for protection CLI options."""
    func = click.option(
        "--protection/--no-protection",
        "protection_enabled",
        default=None,
        help="Enable/disable 1+1 protection",
    )(func)

    func = click.option(
        "--disjointness",
        "protection_disjointness",
        type=click.Choice(["link", "node"]),
        default=None,
        help="Path disjointness type",
    )(func)

    func = click.option(
        "--switchover-ms",
        "protection_switchover_ms",
        type=float,
        default=None,
        help="Switchover time in ms",
    )(func)

    func = click.option(
        "--revert-after-repair/--no-revert-after-repair",
        "protection_revert_after_repair",
        default=None,
        help="Revert to primary after repair",
    )(func)

    func = click.option(
        "--guard-band",
        "protection_guard_band_slots",
        type=int,
        default=None,
        help="Guard band slots",
    )(func)

    return func
```

### 6. Config Loader Extension

```python
"""
Load protection configuration from INI file.
"""

from configparser import ConfigParser


def load_protection_config(parser: ConfigParser) -> dict[str, Any]:
    """
    Load [protection] section from config parser.

    Args:
        parser: ConfigParser with loaded config

    Returns:
        Protection configuration dictionary
    """
    config = {}

    if not parser.has_section("protection"):
        # Return defaults if section missing
        return {
            "enabled": False,
            "disjointness": "link",
            "switchover_time_ms": 50.0,
            "revert_after_repair": False,
            "guard_band_slots": 1,
        }

    config["enabled"] = parser.getboolean(
        "protection", "enabled", fallback=False
    )

    config["disjointness"] = parser.get(
        "protection", "disjointness", fallback="link"
    )

    config["switchover_time_ms"] = parser.getfloat(
        "protection", "switchover_time_ms", fallback=50.0
    )

    config["revert_after_repair"] = parser.getboolean(
        "protection", "revert_after_repair", fallback=False
    )

    config["guard_band_slots"] = parser.getint(
        "protection", "guard_band_slots", fallback=1
    )

    return config
```

### 7. Example Configurations

```ini
# Example 1: Protection disabled (default)
[protection]
enabled = false

# Example 2: Basic link-disjoint protection
[protection]
enabled = true
disjointness = link
switchover_time_ms = 50

# Example 3: Node-disjoint with revert
[protection]
enabled = true
disjointness = node
switchover_time_ms = 25
revert_after_repair = true

# Example 4: Customized protection
[protection]
enabled = true
disjointness = link
switchover_time_ms = 100
revert_after_repair = false
guard_band_slots = 2
```

### 8. Integration with ProtectionPipeline

```python
# In orchestrator creation

def create_protection_pipeline(
    config: SimulationConfig,
) -> ProtectionPipeline | None:
    """Create ProtectionPipeline if enabled."""
    if not config.protection_enabled:
        return None

    protection_config = config.create_protection_config()

    # Validate topology supports protection
    warnings = validate_protection_topology(
        config.topology,
        config.protection_disjointness,
    )
    for warning in warnings:
        logger.warning(warning)

    return ProtectionPipeline(protection_config)
```

---

## Verification

- [ ] enabled toggles protection correctly
- [ ] disjointness accepts link/node
- [ ] switchover_time_ms validated range
- [ ] revert_after_repair works
- [ ] guard_band_slots validated
- [ ] CLI parameters override config

---

## Next Task

Proceed to **P5.6.c** to design the [heuristic] configuration section.
