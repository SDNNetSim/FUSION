# Task ID: P5.6.e - Verification Plan for Configuration Extension

**Sub-phase:** P5.6
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** verification-plan

---

## Purpose

Define the verification plan for Phase 5 configuration extensions.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.6_configuration_extension/P5.6.d_implement_config_extension.md`

---

## Outputs

### 1. Test File Structure

```
fusion/configs/tests/
├── test_phase5_schema.py
├── test_phase5_loader.py
├── test_phase5_validation.py
└── test_phase5_cli.py
```

### 2. Schema Tests

```python
"""Tests for Phase 5 configuration schema."""

import pytest

from fusion.configs.schema import (
    POLICY_SCHEMA,
    PROTECTION_SCHEMA,
    HEURISTIC_SCHEMA,
)


class TestPolicySchema:
    """Test suite for policy schema."""

    def test_policy_type_choices(self) -> None:
        """Should include all policy types."""
        choices = POLICY_SCHEMA["type"]["choices"]

        assert "first_feasible" in choices
        assert "shortest_feasible" in choices
        assert "least_congested" in choices
        assert "random" in choices
        assert "load_balanced" in choices
        assert "ml" in choices
        assert "rl" in choices

    def test_policy_type_default(self) -> None:
        """Should default to first_feasible."""
        assert POLICY_SCHEMA["type"]["default"] == "first_feasible"

    def test_device_choices(self) -> None:
        """Should include cpu and cuda."""
        choices = POLICY_SCHEMA["device"]["choices"]
        assert "cpu" in choices
        assert "cuda" in choices

    def test_k_paths_range(self) -> None:
        """Should have valid k_paths range."""
        assert POLICY_SCHEMA["k_paths"]["min"] >= 1
        assert POLICY_SCHEMA["k_paths"]["max"] <= 20


class TestProtectionSchema:
    """Test suite for protection schema."""

    def test_enabled_default_false(self) -> None:
        """Should default to disabled."""
        assert PROTECTION_SCHEMA["enabled"]["default"] is False

    def test_disjointness_choices(self) -> None:
        """Should include link and node."""
        choices = PROTECTION_SCHEMA["disjointness"]["choices"]
        assert "link" in choices
        assert "node" in choices

    def test_switchover_range(self) -> None:
        """Should have valid switchover range."""
        assert PROTECTION_SCHEMA["switchover_time_ms"]["min"] >= 0
        assert PROTECTION_SCHEMA["switchover_time_ms"]["max"] <= 1000


class TestHeuristicSchema:
    """Test suite for heuristic schema."""

    def test_alpha_range(self) -> None:
        """Should have alpha in [0, 1]."""
        assert HEURISTIC_SCHEMA["load_balance_alpha"]["min"] == 0.0
        assert HEURISTIC_SCHEMA["load_balance_alpha"]["max"] == 1.0

    def test_random_seed_nullable(self) -> None:
        """Should allow null random_seed."""
        assert HEURISTIC_SCHEMA["random_seed"]["nullable"] is True

    def test_tie_breaker_choices(self) -> None:
        """Should include valid tie breakers."""
        choices = HEURISTIC_SCHEMA["tie_breaker"]["choices"]
        assert "first" in choices
        assert "random" in choices
        assert "shortest" in choices
```

### 3. Loader Tests

```python
"""Tests for Phase 5 configuration loader."""

import pytest
import tempfile
from pathlib import Path

from fusion.configs.loader import (
    load_config,
    load_policy_config,
    load_protection_config,
    load_heuristic_config,
)


@pytest.fixture
def config_file_basic():
    """Basic config file without Phase 5 sections."""
    content = """
[simulation]
name = test
seed = 42
"""
    with tempfile.NamedTemporaryFile(mode="w", suffix=".ini", delete=False) as f:
        f.write(content)
        return f.name


@pytest.fixture
def config_file_full():
    """Config file with all Phase 5 sections."""
    content = """
[simulation]
name = test
seed = 42

[policy]
type = shortest_feasible
model_path = test.pt
device = cuda

[protection]
enabled = true
disjointness = node
switchover_time_ms = 25

[heuristic]
load_balance_alpha = 0.7
random_seed = 123
"""
    with tempfile.NamedTemporaryFile(mode="w", suffix=".ini", delete=False) as f:
        f.write(content)
        return f.name


class TestConfigLoader:
    """Test suite for configuration loader."""

    def test_load_without_phase5_sections(self, config_file_basic) -> None:
        """Should load config without Phase 5 sections using defaults."""
        config = load_config(config_file_basic)

        # Should use defaults
        assert config.policy_type == "first_feasible"
        assert config.protection_enabled is False
        assert config.heuristic_load_balance_alpha == 0.5

    def test_load_with_all_sections(self, config_file_full) -> None:
        """Should load all Phase 5 sections."""
        config = load_config(config_file_full)

        # Policy
        assert config.policy_type == "shortest_feasible"
        assert config.policy_device == "cuda"

        # Protection
        assert config.protection_enabled is True
        assert config.protection_disjointness == "node"
        assert config.protection_switchover_ms == 25.0

        # Heuristic
        assert config.heuristic_load_balance_alpha == 0.7
        assert config.heuristic_random_seed == 123

    def test_empty_model_path_becomes_none(self, config_file_basic) -> None:
        """Should convert empty model_path to None."""
        config = load_config(config_file_basic)
        assert config.policy_model_path is None

    def test_empty_random_seed_becomes_none(self, config_file_basic) -> None:
        """Should convert empty random_seed to None."""
        config = load_config(config_file_basic)
        assert config.heuristic_random_seed is None


class TestPartialLoaders:
    """Test individual section loaders."""

    def test_load_policy_config_missing(self) -> None:
        """Should return empty dict for missing section."""
        from configparser import ConfigParser
        parser = ConfigParser()

        result = load_policy_config(parser)
        assert result == {}

    def test_load_protection_config_missing(self) -> None:
        """Should return empty dict for missing section."""
        from configparser import ConfigParser
        parser = ConfigParser()

        result = load_protection_config(parser)
        assert result == {}
```

### 4. Validation Tests

```python
"""Tests for Phase 5 configuration validation."""

import pytest

from fusion.configs.validation import (
    validate_policy_config,
    validate_protection_config,
    validate_heuristic_config,
    validate_model_path,
)


class TestPolicyValidation:
    """Test suite for policy validation."""

    def test_valid_policy_config(self) -> None:
        """Should pass for valid config."""
        config = {
            "type": "first_feasible",
            "device": "cpu",
            "k_paths": 5,
        }
        errors = validate_policy_config(config)
        assert errors == []

    def test_invalid_policy_type(self) -> None:
        """Should fail for invalid policy type."""
        config = {"type": "invalid_policy"}
        errors = validate_policy_config(config)
        assert len(errors) == 1
        assert "Invalid policy type" in errors[0]

    def test_ml_policy_requires_model_path(self) -> None:
        """Should fail for ML policy without model_path."""
        config = {"type": "ml", "model_path": ""}
        errors = validate_policy_config(config)
        assert len(errors) == 1
        assert "requires model_path" in errors[0]

    def test_invalid_device(self) -> None:
        """Should fail for invalid device."""
        config = {"type": "first_feasible", "device": "tpu"}
        errors = validate_policy_config(config)
        assert any("Invalid device" in e for e in errors)


class TestProtectionValidation:
    """Test suite for protection validation."""

    def test_valid_protection_config(self) -> None:
        """Should pass for valid config."""
        config = {
            "disjointness": "link",
            "switchover_time_ms": 50.0,
            "guard_band_slots": 1,
        }
        errors = validate_protection_config(config)
        assert errors == []

    def test_invalid_disjointness(self) -> None:
        """Should fail for invalid disjointness."""
        config = {"disjointness": "path"}
        errors = validate_protection_config(config)
        assert any("Invalid disjointness" in e for e in errors)

    def test_negative_switchover(self) -> None:
        """Should fail for negative switchover time."""
        config = {"switchover_time_ms": -10}
        errors = validate_protection_config(config)
        assert any("non-negative" in e for e in errors)


class TestHeuristicValidation:
    """Test suite for heuristic validation."""

    def test_valid_heuristic_config(self) -> None:
        """Should pass for valid config."""
        config = {
            "load_balance_alpha": 0.5,
            "random_seed": 42,
            "congestion_threshold": 0.8,
            "tie_breaker": "first",
        }
        errors = validate_heuristic_config(config)
        assert errors == []

    def test_alpha_out_of_range(self) -> None:
        """Should fail for alpha outside [0, 1]."""
        config = {"load_balance_alpha": 1.5}
        errors = validate_heuristic_config(config)
        assert any("must be in [0, 1]" in e for e in errors)

    def test_invalid_tie_breaker(self) -> None:
        """Should fail for invalid tie_breaker."""
        config = {"tie_breaker": "invalid"}
        errors = validate_heuristic_config(config)
        assert any("Invalid tie_breaker" in e for e in errors)


class TestModelPathValidation:
    """Test suite for model path validation."""

    def test_empty_path_invalid(self) -> None:
        """Should fail for empty path."""
        is_valid, error = validate_model_path("")
        assert not is_valid
        assert "empty" in error

    def test_nonexistent_file(self) -> None:
        """Should fail for nonexistent file."""
        is_valid, error = validate_model_path("/nonexistent/model.pt")
        assert not is_valid
        assert "not found" in error

    def test_invalid_extension(self, tmp_path) -> None:
        """Should fail for unsupported extension."""
        path = tmp_path / "model.txt"
        path.touch()
        is_valid, error = validate_model_path(str(path))
        assert not is_valid
        assert "Unsupported" in error
```

### 5. CLI Tests

```python
"""Tests for Phase 5 CLI parameters."""

import pytest
from click.testing import CliRunner

from fusion.cli.run_sim import run_sim


@pytest.fixture
def runner():
    """CLI test runner."""
    return CliRunner()


class TestPolicyCLI:
    """Test suite for policy CLI options."""

    def test_policy_type_option(self, runner) -> None:
        """Should accept --policy option."""
        result = runner.invoke(run_sim, ["--policy", "shortest_feasible", "--dry-run"])
        assert result.exit_code == 0 or "policy" in str(result.exception).lower()

    def test_policy_device_option(self, runner) -> None:
        """Should accept --policy-device option."""
        result = runner.invoke(run_sim, ["--policy-device", "cuda", "--dry-run"])
        # Should not fail on unknown option
        assert "--policy-device" not in result.output or result.exit_code == 0


class TestProtectionCLI:
    """Test suite for protection CLI options."""

    def test_protection_flag(self, runner) -> None:
        """Should accept --protection flag."""
        result = runner.invoke(run_sim, ["--protection", "--dry-run"])
        # Should toggle protection on
        assert result.exit_code == 0 or "protection" in str(result.exception).lower()

    def test_no_protection_flag(self, runner) -> None:
        """Should accept --no-protection flag."""
        result = runner.invoke(run_sim, ["--no-protection", "--dry-run"])
        assert result.exit_code == 0 or "protection" in str(result.exception).lower()


class TestCLIOverrides:
    """Test CLI parameter overrides."""

    def test_cli_overrides_config(self, runner, tmp_path) -> None:
        """CLI parameters should override config file."""
        # Create config file with first_feasible
        config_path = tmp_path / "test.ini"
        config_path.write_text("""
[policy]
type = first_feasible
""")

        # Run with --policy override
        result = runner.invoke(run_sim, [
            "-c", str(config_path),
            "--policy", "shortest_feasible",
            "--dry-run",
        ])

        # CLI should override config
        # (verify in actual implementation)
```

### 6. Integration Tests

```python
"""Integration tests for Phase 5 configuration."""

import pytest
import tempfile
from pathlib import Path

from fusion.domain.config import SimulationConfig
from fusion.configs.loader import load_config
from fusion.policies.policy_factory import PolicyFactory
from fusion.pipelines.protection_pipeline import ProtectionPipeline


class TestConfigIntegration:
    """Integration tests for configuration system."""

    def test_config_to_policy(self) -> None:
        """Should create policy from config."""
        config = SimulationConfig(policy_type="shortest_feasible")
        policy = PolicyFactory.create(config)

        from fusion.policies.heuristic_policy import ShortestFeasiblePolicy
        assert isinstance(policy, ShortestFeasiblePolicy)

    def test_config_to_protection_pipeline(self) -> None:
        """Should create ProtectionPipeline from config."""
        config = SimulationConfig(
            protection_enabled=True,
            protection_disjointness="link",
            protection_switchover_ms=50.0,
        )

        protection_config = config.create_protection_config()
        pipeline = ProtectionPipeline(protection_config)

        assert pipeline.config.enabled
        assert pipeline.config.switchover_time_ms == 50.0

    def test_full_config_load_and_use(self) -> None:
        """Should load full config and use for simulation setup."""
        content = """
[simulation]
name = integration_test
seed = 42

[policy]
type = load_balanced

[protection]
enabled = true
disjointness = link

[heuristic]
load_balance_alpha = 0.7
"""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".ini", delete=False) as f:
            f.write(content)
            config_path = f.name

        config = load_config(config_path)

        assert config.policy_type == "load_balanced"
        assert config.protection_enabled is True
        assert config.heuristic_load_balance_alpha == 0.7

        # Create policy with heuristic config
        policy = PolicyFactory.create(config)
        assert policy.alpha == 0.7  # If LoadBalancedPolicy exposes alpha

        # Create protection pipeline
        protection = ProtectionPipeline(config.create_protection_config())
        assert protection.config.enabled
```

### 7. Acceptance Criteria

| Criterion | Test Coverage |
|-----------|---------------|
| Schema includes all fields | `TestPolicySchema`, etc. |
| Defaults used for missing sections | `test_load_without_phase5_sections` |
| All fields loaded correctly | `test_load_with_all_sections` |
| Validation catches errors | `TestPolicyValidation`, etc. |
| CLI parameters work | `TestPolicyCLI`, etc. |
| CLI overrides config | `test_cli_overrides_config` |
| Config creates pipeline objects | `TestConfigIntegration` |

---

## Verification Commands

```bash
# Run configuration tests
pytest fusion/configs/tests/ -v

# Run with coverage
pytest fusion/configs/tests/ -v --cov=fusion/configs --cov-report=term-missing

# Type checking
mypy fusion/configs/
mypy fusion/domain/config.py
mypy fusion/cli/parameters/phase5.py

# Lint checking
ruff check fusion/configs/
ruff check fusion/cli/parameters/

# Test CLI help
python -m fusion.cli.run_sim --help
```

---

## Exit Criteria for P5.6 (and Phase 5)

- [ ] All Phase 5 configuration tests pass
- [ ] Schema validation works for all sections
- [ ] Config loader handles missing sections gracefully
- [ ] CLI parameters override config values
- [ ] Templates demonstrate all configuration options
- [ ] Configuration integrates with PolicyFactory
- [ ] Configuration integrates with ProtectionPipeline
- [ ] Type checking passes
- [ ] Lint checking passes

---

## Phase 5 Completion

With P5.6 complete, Phase 5 (ML Control + Protection) is fully documented. The phase includes:

1. **P5.1**: ControlPolicy Protocol
2. **P5.2**: Heuristic Policies
3. **P5.3**: ML Policy Support
4. **P5.4**: Protection Pipeline
5. **P5.5**: Orchestrator Integration
6. **P5.6**: Configuration Extension

Total documentation files: 48
