# Task ID: P5.1.b - Design ControlPolicy Protocol

**Sub-phase:** P5.1
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Define the complete `ControlPolicy` protocol per the V4 specification. This protocol provides a unified interface for all path selection strategies: heuristics, RL policies, and ML policies.

**REVISION NOTE**: This file has been updated to include `get_name()` method per the V4 specification requirement for logging and metrics support.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.1_control_policy_protocol/P5.1.shared_context_existing_policies.md`
- `.claude/v4-docs/migration/phase_5_ml_protection.md` (P5.1 section)
- `.claude/v4-docs/decisions/0010-control-policy-protocol.md`
- `fusion/domain/request.py` (Request dataclass)

---

## Outputs

### 1. Create `fusion/interfaces/control_policy.py`

```python
"""
ControlPolicy protocol for unified path selection.

This module defines the ControlPolicy protocol that all path selection
strategies must implement: heuristics, RL policies, and ML policies.

The protocol uses Python's structural typing (Protocol) to allow any class
with the required methods to be used as a policy without explicit inheritance.

Example:
    >>> class MyPolicy:
    ...     def select_action(self, request, options, network_state) -> int:
    ...         return 0  # Always select first option
    ...     def update(self, request, action, reward) -> None:
    ...         pass  # No learning
    ...     def get_name(self) -> str:
    ...         return "MyPolicy"
    >>>
    >>> policy = MyPolicy()
    >>> isinstance(policy, ControlPolicy)  # True
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Protocol, runtime_checkable

if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.rl.adapter import PathOption


@runtime_checkable
class ControlPolicy(Protocol):
    """
    Protocol for control policies that select actions for resource allocation.

    This protocol defines the interface for all path selection strategies
    in the FUSION simulation framework. Implementations include:

    - **Heuristic policies**: Rule-based selection (first-fit, shortest-path)
    - **RL policies**: Reinforcement learning agents (PPO, DQN, etc.)
    - **ML policies**: Pre-trained neural networks or classifiers
    - **Composite policies**: FallbackPolicy, TiebreakingPolicy

    All policies must:

    1. **Respect feasibility**: Only select paths where `PathOption.is_feasible` is True
    2. **Return valid indices**: Return 0 to len(options)-1, or -1 for no valid action
    3. **Never mutate state**: NetworkState must remain unchanged during select_action
    4. **Provide a name**: Return descriptive name via get_name() for logging

    Attributes:
        None required - this is a structural protocol

    Example:
        >>> policy = FirstFeasiblePolicy()
        >>> action = policy.select_action(request, options, network_state)
        >>> if action >= 0:
        ...     result = orchestrator.apply_action(action, request, options)
        ...     policy.update(request, action, result.reward)
        ...     logger.info(f"Policy {policy.get_name()} selected action {action}")
        >>> else:
        ...     # No feasible path - request blocked
        ...     handle_blocking(request)
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select an action (path index) for the given request.

        This method is the core decision-making interface. It receives the
        current request, available path options (with feasibility information),
        and read-only network state. It returns the index of the selected path.

        Args:
            request: The incoming request to serve. Contains source, destination,
                bandwidth requirements, and timing information.
            options: List of available path options, each with:
                - path_index: Index in this list (0 to len-1)
                - path: Node sequence
                - weight_km: Path length
                - is_feasible: Whether spectrum is available
                - congestion: Current congestion level (0-1)
                - slots_needed: Required spectrum slots
                - modulation: Selected modulation format
                For protected paths, also includes backup_path, backup_feasible.
            network_state: Current state of the network. This is read-only;
                policies must not modify network state. Use for additional
                context (e.g., global congestion, topology info).

        Returns:
            int: Path index (0 to len(options)-1) for the selected path,
                or -1 if no valid action exists.

        Raises:
            No exceptions should be raised. Invalid states should return -1.

        Note:
            - Policies MUST only return indices where options[i].is_feasible is True
            - For protected paths, check options[i].both_paths_feasible for full protection
            - Returning an infeasible index is undefined behavior (orchestrator may reject)
        """
        ...

    def update(self, request: Request, action: int, reward: float) -> None:
        """
        Update policy based on experience.

        Called after an action is executed and the reward is computed. This
        enables online learning for RL policies. Heuristic and pre-trained ML
        policies typically implement this as a no-op.

        Args:
            request: The request that was served
            action: The action (path index) that was taken
            reward: The reward received. Typically:
                - Positive for successful allocation
                - Negative for blocking
                - May include shaping terms (fragmentation, utilization)

        Returns:
            None

        Note:
            - Heuristic policies should implement this as `pass`
            - RL policies may update internal state, replay buffers, etc.
            - ML policies (pre-trained) typically implement as `pass`
            - This method should not raise exceptions
        """
        ...

    def get_name(self) -> str:
        """
        Return the policy name for logging and metrics.

        This method enables meaningful logging messages and metrics tracking.
        Names should be descriptive and include relevant configuration.

        Returns:
            str: Human-readable policy name

        Examples:
            - "FirstFeasiblePolicy"
            - "ShortestFeasiblePolicy"
            - "LoadBalancedPolicy(alpha=0.5)"
            - "RLPolicy(PPO)"
            - "MLControlPolicy(pytorch)"
            - "FallbackPolicy(MLControlPolicy->FirstFeasiblePolicy)"
        """
        ...


# Type alias for policy action results
PolicyAction = int
"""Type alias for policy action: -1 for invalid, 0 to k-1 for valid path index."""
```

### 2. Design Rationale Table

| Decision | Rationale |
|----------|-----------|
| **Protocol over ABC** | Structural typing allows any conforming class to be a policy without inheritance. Enables third-party extensions. |
| **@runtime_checkable** | Enables `isinstance()` checks for validation and debugging. |
| **PathOption list (not mask)** | Feasibility embedded in options is cleaner than separate mask. Path data and feasibility travel together. |
| **NetworkState parameter** | Policies may need global context (congestion, topology). Read-only access prevents mutation. |
| **Action as int** | Compatible with Gymnasium discrete action spaces. Simple, efficient. |
| **-1 for invalid** | Explicit invalid action better than raising exception. Matches existing convention. |
| **update() method** | Enables online learning for RL policies. No-op for heuristics is low overhead. |
| **get_name() method** | Required for meaningful logging, metrics, and debugging. Orchestrator uses this. |
| **TYPE_CHECKING imports** | Avoid circular imports while maintaining type hints. |

### 3. Protocol Compliance Examples

#### Minimal Compliant Implementation

```python
class MinimalPolicy:
    """Minimal implementation that satisfies ControlPolicy protocol."""

    def select_action(self, request, options, network_state) -> int:
        for opt in options:
            if opt.is_feasible:
                return opt.path_index
        return -1

    def update(self, request, action, reward) -> None:
        pass

    def get_name(self) -> str:
        return "MinimalPolicy"
```

#### Non-Compliant Examples

```python
# WRONG: Missing update method
class BadPolicy1:
    def select_action(self, request, options, network_state) -> int:
        return 0
    def get_name(self) -> str:
        return "BadPolicy1"
# isinstance(BadPolicy1(), ControlPolicy) == False

# WRONG: Missing get_name method
class BadPolicy2:
    def select_action(self, request, options, network_state) -> int:
        return 0
    def update(self, request, action, reward) -> None:
        pass
# isinstance(BadPolicy2(), ControlPolicy) == False

# WRONG: Wrong return type for get_name
class BadPolicy3:
    def select_action(self, request, options, network_state) -> int:
        return 0
    def update(self, request, action, reward) -> None:
        pass
    def get_name(self) -> int:  # Should be str
        return 42
# Type checker will reject
```

### 4. Integration with Type Checking

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.interfaces.control_policy import ControlPolicy

def run_with_policy(policy: "ControlPolicy", request, options, state) -> int:
    """Example function using ControlPolicy type hint."""
    logger.info(f"Running policy: {policy.get_name()}")
    action = policy.select_action(request, options, state)
    if action >= 0:
        reward = compute_reward(action)
        policy.update(request, action, reward)
    return action
```

### 5. Runtime Validation

```python
from fusion.interfaces.control_policy import ControlPolicy

def validate_policy(policy: object) -> bool:
    """Validate that an object implements ControlPolicy."""
    if not isinstance(policy, ControlPolicy):
        raise TypeError(
            f"Expected ControlPolicy, got {type(policy).__name__}. "
            f"Policy must implement select_action(), update(), and get_name() methods."
        )
    return True
```

---

## Verification

- [ ] `ControlPolicy` protocol defined with `select_action`, `update`, and `get_name` methods
- [ ] Protocol is decorated with `@runtime_checkable`
- [ ] Comprehensive docstrings for protocol and methods
- [ ] Type hints use `TYPE_CHECKING` guard for forward references
- [ ] `PolicyAction` type alias defined
- [ ] Design rationale documented for all decisions
- [ ] Compliant and non-compliant examples provided
- [ ] get_name() documentation includes example return values

---

## Test Cases to Implement

```python
# In fusion/tests/interfaces/test_control_policy.py

def test_protocol_isinstance_check():
    """Protocol should support isinstance() checks."""
    class ValidPolicy:
        def select_action(self, request, options, network_state) -> int:
            return 0
        def update(self, request, action, reward) -> None:
            pass
        def get_name(self) -> str:
            return "ValidPolicy"

    policy = ValidPolicy()
    assert isinstance(policy, ControlPolicy)

def test_missing_method_fails_isinstance():
    """Class missing methods should fail isinstance()."""
    class InvalidPolicy:
        def select_action(self, request, options, network_state) -> int:
            return 0
        # Missing update() and get_name()

    policy = InvalidPolicy()
    assert not isinstance(policy, ControlPolicy)

def test_missing_get_name_fails_isinstance():
    """Class missing get_name() should fail isinstance()."""
    class InvalidPolicy:
        def select_action(self, request, options, network_state) -> int:
            return 0
        def update(self, request, action, reward) -> None:
            pass
        # Missing get_name()

    policy = InvalidPolicy()
    assert not isinstance(policy, ControlPolicy)
```

---

## Next Task

Proceed to **P5.1.c** to design the PathOption extension with protection fields.
