# Task ID: P5.1.a - Context Extraction: PathPolicy Patterns

**Sub-phase:** P5.1
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** context-extraction

---

## Purpose

Extract and document how the existing `PathPolicy` interface works to inform the design of the new `ControlPolicy` protocol. This task gathers the necessary context for subsequent design tasks.

---

## Context to load before running this task

- `fusion/modules/rl/policies/base.py` - PathPolicy abstract base class
- `fusion/modules/rl/policies/ksp_ff_policy.py` - KSPFFPolicy implementation
- `fusion/modules/rl/policies/bc_policy.py` - BCPolicy (behavior cloning) implementation
- `.claude/v4-docs/migration/phase_5_ml_protection.md` (P5.1 section)

---

## Outputs

### 1. PathPolicy Interface Summary

Document the current `PathPolicy` abstract interface:

```python
# From fusion/modules/rl/policies/base.py

from abc import ABC, abstractmethod
from typing import Any

class PathPolicy(ABC):
    """Abstract base class for path selection policies.

    All path selection strategies (heuristics, RL, ML) inherit from this class.
    The primary method is select_path() which takes observation state and
    action mask, returning the selected path index.
    """

    @abstractmethod
    def select_path(self, state: dict[str, Any], action_mask: list[bool]) -> int:
        """
        Select a path index based on current state.

        Args:
            state: Dictionary containing observation features:
                - 'src': Source node index
                - 'dst': Destination node index
                - 'slots_needed': Required spectrum slots
                - 'est_remaining_time': Estimated request duration
                - 'is_disaster': Disaster flag (0 or 1)
                - 'paths': List of per-path feature dicts
            action_mask: Boolean mask where True = valid action

        Returns:
            Selected path index (0 to K-1), or -1 if no valid action
        """
        pass

    def get_name(self) -> str:
        """Return policy name for logging and identification."""
        return self.__class__.__name__
```

### 2. State Dictionary Structure

Document the `state` dictionary format used by existing policies:

```python
state_example = {
    # Request identification
    'src': 0,                      # Source node index (int)
    'dst': 5,                      # Destination node index (int)
    'slots_needed': 4,             # Spectrum slots required (int)
    'est_remaining_time': 100.5,   # Expected holding time (float)

    # Environment context
    'is_disaster': 0,              # Disaster active flag (0 or 1)

    # Per-path features (K paths)
    'paths': [
        {
            'path_hops': 3,                    # Number of hops (int)
            'min_residual_slots': 12,          # Minimum available slots on path (int)
            'frag_indicator': 0.25,            # Fragmentation metric 0-1 (float)
            'failure_mask': 0,                 # Path affected by failure (0 or 1)
            'dist_to_disaster_centroid': 5,    # Distance to disaster (int)
        },
        # ... repeated for each of K candidate paths
    ]
}
```

### 3. Action Mask Convention

Document how action masking works:

```python
# Action mask format
action_mask = [True, False, True, False, False]  # K=5 paths

# Interpretation:
# - action_mask[i] == True  => Path i is feasible (valid selection)
# - action_mask[i] == False => Path i is infeasible (blocked)

# Selection rules:
# 1. Policy MUST only return indices where mask is True
# 2. Policy returns -1 if all masks are False (no valid action)
# 3. Violating the mask causes undefined behavior

# Example compliant implementation:
def select_first_feasible(state: dict, action_mask: list[bool]) -> int:
    for i, is_valid in enumerate(action_mask):
        if is_valid:
            return i
    return -1
```

### 4. Existing Policy Implementation Patterns

#### KSPFFPolicy (Heuristic - First Fit)

```python
class KSPFFPolicy(PathPolicy):
    """K-Shortest Path First Fit.

    Selects the first feasible path in order (assumes paths sorted by length).
    Simple, deterministic, no learning.
    """

    def select_path(self, state: dict[str, Any], action_mask: list[bool]) -> int:
        for i, is_valid in enumerate(action_mask):
            if is_valid:
                return i
        return -1
```

**Pattern:** Iterate through mask, return first True index.

#### BCPolicy (ML - Behavior Cloning)

```python
class BCPolicy(PathPolicy):
    """Behavior Cloning policy using pre-trained neural network.

    Loads a model trained to imitate expert (heuristic) behavior.
    Uses action masking to ensure valid selections.
    """

    def __init__(self, model_path: str, device: str = "cpu"):
        self.model = self._load_model(model_path)
        self.device = device

    def select_path(self, state: dict[str, Any], action_mask: list[bool]) -> int:
        # 1. Extract features from state dict
        features = self._extract_features(state)

        # 2. Get model predictions (logits or probabilities)
        with torch.no_grad():
            tensor = torch.FloatTensor(features).to(self.device)
            logits = self.model(tensor)

        # 3. Apply action mask
        masked_logits = logits.clone()
        for i, valid in enumerate(action_mask):
            if not valid:
                masked_logits[i] = float('-inf')

        # 4. Select highest-scoring valid action
        return int(torch.argmax(masked_logits).item())

    def _extract_features(self, state: dict) -> np.ndarray:
        # Flatten state dict into feature vector
        features = [
            state['slots_needed'] / 100.0,  # Normalized
            state['is_disaster'],
        ]
        for path in state['paths']:
            features.extend([
                path['path_hops'] / 10.0,
                path['min_residual_slots'] / 100.0,
                path['frag_indicator'],
                path['failure_mask'],
            ])
        return np.array(features, dtype=np.float32)
```

**Pattern:** Feature extraction -> Model inference -> Mask application -> Argmax selection.

### 5. Gap Analysis: PathPolicy vs ControlPolicy

| Feature | PathPolicy (Legacy) | ControlPolicy (V4 Spec) |
|---------|---------------------|-------------------------|
| **Input format** | `state` dict + `action_mask` list | `Request` + `PathOption` list + `NetworkState` |
| **Feasibility** | Separate `action_mask` | Embedded in `PathOption.is_feasible` |
| **Learning** | No update method | `update(request, action, reward)` |
| **Network access** | Via state dict features | Direct `NetworkState` access |
| **Typing** | ABC inheritance | Protocol (structural typing) |
| **Request data** | Encoded in state dict | Typed `Request` object |
| **Path data** | Encoded in state dict | Typed `PathOption` objects |

### 6. Migration Considerations

**Changes required for existing policies:**

1. **Interface change**: `select_path(state, mask)` -> `select_action(request, options, network_state)`
2. **Feasibility source**: Extract from `PathOption.is_feasible` instead of separate mask
3. **Feature extraction**: Build from `Request` + `PathOption` instead of state dict
4. **Protocol compliance**: Add `update()` method (no-op for heuristics)

**Adapter pattern for gradual migration:**

```python
class PathPolicyAdapter:
    """Wraps legacy PathPolicy to implement ControlPolicy interface."""

    def __init__(self, legacy_policy: PathPolicy):
        self._legacy = legacy_policy

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState
    ) -> int:
        state = self._build_legacy_state(request, options, network_state)
        mask = [opt.is_feasible for opt in options]
        return self._legacy.select_path(state, mask)

    def update(self, request: Request, action: int, reward: float) -> None:
        pass  # Legacy policies don't support updates

    def _build_legacy_state(self, request, options, network_state) -> dict:
        # Reconstruct legacy state dict format
        return {
            'src': request.source,
            'dst': request.destination,
            'slots_needed': request.slots_needed,
            'est_remaining_time': request.holding_time,
            'is_disaster': 0,  # From network_state if available
            'paths': [
                {
                    'path_hops': len(opt.path) - 1,
                    'min_residual_slots': 0,  # Would need network_state query
                    'frag_indicator': 0.0,
                    'failure_mask': 0,
                    'dist_to_disaster_centroid': 0,
                }
                for opt in options
            ]
        }
```

---

## Verification

- [ ] PathPolicy interface documented with method signatures
- [ ] State dictionary structure documented with all fields
- [ ] Action mask convention documented with examples
- [ ] At least 2 existing policy implementations analyzed
- [ ] Gap analysis comparing PathPolicy to ControlPolicy spec
- [ ] Migration considerations documented with adapter pattern

---

## Next Task

Proceed to **P5.1.b** to design the ControlPolicy protocol based on these findings.
