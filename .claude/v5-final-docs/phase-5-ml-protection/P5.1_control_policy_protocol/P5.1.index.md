# P5.1 Index - ControlPolicy Protocol + RLPolicy Adapter

**Phase:** 5 - ML Control + Protection Integration
**Sub-phase:** P5.1
**Status:** Not Started

---

## Goals

1. Define the `ControlPolicy` protocol that provides a unified interface for all path selection strategies (heuristics, RL, ML)
2. Extend `PathOption` with protection fields and `both_paths_feasible` property
3. Implement `RLPolicy` wrapper that enables existing SB3 models to implement ControlPolicy
4. Ensure RL continues to work unchanged via the adapter pattern

### Core Principle: Protocol-Based Design

Use Python's `Protocol` for structural typing, allowing any class with `select_action`, `update`, and `get_name` methods to be used as a policy without explicit inheritance. This enables:

1. **Flexibility**: Third-party policies without code modification
2. **Duck Typing**: Any conforming class is automatically a valid policy
3. **Runtime Checking**: `isinstance()` works via `@runtime_checkable`
4. **RL Compatibility**: Existing RL code works through RLPolicy wrapper

---

## Key Deliverables

| # | Deliverable | Description |
|---|-------------|-------------|
| 1 | `fusion/interfaces/control_policy.py` | ControlPolicy protocol definition with get_name() |
| 2 | `fusion/policies/__init__.py` | Policies package initialization |
| 3 | `fusion/policies/rl_policy.py` | RLPolicy wrapper for SB3 models |
| 4 | PathOption extension | Add protection fields and both_paths_feasible property |

---

## Constraints

1. **Protocol must be `@runtime_checkable`** for isinstance() checks
2. **Protocol includes `get_name()`** for logging and metrics
3. **PathOption must be frozen dataclass** with protection fields
4. **PathOption must have `both_paths_feasible` property** for protection
5. **Action returns path index (0 to k-1) or -1** for invalid
6. **NetworkState is read-only** during select_action
7. **Policies never mutate state** - orchestrator applies actions
8. **RLPolicy must wrap SB3 models** for backwards compatibility

---

## Dependencies

### From Earlier Phases
- **Phase 1**: `Request` dataclass from `fusion/domain/request.py`
- **Phase 2**: `NetworkState` from `fusion/domain/network_state.py`
- **Phase 4**: `PathOption` from `fusion/rl/adapter.py` (to be extended)
- **Phase 4**: `RLSimulationAdapter` for observation building

### External Dependencies
- Python `typing.Protocol` (standard library)
- `stable-baselines3` (optional, for RLPolicy)

---

## Micro-Tasks

| ID | File | Type | Description |
|----|------|------|-------------|
| P5.1.a | `P5.1.a_context_extraction_path_policy.md` | context-extraction | Extract existing PathPolicy patterns |
| P5.1.b | `P5.1.b_design_control_policy_protocol.md` | design | Design ControlPolicy protocol with get_name() |
| P5.1.c | `P5.1.c_design_pathoption_extension.md` | design | Extend PathOption for protection |
| P5.1.d | `P5.1.d_implement_control_policy.md` | wiring-plan | Implement protocol and package |
| P5.1.e | `P5.1.e_design_rl_policy_wrapper.md` | design | **NEW**: Design RLPolicy wrapper |
| P5.1.f | `P5.1.f_implement_rl_policy.md` | wiring-plan | **NEW**: Implement RLPolicy |
| P5.1.g | `P5.1.g_verification_plan.md` | verification-plan | Unit tests for protocol and RLPolicy |

---

## Shared Context Files

| File | Purpose |
|------|---------|
| `P5.1.shared_context_existing_policies.md` | Summarizes existing PathPolicy interface and implementations |

---

## Interface Summary

### ControlPolicy Protocol (Updated)

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class ControlPolicy(Protocol):
    """Protocol for control policies that select actions for resource allocation."""

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select action (path index 0 to k-1) or -1 for invalid."""
        ...

    def update(self, request: Request, action: int, reward: float) -> None:
        """Update policy based on experience (no-op for heuristics)."""
        ...

    def get_name(self) -> str:
        """Return policy name for logging and metrics."""
        ...
```

### PathOption Extension (Protection Fields + Property)

```python
@dataclass(frozen=True)
class PathOption:
    # Existing fields
    path_index: int
    path: tuple[str, ...]
    weight_km: float
    is_feasible: bool
    modulation: str | None
    slots_needed: int | None
    congestion: float

    # New protection fields
    backup_path: tuple[str, ...] | None = None
    backup_feasible: bool | None = None
    backup_weight_km: float | None = None
    backup_modulation: str | None = None
    is_protected: bool = False

    @property
    def both_paths_feasible(self) -> bool:
        """True if both primary and backup are feasible (for protected paths)."""
        if not self.is_protected:
            return self.is_feasible
        return self.is_feasible and (self.backup_feasible or False)
```

### RLPolicy Wrapper

```python
class RLPolicy:
    """
    Wrapper enabling SB3 models to implement ControlPolicy.

    This adapter bridges the existing RL infrastructure with the
    new ControlPolicy interface, ensuring backwards compatibility.
    """

    def __init__(
        self,
        model: BaseAlgorithm,
        adapter: RLSimulationAdapter | None = None,
    ) -> None:
        self.model = model
        self._adapter = adapter

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select action using trained SB3 model."""
        obs = self._build_observation(request, options, network_state)
        action_mask = [opt.is_feasible for opt in options]
        action, _ = self.model.predict(obs, action_masks=action_mask)
        return int(action)

    def update(self, request: Request, action: int, reward: float) -> None:
        """No-op - model is pre-trained."""
        pass

    def get_name(self) -> str:
        """Return policy name."""
        return f"RLPolicy({type(self.model).__name__})"
```

---

## RL Compatibility Design

The RLPolicy wrapper ensures existing RL code continues to work:

```
                    ControlPolicy Protocol
                           |
            +-------------+-------------+
            |             |             |
      HeuristicPolicy  RLPolicy    MLControlPolicy
                          |
                    wraps SB3 Model
                          |
              +--------------------+
              |                    |
         PPO/DQN/A2C        model.predict()
```

### Usage Patterns

```python
# 1. Use RLPolicy directly with ControlPolicy interface
rl_policy = RLPolicy(trained_model)
action = rl_policy.select_action(request, options, network_state)

# 2. Use through Orchestrator
orchestrator = SDNOrchestrator(config, pipelines, policy=rl_policy)
result = orchestrator.handle_arrival(request, network_state)

# 3. Use through UnifiedSimEnv (unchanged from Phase 4)
env = UnifiedSimEnv(config)
obs, info = env.reset()
action, _ = model.predict(obs)  # Direct SB3 usage unchanged
```

---

## Exit Criteria

- [ ] `ControlPolicy` protocol defined with `select_action`, `update`, and `get_name` methods
- [ ] Protocol is `@runtime_checkable` and passes isinstance() tests
- [ ] PathOption extended with protection fields (backup_path, backup_feasible, etc.)
- [ ] PathOption has `both_paths_feasible` property
- [ ] RLPolicy wraps SB3 models and implements ControlPolicy
- [ ] RLPolicy builds observations using adapter pattern
- [ ] RLPolicy applies action masking for feasibility
- [ ] `fusion/policies/__init__.py` exports ControlPolicy and RLPolicy
- [ ] mypy passes on all new files
- [ ] Unit tests verify protocol compliance for all policy types
- [ ] Documentation complete in all micro-task files

---

## Next Sub-Phase

After completing P5.1, proceed to:
- **P5.2** (Heuristic + Composite Policies) - implements ControlPolicy with heuristic and composite strategies
- **P5.3** (ML Policy Support) - implements ControlPolicy with ML models
- **P5.4** (Protection Pipeline) - uses extended PathOption for protected routes
