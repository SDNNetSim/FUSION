# Task ID: P5.1.c - Design PathOption Extension

**Sub-phase:** P5.1
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Extend the `PathOption` dataclass to support 1+1 protection path pairs. This enables policies to make informed decisions about protected routes where both primary and backup paths must be considered.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-4-rl-integration/P4.1_rl_adapter/P4.1.b_design_pathoption.md` (if exists)
- `.claude/v4-docs/migration/phase_5_ml_protection.md` (P5.4 section - protection requirements)
- `.claude/v4-docs/architecture/protection_pipeline.md` (if exists)
- `fusion/rl/adapter.py` (current PathOption definition, if exists)

---

## Outputs

### 1. Extended PathOption Definition

Update `fusion/rl/adapter.py` (or create if needed):

```python
"""
PathOption dataclass for representing candidate paths.

This module defines PathOption, a frozen dataclass representing a single
candidate path that can be selected by a ControlPolicy. For protected
routes, PathOption includes backup path information.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    pass  # Future type imports


@dataclass(frozen=True)
class PathOption:
    """
    Single path option presented to a policy for selection.

    This immutable dataclass represents one candidate path from a set of
    K paths computed by the routing pipeline. Policies use PathOption
    instances to make selection decisions.

    For unprotected paths, only the primary path fields are populated.
    For protected paths (1+1 protection), backup_* fields contain the
    disjoint backup path information.

    Attributes:
        path_index: Index in the options list (0 to K-1)
        path: Node sequence as tuple (e.g., ("A", "B", "C", "D"))
        weight_km: Total path length in kilometers
        is_feasible: True if spectrum is available on this path
        modulation: Selected modulation format (e.g., "QPSK", "16-QAM")
        slots_needed: Number of spectrum slots required
        congestion: Current path congestion (0.0 to 1.0)

        # Protection fields (optional, for 1+1 protection)
        backup_path: Disjoint backup path node sequence, or None
        backup_feasible: True if spectrum available on backup, or None
        backup_weight_km: Backup path length in km, or None
        backup_modulation: Backup path modulation format, or None
        is_protected: True if this is a protected path pair

    Example (unprotected):
        >>> opt = PathOption(
        ...     path_index=0,
        ...     path=("A", "B", "C"),
        ...     weight_km=150.0,
        ...     is_feasible=True,
        ...     modulation="QPSK",
        ...     slots_needed=4,
        ...     congestion=0.3,
        ... )
        >>> opt.is_protected
        False

    Example (protected):
        >>> opt = PathOption.from_protected_route(
        ...     path_index=0,
        ...     primary_path=["A", "B", "C"],
        ...     backup_path=["A", "D", "E", "C"],
        ...     primary_weight=150.0,
        ...     backup_weight=200.0,
        ...     primary_feasible=True,
        ...     backup_feasible=True,
        ...     primary_modulation="QPSK",
        ...     backup_modulation="QPSK",
        ...     slots_needed=4,
        ...     congestion=0.3,
        ... )
        >>> opt.is_protected
        True
        >>> opt.both_paths_feasible
        True
    """

    # Core path identification
    path_index: int
    path: tuple[str, ...]

    # Path metrics
    weight_km: float
    is_feasible: bool
    modulation: str | None
    slots_needed: int | None
    congestion: float

    # Protection fields (optional)
    backup_path: tuple[str, ...] | None = None
    backup_feasible: bool | None = None
    backup_weight_km: float | None = None
    backup_modulation: str | None = None
    is_protected: bool = False

    def __post_init__(self) -> None:
        """Validate PathOption invariants."""
        # Validate path_index is non-negative
        if self.path_index < 0:
            raise ValueError(f"path_index must be >= 0, got {self.path_index}")

        # Validate path is non-empty
        if not self.path:
            raise ValueError("path must not be empty")

        # Validate congestion is in valid range
        if not 0.0 <= self.congestion <= 1.0:
            raise ValueError(f"congestion must be 0-1, got {self.congestion}")

        # Validate protection fields consistency
        if self.is_protected:
            if self.backup_path is None:
                raise ValueError("is_protected=True requires backup_path")
            if self.backup_feasible is None:
                raise ValueError("is_protected=True requires backup_feasible")

    @property
    def both_paths_feasible(self) -> bool:
        """
        Check if both primary and backup paths are feasible.

        For unprotected paths, returns the primary path's feasibility.
        For protected paths, returns True only if both paths have spectrum.

        Returns:
            True if allocation can proceed (considering protection status)
        """
        if not self.is_protected:
            return self.is_feasible
        return self.is_feasible and (self.backup_feasible is True)

    @property
    def total_weight_km(self) -> float:
        """
        Total path length (primary + backup if protected).

        Returns:
            Combined length for protected paths, primary length otherwise
        """
        if self.is_protected and self.backup_weight_km is not None:
            return self.weight_km + self.backup_weight_km
        return self.weight_km

    @property
    def hop_count(self) -> int:
        """Number of hops in primary path."""
        return len(self.path) - 1

    @property
    def backup_hop_count(self) -> int | None:
        """Number of hops in backup path, or None if unprotected."""
        if self.backup_path is None:
            return None
        return len(self.backup_path) - 1

    @classmethod
    def from_protected_route(
        cls,
        path_index: int,
        primary_path: list[str],
        backup_path: list[str],
        primary_weight: float,
        backup_weight: float,
        primary_feasible: bool,
        backup_feasible: bool,
        primary_modulation: str | None,
        backup_modulation: str | None,
        slots_needed: int,
        congestion: float,
    ) -> "PathOption":
        """
        Factory method to create PathOption for 1+1 protected path pair.

        This method provides a convenient way to construct a protected
        PathOption from separate primary and backup path information.

        Args:
            path_index: Index in the options list
            primary_path: Primary path node sequence
            backup_path: Backup (disjoint) path node sequence
            primary_weight: Primary path length in km
            backup_weight: Backup path length in km
            primary_feasible: Primary path spectrum availability
            backup_feasible: Backup path spectrum availability
            primary_modulation: Primary path modulation format
            backup_modulation: Backup path modulation format
            slots_needed: Spectrum slots required (same for both paths)
            congestion: Combined congestion metric

        Returns:
            PathOption configured for 1+1 protection
        """
        return cls(
            path_index=path_index,
            path=tuple(primary_path),
            weight_km=primary_weight,
            is_feasible=primary_feasible,
            modulation=primary_modulation,
            slots_needed=slots_needed,
            congestion=congestion,
            backup_path=tuple(backup_path),
            backup_feasible=backup_feasible,
            backup_weight_km=backup_weight,
            backup_modulation=backup_modulation,
            is_protected=True,
        )

    @classmethod
    def from_unprotected_route(
        cls,
        path_index: int,
        path: list[str],
        weight_km: float,
        is_feasible: bool,
        modulation: str | None,
        slots_needed: int | None,
        congestion: float,
    ) -> "PathOption":
        """
        Factory method to create PathOption for unprotected route.

        Args:
            path_index: Index in the options list
            path: Path node sequence
            weight_km: Path length in km
            is_feasible: Spectrum availability
            modulation: Modulation format
            slots_needed: Required spectrum slots
            congestion: Path congestion metric

        Returns:
            PathOption configured for unprotected route
        """
        return cls(
            path_index=path_index,
            path=tuple(path),
            weight_km=weight_km,
            is_feasible=is_feasible,
            modulation=modulation,
            slots_needed=slots_needed,
            congestion=congestion,
        )
```

### 2. Design Rationale Table

| Decision | Rationale |
|----------|-----------|
| **frozen=True** | Immutability prevents accidental modification during selection. Enables hashing. |
| **tuple for paths** | Immutable sequence type consistent with frozen dataclass. |
| **Optional backup fields** | Most paths are unprotected; avoid bloat with defaults. |
| **is_protected flag** | Explicit flag clearer than checking backup_path is None. |
| **both_paths_feasible property** | Common check for protection scenarios. |
| **Factory methods** | Cleaner construction than raw __init__ with many args. |
| **__post_init__ validation** | Catch invalid states early with clear error messages. |
| **Congestion 0-1 range** | Normalized metric allows consistent comparison. |

### 3. Type Aliases

Add to module:

```python
from typing import TypeAlias

PathOptionList: TypeAlias = list[PathOption]
"""Type alias for list of path options."""

PathSequence: TypeAlias = tuple[str, ...]
"""Type alias for immutable path node sequence."""
```

### 4. Usage Examples

```python
# Creating unprotected options
options: PathOptionList = [
    PathOption.from_unprotected_route(
        path_index=0,
        path=["A", "B", "C"],
        weight_km=100.0,
        is_feasible=True,
        modulation="QPSK",
        slots_needed=4,
        congestion=0.2,
    ),
    PathOption.from_unprotected_route(
        path_index=1,
        path=["A", "D", "C"],
        weight_km=150.0,
        is_feasible=False,  # No spectrum
        modulation=None,
        slots_needed=None,
        congestion=0.8,
    ),
]

# Creating protected option
protected_opt = PathOption.from_protected_route(
    path_index=0,
    primary_path=["A", "B", "C"],
    backup_path=["A", "D", "E", "C"],
    primary_weight=100.0,
    backup_weight=180.0,
    primary_feasible=True,
    backup_feasible=True,
    primary_modulation="QPSK",
    backup_modulation="8-QAM",
    slots_needed=4,
    congestion=0.3,
)

# Policy selection considering protection
def select_protected_path(options: PathOptionList) -> int:
    """Select first path where both primary and backup are feasible."""
    for opt in options:
        if opt.is_protected and opt.both_paths_feasible:
            return opt.path_index
        elif not opt.is_protected and opt.is_feasible:
            return opt.path_index
    return -1
```

---

## Verification

- [ ] PathOption dataclass extended with protection fields
- [ ] All protection fields have appropriate default values (None/False)
- [ ] `both_paths_feasible` property implemented correctly
- [ ] `total_weight_km` property works for both protected and unprotected
- [ ] Factory methods (`from_protected_route`, `from_unprotected_route`) work
- [ ] `__post_init__` validation catches invalid states
- [ ] Frozen dataclass remains hashable
- [ ] Type aliases defined for common types

---

## Test Cases to Implement

```python
# In fusion/tests/rl/test_pathoption.py

class TestPathOption:
    """Tests for PathOption dataclass."""

    def test_unprotected_default_values(self) -> None:
        """Unprotected PathOption has None backup fields."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        )
        assert opt.backup_path is None
        assert opt.is_protected is False
        assert opt.both_paths_feasible is True

    def test_protected_both_paths_feasible_true(self) -> None:
        """both_paths_feasible True when both paths have spectrum."""
        opt = PathOption.from_protected_route(
            path_index=0,
            primary_path=["A", "B"],
            backup_path=["A", "C", "B"],
            primary_weight=50.0,
            backup_weight=80.0,
            primary_feasible=True,
            backup_feasible=True,
            primary_modulation="QPSK",
            backup_modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
        )
        assert opt.both_paths_feasible is True

    def test_protected_both_paths_feasible_false_backup(self) -> None:
        """both_paths_feasible False when backup infeasible."""
        opt = PathOption.from_protected_route(
            path_index=0,
            primary_path=["A", "B"],
            backup_path=["A", "C", "B"],
            primary_weight=50.0,
            backup_weight=80.0,
            primary_feasible=True,
            backup_feasible=False,  # Backup has no spectrum
            primary_modulation="QPSK",
            backup_modulation=None,
            slots_needed=4,
            congestion=0.3,
        )
        assert opt.both_paths_feasible is False

    def test_total_weight_protected(self) -> None:
        """total_weight_km sums both paths for protected."""
        opt = PathOption.from_protected_route(
            path_index=0,
            primary_path=["A", "B"],
            backup_path=["A", "C", "B"],
            primary_weight=50.0,
            backup_weight=80.0,
            primary_feasible=True,
            backup_feasible=True,
            primary_modulation="QPSK",
            backup_modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
        )
        assert opt.total_weight_km == 130.0

    def test_frozen_immutable(self) -> None:
        """PathOption should be immutable."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        )
        with pytest.raises(dataclasses.FrozenInstanceError):
            opt.is_feasible = False  # type: ignore

    def test_validation_negative_path_index(self) -> None:
        """Should reject negative path_index."""
        with pytest.raises(ValueError, match="path_index must be >= 0"):
            PathOption(
                path_index=-1,
                path=("A", "B"),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=0.5,
            )

    def test_validation_empty_path(self) -> None:
        """Should reject empty path."""
        with pytest.raises(ValueError, match="path must not be empty"):
            PathOption(
                path_index=0,
                path=(),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=0.5,
            )
```

---

## Next Task

Proceed to **P5.1.d** to implement the complete ControlPolicy package.
