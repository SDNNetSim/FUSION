# Task ID: P5.1.d - Implement ControlPolicy Package

**Sub-phase:** P5.1
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** wiring-plan

---

## Purpose

Create the `fusion/policies` package structure and implement all files designed in P5.1.b and P5.1.c. This task wires together the ControlPolicy protocol and extended PathOption.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.1_control_policy_protocol/P5.1.b_design_control_policy_protocol.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.1_control_policy_protocol/P5.1.c_design_pathoption_extension.md`
- `fusion/interfaces/__init__.py` (existing interfaces package)

---

## Outputs

### 1. Create `fusion/interfaces/control_policy.py`

Full implementation from P5.1.b:

```python
"""
ControlPolicy protocol for unified path selection.

This module defines the ControlPolicy protocol that all path selection
strategies must implement: heuristics, RL policies, and ML policies.

The protocol uses Python's structural typing (Protocol) to allow any class
with the required methods to be used as a policy without explicit inheritance.

Example:
    >>> class MyPolicy:
    ...     def select_action(self, request, options, network_state) -> int:
    ...         return 0  # Always select first option
    ...     def update(self, request, action, reward) -> None:
    ...         pass  # No learning
    >>>
    >>> policy = MyPolicy()
    >>> isinstance(policy, ControlPolicy)  # True
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Protocol, runtime_checkable

if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.rl.adapter import PathOption


@runtime_checkable
class ControlPolicy(Protocol):
    """
    Protocol for control policies that select actions for resource allocation.

    This protocol defines the interface for all path selection strategies
    in the FUSION simulation framework. Implementations include:

    - **Heuristic policies**: Rule-based selection (first-fit, shortest-path)
    - **RL policies**: Reinforcement learning agents (PPO, DQN, etc.)
    - **ML policies**: Pre-trained neural networks or classifiers

    All policies must:

    1. **Respect feasibility**: Only select paths where PathOption.is_feasible is True
    2. **Return valid indices**: Return 0 to len(options)-1, or -1 for no valid action
    3. **Never mutate state**: NetworkState must remain unchanged during select_action

    Example:
        >>> policy = FirstFeasiblePolicy()
        >>> action = policy.select_action(request, options, network_state)
        >>> if action >= 0:
        ...     result = orchestrator.apply_action(action, request, options)
        ...     policy.update(request, action, result.reward)
        >>> else:
        ...     handle_blocking(request)
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select an action (path index) for the given request.

        Args:
            request: The incoming request to serve
            options: List of available path options with feasibility info
            network_state: Current network state (read-only access)

        Returns:
            Path index (0 to len(options)-1), or -1 if no valid action
        """
        ...

    def update(self, request: Request, action: int, reward: float) -> None:
        """
        Update policy based on experience (optional for heuristics).

        Args:
            request: The request that was served
            action: The action that was taken
            reward: The reward received
        """
        ...


# Type alias for policy action results
PolicyAction = int
"""Type alias: -1 for invalid action, 0 to k-1 for valid path index."""
```

### 2. Update `fusion/interfaces/__init__.py`

Add ControlPolicy to the interfaces package exports:

```python
"""
FUSION Interfaces Package.

This package defines protocols and abstract interfaces for the simulation.
"""

from fusion.interfaces.control_policy import ControlPolicy, PolicyAction

# Include any existing exports...

__all__ = [
    "ControlPolicy",
    "PolicyAction",
    # ... existing exports
]
```

### 3. Create `fusion/policies/__init__.py`

Initialize the policies package:

```python
"""
FUSION Control Policies Package.

This package provides path selection policies implementing the ControlPolicy
protocol. Available policy types:

**Heuristic Policies** (P5.2):
- FirstFeasiblePolicy: Selects first feasible path
- ShortestFeasiblePolicy: Selects shortest feasible path
- LeastCongestedPolicy: Selects least congested path
- RandomFeasiblePolicy: Random selection among feasible
- LoadBalancedPolicy: Weighted length + congestion

**ML Policies** (P5.3):
- MLControlPolicy: Pre-trained model deployment

**Factory**:
- PolicyFactory: Creates policies from configuration

Example:
    >>> from fusion.policies import FirstFeasiblePolicy, ControlPolicy
    >>> policy = FirstFeasiblePolicy()
    >>> isinstance(policy, ControlPolicy)
    True
"""

from fusion.interfaces.control_policy import ControlPolicy, PolicyAction

__all__ = [
    # Protocol
    "ControlPolicy",
    "PolicyAction",
    # Heuristic policies will be added in P5.2
    # ML policies will be added in P5.3
    # Factory will be added in P5.5
]
```

### 4. Update `fusion/rl/adapter.py` (PathOption Extension)

Add or update the PathOption dataclass:

```python
"""
RL Simulation Adapter with PathOption dataclass.

This module provides the PathOption dataclass for representing candidate
paths and the RLSimulationAdapter for bridging RL and simulation.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TypeAlias

# Type aliases
PathOptionList: TypeAlias = list["PathOption"]
PathSequence: TypeAlias = tuple[str, ...]


@dataclass(frozen=True)
class PathOption:
    """
    Single path option presented to a policy for selection.

    For unprotected paths, only primary path fields are populated.
    For protected paths (1+1), backup_* fields contain disjoint backup info.

    Attributes:
        path_index: Index in the options list (0 to K-1)
        path: Node sequence as tuple
        weight_km: Path length in kilometers
        is_feasible: True if spectrum is available
        modulation: Selected modulation format
        slots_needed: Number of spectrum slots required
        congestion: Path congestion (0.0 to 1.0)
        backup_path: Disjoint backup path, or None
        backup_feasible: Backup spectrum availability, or None
        backup_weight_km: Backup path length, or None
        backup_modulation: Backup modulation format, or None
        is_protected: True if this is a protected path pair
    """

    # Core path identification
    path_index: int
    path: tuple[str, ...]

    # Path metrics
    weight_km: float
    is_feasible: bool
    modulation: str | None
    slots_needed: int | None
    congestion: float

    # Protection fields (optional)
    backup_path: tuple[str, ...] | None = None
    backup_feasible: bool | None = None
    backup_weight_km: float | None = None
    backup_modulation: str | None = None
    is_protected: bool = False

    def __post_init__(self) -> None:
        """Validate PathOption invariants."""
        if self.path_index < 0:
            raise ValueError(f"path_index must be >= 0, got {self.path_index}")
        if not self.path:
            raise ValueError("path must not be empty")
        if not 0.0 <= self.congestion <= 1.0:
            raise ValueError(f"congestion must be 0-1, got {self.congestion}")
        if self.is_protected:
            if self.backup_path is None:
                raise ValueError("is_protected=True requires backup_path")
            if self.backup_feasible is None:
                raise ValueError("is_protected=True requires backup_feasible")

    @property
    def both_paths_feasible(self) -> bool:
        """True if both primary and backup paths are feasible."""
        if not self.is_protected:
            return self.is_feasible
        return self.is_feasible and (self.backup_feasible is True)

    @property
    def total_weight_km(self) -> float:
        """Total path length (primary + backup if protected)."""
        if self.is_protected and self.backup_weight_km is not None:
            return self.weight_km + self.backup_weight_km
        return self.weight_km

    @property
    def hop_count(self) -> int:
        """Number of hops in primary path."""
        return len(self.path) - 1

    @property
    def backup_hop_count(self) -> int | None:
        """Number of hops in backup path, or None if unprotected."""
        if self.backup_path is None:
            return None
        return len(self.backup_path) - 1

    @classmethod
    def from_protected_route(
        cls,
        path_index: int,
        primary_path: list[str],
        backup_path: list[str],
        primary_weight: float,
        backup_weight: float,
        primary_feasible: bool,
        backup_feasible: bool,
        primary_modulation: str | None,
        backup_modulation: str | None,
        slots_needed: int,
        congestion: float,
    ) -> "PathOption":
        """Factory method for 1+1 protected path pair."""
        return cls(
            path_index=path_index,
            path=tuple(primary_path),
            weight_km=primary_weight,
            is_feasible=primary_feasible,
            modulation=primary_modulation,
            slots_needed=slots_needed,
            congestion=congestion,
            backup_path=tuple(backup_path),
            backup_feasible=backup_feasible,
            backup_weight_km=backup_weight,
            backup_modulation=backup_modulation,
            is_protected=True,
        )

    @classmethod
    def from_unprotected_route(
        cls,
        path_index: int,
        path: list[str],
        weight_km: float,
        is_feasible: bool,
        modulation: str | None,
        slots_needed: int | None,
        congestion: float,
    ) -> "PathOption":
        """Factory method for unprotected route."""
        return cls(
            path_index=path_index,
            path=tuple(path),
            weight_km=weight_km,
            is_feasible=is_feasible,
            modulation=modulation,
            slots_needed=slots_needed,
            congestion=congestion,
        )
```

### 5. Directory Structure After Task

```
fusion/
├── interfaces/
│   ├── __init__.py          # Updated with ControlPolicy export
│   └── control_policy.py    # NEW: ControlPolicy protocol
├── policies/
│   └── __init__.py          # NEW: Policies package
└── rl/
    └── adapter.py           # UPDATED: PathOption with protection fields
```

---

## Verification Commands

```bash
# Check Python syntax
python -c "from fusion.interfaces.control_policy import ControlPolicy; print('OK')"
python -c "from fusion.policies import ControlPolicy; print('OK')"
python -c "from fusion.rl.adapter import PathOption; print('OK')"

# Type checking
mypy fusion/interfaces/control_policy.py
mypy fusion/policies/__init__.py
mypy fusion/rl/adapter.py

# Linting
ruff check fusion/interfaces/control_policy.py
ruff check fusion/policies/__init__.py
ruff check fusion/rl/adapter.py
```

---

## Verification Checklist

- [ ] `fusion/interfaces/control_policy.py` created with ControlPolicy protocol
- [ ] `fusion/interfaces/__init__.py` updated to export ControlPolicy
- [ ] `fusion/policies/__init__.py` created as package entry point
- [ ] `fusion/rl/adapter.py` updated with extended PathOption
- [ ] All files pass `python -c` import test
- [ ] All files pass mypy type checking
- [ ] All files pass ruff linting

---

## Next Task

Proceed to **P5.1.e** to create verification tests for the ControlPolicy protocol.
