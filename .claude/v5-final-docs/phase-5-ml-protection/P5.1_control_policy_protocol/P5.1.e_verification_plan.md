# Task ID: P5.1.e - Verification Plan: ControlPolicy Protocol

**Sub-phase:** P5.1
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** verification-plan

---

## Purpose

Define comprehensive unit tests ensuring the ControlPolicy protocol and PathOption extension are correct and maintain their invariants.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.1_control_policy_protocol/P5.1.d_implement_control_policy.md`
- `fusion/interfaces/control_policy.py`
- `fusion/rl/adapter.py`
- `.claude/v4-docs/testing/phase_5_testing.md` (if exists)

---

## Outputs

### 1. Test File Structure

```
fusion/tests/
├── interfaces/
│   ├── __init__.py
│   └── test_control_policy.py    # Protocol tests
└── rl/
    ├── __init__.py
    └── test_pathoption.py        # PathOption tests
```

### 2. Create `fusion/tests/interfaces/__init__.py`

```python
"""Tests for fusion.interfaces package."""
```

### 3. Create `fusion/tests/interfaces/test_control_policy.py`

```python
"""
Tests for ControlPolicy protocol.

This module verifies that:
1. The ControlPolicy protocol is properly defined
2. isinstance() checks work with @runtime_checkable
3. Compliant classes pass protocol checks
4. Non-compliant classes fail protocol checks
"""

from __future__ import annotations

import pytest

from fusion.interfaces.control_policy import ControlPolicy, PolicyAction


class MockValidPolicy:
    """Mock policy that correctly implements ControlPolicy."""

    def __init__(self) -> None:
        self.update_called = False
        self.last_action: int | None = None

    def select_action(self, request, options, network_state) -> int:
        """Select first feasible option."""
        for opt in options:
            if opt.is_feasible:
                return opt.path_index
        return -1

    def update(self, request, action, reward) -> None:
        """Record that update was called."""
        self.update_called = True
        self.last_action = action


class MockLearningPolicy:
    """Mock policy that tracks learning updates."""

    def __init__(self) -> None:
        self.experiences: list[tuple] = []

    def select_action(self, request, options, network_state) -> int:
        return 0 if options and options[0].is_feasible else -1

    def update(self, request, action, reward) -> None:
        self.experiences.append((request, action, reward))


class TestControlPolicyProtocol:
    """Test ControlPolicy protocol definition."""

    def test_isinstance_check_valid_policy(self) -> None:
        """Valid policy should pass isinstance check."""
        policy = MockValidPolicy()
        assert isinstance(policy, ControlPolicy)

    def test_isinstance_check_learning_policy(self) -> None:
        """Learning policy should pass isinstance check."""
        policy = MockLearningPolicy()
        assert isinstance(policy, ControlPolicy)

    def test_missing_select_action_fails_isinstance(self) -> None:
        """Class without select_action should fail isinstance."""

        class BadPolicy:
            def update(self, request, action, reward) -> None:
                pass

        policy = BadPolicy()
        assert not isinstance(policy, ControlPolicy)

    def test_missing_update_fails_isinstance(self) -> None:
        """Class without update should fail isinstance."""

        class BadPolicy:
            def select_action(self, request, options, network_state) -> int:
                return 0

        policy = BadPolicy()
        assert not isinstance(policy, ControlPolicy)

    def test_wrong_method_signature_passes_isinstance(self) -> None:
        """
        Note: Protocol only checks method existence, not signature.
        Type checker catches signature issues at static analysis time.
        """

        class WeirdPolicy:
            def select_action(self) -> str:  # Wrong signature
                return "wrong"

            def update(self) -> None:  # Wrong signature
                pass

        policy = WeirdPolicy()
        # isinstance passes (only checks method names exist)
        assert isinstance(policy, ControlPolicy)
        # But calling with wrong args would fail at runtime

    def test_policy_action_type_alias(self) -> None:
        """PolicyAction type alias should be int."""
        action: PolicyAction = 0
        assert isinstance(action, int)
        action = -1
        assert isinstance(action, int)


class TestMockPolicyBehavior:
    """Test mock policy implementations for correct behavior."""

    def test_valid_policy_selects_feasible(self) -> None:
        """MockValidPolicy should select first feasible option."""
        from dataclasses import dataclass

        @dataclass
        class MockOption:
            path_index: int
            is_feasible: bool

        options = [
            MockOption(path_index=0, is_feasible=False),
            MockOption(path_index=1, is_feasible=True),
            MockOption(path_index=2, is_feasible=True),
        ]

        policy = MockValidPolicy()
        action = policy.select_action(None, options, None)
        assert action == 1  # First feasible

    def test_valid_policy_returns_negative_when_none_feasible(self) -> None:
        """Should return -1 when no options are feasible."""
        from dataclasses import dataclass

        @dataclass
        class MockOption:
            path_index: int
            is_feasible: bool

        options = [
            MockOption(path_index=0, is_feasible=False),
            MockOption(path_index=1, is_feasible=False),
        ]

        policy = MockValidPolicy()
        action = policy.select_action(None, options, None)
        assert action == -1

    def test_valid_policy_handles_empty_options(self) -> None:
        """Should return -1 for empty options list."""
        policy = MockValidPolicy()
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_update_is_called(self) -> None:
        """Update method should be callable."""
        policy = MockValidPolicy()
        assert not policy.update_called

        policy.update(None, 0, 1.0)

        assert policy.update_called
        assert policy.last_action == 0

    def test_learning_policy_tracks_experiences(self) -> None:
        """Learning policy should accumulate experiences."""
        policy = MockLearningPolicy()
        assert len(policy.experiences) == 0

        policy.update("req1", 0, 1.0)
        policy.update("req2", 1, -0.5)

        assert len(policy.experiences) == 2
        assert policy.experiences[0] == ("req1", 0, 1.0)
        assert policy.experiences[1] == ("req2", 1, -0.5)


class TestProtocolDocumentation:
    """Test that protocol has proper documentation."""

    def test_protocol_has_docstring(self) -> None:
        """ControlPolicy should have a docstring."""
        assert ControlPolicy.__doc__ is not None
        assert len(ControlPolicy.__doc__) > 100  # Substantial docstring

    def test_select_action_has_docstring(self) -> None:
        """select_action should have a docstring."""
        # Access through __protocol_attrs__ or directly
        assert "select_action" in dir(ControlPolicy)

    def test_update_has_docstring(self) -> None:
        """update should have a docstring."""
        assert "update" in dir(ControlPolicy)
```

### 4. Create `fusion/tests/rl/test_pathoption.py`

```python
"""
Tests for PathOption dataclass.

This module verifies:
1. PathOption creation and immutability
2. Protection field handling
3. Computed properties (both_paths_feasible, total_weight_km, etc.)
4. Validation in __post_init__
5. Factory methods
"""

from __future__ import annotations

import dataclasses

import pytest

from fusion.rl.adapter import PathOption, PathOptionList, PathSequence


class TestPathOptionBasic:
    """Test basic PathOption functionality."""

    def test_create_unprotected_pathoption(self) -> None:
        """Should create unprotected PathOption with defaults."""
        opt = PathOption(
            path_index=0,
            path=("A", "B", "C"),
            weight_km=100.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
        )

        assert opt.path_index == 0
        assert opt.path == ("A", "B", "C")
        assert opt.weight_km == 100.0
        assert opt.is_feasible is True
        assert opt.modulation == "QPSK"
        assert opt.slots_needed == 4
        assert opt.congestion == 0.3
        # Protection defaults
        assert opt.backup_path is None
        assert opt.backup_feasible is None
        assert opt.is_protected is False

    def test_frozen_immutable(self) -> None:
        """PathOption should be immutable (frozen)."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        )

        with pytest.raises(dataclasses.FrozenInstanceError):
            opt.is_feasible = False  # type: ignore

    def test_hashable(self) -> None:
        """Frozen PathOption should be hashable."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        )

        # Should not raise
        hash_value = hash(opt)
        assert isinstance(hash_value, int)

        # Can be used in set
        options_set = {opt}
        assert opt in options_set


class TestPathOptionValidation:
    """Test __post_init__ validation."""

    def test_reject_negative_path_index(self) -> None:
        """Should reject negative path_index."""
        with pytest.raises(ValueError, match="path_index must be >= 0"):
            PathOption(
                path_index=-1,
                path=("A", "B"),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=0.5,
            )

    def test_reject_empty_path(self) -> None:
        """Should reject empty path tuple."""
        with pytest.raises(ValueError, match="path must not be empty"):
            PathOption(
                path_index=0,
                path=(),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=0.5,
            )

    def test_reject_congestion_below_zero(self) -> None:
        """Should reject congestion < 0."""
        with pytest.raises(ValueError, match="congestion must be 0-1"):
            PathOption(
                path_index=0,
                path=("A", "B"),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=-0.1,
            )

    def test_reject_congestion_above_one(self) -> None:
        """Should reject congestion > 1."""
        with pytest.raises(ValueError, match="congestion must be 0-1"):
            PathOption(
                path_index=0,
                path=("A", "B"),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=1.5,
            )

    def test_accept_congestion_at_boundaries(self) -> None:
        """Should accept congestion exactly 0 and 1."""
        opt_zero = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.0,
        )
        assert opt_zero.congestion == 0.0

        opt_one = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=1.0,
        )
        assert opt_one.congestion == 1.0

    def test_protected_requires_backup_path(self) -> None:
        """is_protected=True requires backup_path."""
        with pytest.raises(ValueError, match="is_protected=True requires backup_path"):
            PathOption(
                path_index=0,
                path=("A", "B"),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=0.5,
                is_protected=True,
                backup_path=None,  # Missing!
                backup_feasible=True,
            )

    def test_protected_requires_backup_feasible(self) -> None:
        """is_protected=True requires backup_feasible."""
        with pytest.raises(ValueError, match="is_protected=True requires backup_feasible"):
            PathOption(
                path_index=0,
                path=("A", "B"),
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=0.5,
                is_protected=True,
                backup_path=("A", "C", "B"),
                backup_feasible=None,  # Missing!
            )


class TestPathOptionProtection:
    """Test protection-related functionality."""

    def test_both_paths_feasible_unprotected_feasible(self) -> None:
        """Unprotected feasible path: both_paths_feasible = is_feasible."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        )
        assert opt.both_paths_feasible is True

    def test_both_paths_feasible_unprotected_infeasible(self) -> None:
        """Unprotected infeasible path: both_paths_feasible = False."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=False,
            modulation=None,
            slots_needed=None,
            congestion=0.8,
        )
        assert opt.both_paths_feasible is False

    def test_both_paths_feasible_protected_both_true(self) -> None:
        """Protected with both feasible: both_paths_feasible = True."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
            backup_path=("A", "C", "B"),
            backup_feasible=True,
            backup_weight_km=80.0,
            backup_modulation="QPSK",
            is_protected=True,
        )
        assert opt.both_paths_feasible is True

    def test_both_paths_feasible_protected_primary_infeasible(self) -> None:
        """Protected with primary infeasible: both_paths_feasible = False."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=False,  # Primary infeasible
            modulation=None,
            slots_needed=None,
            congestion=0.3,
            backup_path=("A", "C", "B"),
            backup_feasible=True,
            backup_weight_km=80.0,
            backup_modulation="QPSK",
            is_protected=True,
        )
        assert opt.both_paths_feasible is False

    def test_both_paths_feasible_protected_backup_infeasible(self) -> None:
        """Protected with backup infeasible: both_paths_feasible = False."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
            backup_path=("A", "C", "B"),
            backup_feasible=False,  # Backup infeasible
            backup_weight_km=80.0,
            backup_modulation=None,
            is_protected=True,
        )
        assert opt.both_paths_feasible is False

    def test_total_weight_km_unprotected(self) -> None:
        """Unprotected: total_weight_km = weight_km."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        )
        assert opt.total_weight_km == 50.0

    def test_total_weight_km_protected(self) -> None:
        """Protected: total_weight_km = primary + backup."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
            backup_path=("A", "C", "B"),
            backup_feasible=True,
            backup_weight_km=80.0,
            backup_modulation="QPSK",
            is_protected=True,
        )
        assert opt.total_weight_km == 130.0

    def test_hop_count(self) -> None:
        """hop_count should be len(path) - 1."""
        opt = PathOption(
            path_index=0,
            path=("A", "B", "C", "D"),
            weight_km=100.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
        )
        assert opt.hop_count == 3

    def test_backup_hop_count_unprotected(self) -> None:
        """Unprotected: backup_hop_count = None."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        )
        assert opt.backup_hop_count is None

    def test_backup_hop_count_protected(self) -> None:
        """Protected: backup_hop_count = len(backup_path) - 1."""
        opt = PathOption(
            path_index=0,
            path=("A", "B"),
            weight_km=50.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
            backup_path=("A", "C", "D", "B"),
            backup_feasible=True,
            backup_weight_km=120.0,
            backup_modulation="QPSK",
            is_protected=True,
        )
        assert opt.backup_hop_count == 3


class TestPathOptionFactoryMethods:
    """Test factory class methods."""

    def test_from_unprotected_route(self) -> None:
        """from_unprotected_route should create correct PathOption."""
        opt = PathOption.from_unprotected_route(
            path_index=2,
            path=["A", "B", "C"],
            weight_km=75.0,
            is_feasible=True,
            modulation="16-QAM",
            slots_needed=8,
            congestion=0.4,
        )

        assert opt.path_index == 2
        assert opt.path == ("A", "B", "C")  # Converted to tuple
        assert opt.weight_km == 75.0
        assert opt.is_feasible is True
        assert opt.modulation == "16-QAM"
        assert opt.slots_needed == 8
        assert opt.congestion == 0.4
        assert opt.is_protected is False
        assert opt.backup_path is None

    def test_from_protected_route(self) -> None:
        """from_protected_route should create correct protected PathOption."""
        opt = PathOption.from_protected_route(
            path_index=1,
            primary_path=["A", "B", "C"],
            backup_path=["A", "D", "E", "C"],
            primary_weight=100.0,
            backup_weight=150.0,
            primary_feasible=True,
            backup_feasible=True,
            primary_modulation="QPSK",
            backup_modulation="8-QAM",
            slots_needed=4,
            congestion=0.25,
        )

        assert opt.path_index == 1
        assert opt.path == ("A", "B", "C")
        assert opt.weight_km == 100.0
        assert opt.is_feasible is True
        assert opt.modulation == "QPSK"
        assert opt.slots_needed == 4
        assert opt.congestion == 0.25
        assert opt.is_protected is True
        assert opt.backup_path == ("A", "D", "E", "C")
        assert opt.backup_feasible is True
        assert opt.backup_weight_km == 150.0
        assert opt.backup_modulation == "8-QAM"
        assert opt.both_paths_feasible is True
        assert opt.total_weight_km == 250.0


class TestTypeAliases:
    """Test type aliases work correctly."""

    def test_path_option_list_alias(self) -> None:
        """PathOptionList should be usable as list[PathOption]."""
        options: PathOptionList = [
            PathOption.from_unprotected_route(
                path_index=0,
                path=["A", "B"],
                weight_km=50.0,
                is_feasible=True,
                modulation="QPSK",
                slots_needed=4,
                congestion=0.3,
            ),
        ]
        assert len(options) == 1
        assert isinstance(options[0], PathOption)

    def test_path_sequence_alias(self) -> None:
        """PathSequence should be usable as tuple[str, ...]."""
        path: PathSequence = ("A", "B", "C")
        assert len(path) == 3
        assert all(isinstance(n, str) for n in path)
```

---

## Verification Commands

```bash
# Run all P5.1 tests
pytest fusion/tests/interfaces/test_control_policy.py -v
pytest fusion/tests/rl/test_pathoption.py -v

# Run with coverage
pytest fusion/tests/interfaces/test_control_policy.py \
       fusion/tests/rl/test_pathoption.py \
       --cov=fusion/interfaces/control_policy \
       --cov=fusion/rl/adapter \
       --cov-report=term-missing

# Type checking
mypy fusion/tests/interfaces/test_control_policy.py
mypy fusion/tests/rl/test_pathoption.py
```

---

## Coverage Requirements

| Module | Target | Notes |
|--------|--------|-------|
| `fusion/interfaces/control_policy.py` | 100% | Protocol definition |
| `fusion/rl/adapter.py` (PathOption) | 95% | All branches covered |

---

## Verification Checklist

- [ ] All test classes have meaningful docstrings
- [ ] Protocol isinstance checks tested (valid and invalid)
- [ ] PathOption creation tested (unprotected and protected)
- [ ] PathOption validation tested (all error cases)
- [ ] Protection properties tested (both_paths_feasible, total_weight_km)
- [ ] Factory methods tested
- [ ] Type aliases tested
- [ ] All tests pass
- [ ] Coverage meets targets

---

## Next Sub-Phase

After completing P5.1, proceed to **P5.2** (Heuristic Policies) to implement concrete policy classes.
