# Task ID: P5.3.c - Design Fallback Mechanism

**Sub-phase:** P5.3
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the fallback mechanism that ensures MLControlPolicy gracefully degrades to a heuristic policy when ML model inference fails.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.3_ml_policy_support/P5.3.b_design_ml_control_policy.md`
- `fusion/policies/heuristic_policy.py`
- `.claude/v4-docs/decisions/0011-ml-control-policy.md` (if exists)

---

## Outputs

### 1. Fallback Scenarios

| Scenario | Trigger | Fallback Action |
|----------|---------|-----------------|
| **Model load failure** | `__init__` raises exception | Raise immediately (fail fast) |
| **Inference error** | `_predict()` raises exception | Use fallback policy |
| **Invalid output** | Model returns wrong shape/type | Use fallback policy |
| **Invalid action** | Model selects infeasible path | Use fallback policy |
| **All paths infeasible** | No valid action exists | Return -1 (both policies) |

### 2. Fallback Flow Diagram

```
select_action(request, options, network_state)
    │
    ▼
┌─────────────────────────────────────┐
│ try:                                │
│   features = build_features(...)    │
│   output = predict(features)        │
│   action = apply_mask(output, ...)  │
│   if is_valid_action(action):       │
│       return action                 │
│   else:                             │
│       log warning                   │
│       ───► FALLBACK                 │
│ except Exception:                   │
│   log warning                       │
│   ───► FALLBACK                     │
└─────────────────────────────────────┘
         │
         ▼
    ┌─────────────────────────────────┐
    │ return fallback.select_action(  │
    │     request, options,           │
    │     network_state               │
    │ )                               │
    └─────────────────────────────────┘
```

### 3. Fallback Policy Configuration

```python
class MLControlPolicy:
    def __init__(
        self,
        model_path: str,
        fallback_policy: ControlPolicy | None = None,
        fallback_type: str = "first_feasible",
        **kwargs,
    ) -> None:
        """
        Initialize with configurable fallback.

        Args:
            model_path: Path to ML model
            fallback_policy: Explicit fallback policy instance
            fallback_type: Fallback type if policy not provided:
                - "first_feasible" (default)
                - "shortest_feasible"
                - "least_congested"
                - "random"

        Priority:
            1. Use fallback_policy if provided
            2. Create policy from fallback_type
        """
        # Resolve fallback
        if fallback_policy is not None:
            self.fallback = fallback_policy
        else:
            self.fallback = self._create_fallback(fallback_type)

    def _create_fallback(self, fallback_type: str) -> ControlPolicy:
        """Create fallback policy from type string."""
        from fusion.policies.heuristic_policy import (
            FirstFeasiblePolicy,
            ShortestFeasiblePolicy,
            LeastCongestedPolicy,
            RandomFeasiblePolicy,
        )

        fallback_map = {
            "first_feasible": FirstFeasiblePolicy,
            "shortest_feasible": ShortestFeasiblePolicy,
            "least_congested": LeastCongestedPolicy,
            "random": RandomFeasiblePolicy,
        }

        if fallback_type not in fallback_map:
            raise ValueError(
                f"Unknown fallback type: {fallback_type}. "
                f"Options: {list(fallback_map.keys())}"
            )

        return fallback_map[fallback_type]()
```

### 4. Error Handling Detail

```python
def select_action(
    self,
    request: Request,
    options: list[PathOption],
    network_state: NetworkState,
) -> int:
    """Select action with comprehensive error handling."""

    # Early return for empty options
    if not options:
        return -1

    try:
        # Step 1: Build features
        features = self._build_features(request, options, network_state)

        # Step 2: Run inference
        raw_output = self._predict(features)

        # Step 3: Validate output shape
        if not self._validate_output(raw_output, len(options)):
            logger.warning(
                f"Model output shape mismatch: expected {len(options)}, "
                f"got {raw_output.shape}"
            )
            return self._use_fallback(request, options, network_state)

        # Step 4: Apply mask and select
        action = self._apply_mask_and_select(raw_output, options)

        # Step 5: Validate action
        if self._is_valid_action(action, options):
            return action

        # Invalid action - log and fallback
        logger.warning(
            f"ML model selected invalid action {action} "
            f"(infeasible or out of range)"
        )
        return self._use_fallback(request, options, network_state)

    except ImportError as e:
        # Framework not installed
        logger.error(f"ML framework import error: {e}")
        return self._use_fallback(request, options, network_state)

    except RuntimeError as e:
        # Model execution error (shape mismatch, device error, etc.)
        logger.warning(f"Model runtime error: {e}")
        return self._use_fallback(request, options, network_state)

    except Exception as e:
        # Catch-all for unexpected errors
        logger.warning(f"Unexpected ML error: {e}")
        return self._use_fallback(request, options, network_state)


def _use_fallback(
    self,
    request: Request,
    options: list[PathOption],
    network_state: NetworkState,
) -> int:
    """Delegate to fallback policy."""
    return self.fallback.select_action(request, options, network_state)


def _validate_output(self, output: np.ndarray, expected_len: int) -> bool:
    """Check if model output is valid."""
    if output is None:
        return False

    if output.ndim == 0:
        # Scalar output - check if valid index
        return 0 <= int(output.item()) < expected_len

    if output.ndim == 1:
        # Vector output - check length
        return len(output) >= expected_len or len(output) > 0

    # Multi-dimensional - unexpected
    return False
```

### 5. Fallback Statistics Tracking

```python
class MLControlPolicy:
    """ML policy with fallback tracking."""

    def __init__(self, ...):
        # ... initialization ...

        # Fallback statistics
        self._total_calls = 0
        self._fallback_calls = 0
        self._error_types: dict[str, int] = {}

    def select_action(self, request, options, network_state) -> int:
        self._total_calls += 1
        # ... try/except with fallback tracking ...

    def _use_fallback(self, request, options, network_state, reason: str = "unknown") -> int:
        """Use fallback and track statistics."""
        self._fallback_calls += 1
        self._error_types[reason] = self._error_types.get(reason, 0) + 1
        return self.fallback.select_action(request, options, network_state)

    @property
    def fallback_rate(self) -> float:
        """Percentage of calls that used fallback."""
        if self._total_calls == 0:
            return 0.0
        return self._fallback_calls / self._total_calls

    def get_stats(self) -> dict[str, Any]:
        """Get fallback statistics."""
        return {
            "total_calls": self._total_calls,
            "fallback_calls": self._fallback_calls,
            "fallback_rate": self.fallback_rate,
            "error_types": self._error_types.copy(),
        }

    def reset_stats(self) -> None:
        """Reset fallback statistics."""
        self._total_calls = 0
        self._fallback_calls = 0
        self._error_types.clear()
```

### 6. Configuration Integration

```ini
# In config file
[policy]
type = ml
model_path = models/bc_policy.pt
device = cpu
fallback_type = first_feasible
```

```python
# In PolicyFactory (P5.5)
def create_ml_policy(config: SimulationConfig) -> MLControlPolicy:
    return MLControlPolicy(
        model_path=config.policy_model_path,
        device=config.policy_device,
        fallback_type=config.policy_fallback_type,
    )
```

---

## Verification

- [ ] Fallback triggered on inference errors
- [ ] Fallback triggered on invalid model output
- [ ] Fallback triggered on infeasible action selection
- [ ] Configurable fallback policy type
- [ ] Statistics tracking implemented
- [ ] Comprehensive logging for debugging
- [ ] Error types categorized appropriately

---

## Test Cases to Implement

```python
class TestMLPolicyFallback:
    """Tests for MLControlPolicy fallback mechanism."""

    def test_fallback_on_inference_error(self) -> None:
        """Should use fallback when model raises during inference."""
        # Create policy with mock model that raises
        policy = create_policy_with_failing_model()

        options = create_test_options()
        action = policy.select_action(None, options, None)

        # Should get valid action from fallback
        assert action >= 0
        assert options[action].is_feasible

    def test_fallback_on_invalid_action(self) -> None:
        """Should use fallback when model returns infeasible action."""
        # Create policy with mock model returning infeasible index
        policy = create_policy_returning_infeasible()

        options = [
            PathOption(..., is_feasible=False),  # Index 0
            PathOption(..., is_feasible=True),   # Index 1
        ]
        # Mock model returns 0 (infeasible)
        action = policy.select_action(None, options, None)

        # Should get index 1 from fallback
        assert action == 1

    def test_fallback_rate_tracking(self) -> None:
        """Should track fallback usage statistics."""
        policy = MLControlPolicy("model.pt")

        # Simulate some successful and some fallback calls
        # ...

        stats = policy.get_stats()
        assert stats["fallback_rate"] == expected_rate

    def test_custom_fallback_policy(self) -> None:
        """Should use custom fallback if provided."""
        custom_fallback = ShortestFeasiblePolicy()
        policy = MLControlPolicy(
            "model.pt",
            fallback_policy=custom_fallback,
        )

        assert policy.fallback is custom_fallback

    def test_fallback_type_configuration(self) -> None:
        """Should create fallback from type string."""
        policy = MLControlPolicy(
            "model.pt",
            fallback_type="least_congested",
        )

        assert isinstance(policy.fallback, LeastCongestedPolicy)
```

---

## Next Task

Proceed to **P5.3.d** to design the feature engineering in detail.
