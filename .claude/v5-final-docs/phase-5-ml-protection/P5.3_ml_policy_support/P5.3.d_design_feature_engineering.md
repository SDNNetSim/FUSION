# Task ID: P5.3.d - Design Feature Engineering

**Sub-phase:** P5.3
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the feature engineering pipeline that converts Request, PathOption, and NetworkState into a feature vector compatible with pre-trained ML models.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.3_ml_policy_support/P5.3.shared_context_model_formats.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.3_ml_policy_support/P5.3.b_design_ml_control_policy.md`
- `fusion/rl/adapter.py` (PathOption)
- `fusion/domain/request.py` (Request)

---

## Outputs

### 1. Feature Vector Specification

The feature vector must match the observation space used during RL training:

| Feature Group | Features | Count |
|---------------|----------|-------|
| Request features | bandwidth | 1 |
| Path features | weight, congestion, feasible, slots | 4 x K |
| **Total** | | 1 + 4K |

For K=5 paths: **21 features**

### 2. Feature Definitions

#### Request-Level Features

| Index | Name | Source | Normalization | Range |
|-------|------|--------|---------------|-------|
| 0 | `bandwidth` | `request.bandwidth_gbps` | / 1000.0 | [0, 1] |

#### Per-Path Features (Repeated K Times)

| Offset | Name | Source | Normalization | Range |
|--------|------|--------|---------------|-------|
| 0 | `weight` | `opt.weight_km` | / 10000.0 | [0, 1+] |
| 1 | `congestion` | `opt.congestion` | None | [0, 1] |
| 2 | `feasible` | `opt.is_feasible` | bool -> float | {0, 1} |
| 3 | `slots` | `opt.slots_needed` | / 100.0 | [0, 1+] |

### 3. Feature Builder Implementation

```python
"""Feature engineering for MLControlPolicy."""

from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.rl.adapter import PathOption


class FeatureBuilder:
    """
    Build feature vectors for ML model inference.

    Creates fixed-size feature vectors from Request and PathOption
    inputs, with padding for variable numbers of paths.

    The feature layout matches the RL training observation space,
    ensuring model compatibility.

    Attributes:
        k_paths: Expected number of paths (for padding)
        features_per_path: Number of features extracted per path

    Example:
        >>> builder = FeatureBuilder(k_paths=5)
        >>> features = builder.build(request, options, network_state)
        >>> features.shape
        (21,)  # 1 + 5*4
    """

    FEATURES_PER_PATH = 4

    # Normalization constants
    MAX_BANDWIDTH_GBPS = 1000.0
    MAX_WEIGHT_KM = 10000.0
    MAX_SLOTS = 100.0

    def __init__(self, k_paths: int = 5) -> None:
        """
        Initialize feature builder.

        Args:
            k_paths: Expected number of path options
        """
        self.k_paths = k_paths
        self._feature_size = 1 + k_paths * self.FEATURES_PER_PATH

    @property
    def feature_size(self) -> int:
        """Total size of feature vector."""
        return self._feature_size

    def build(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> np.ndarray:
        """
        Build feature vector from inputs.

        Args:
            request: The request being processed
            options: Available path options
            network_state: Current network state (for future extensions)

        Returns:
            Feature vector of shape (feature_size,)
        """
        features = []

        # Request-level features
        features.append(self._normalize_bandwidth(request.bandwidth_gbps))

        # Per-path features
        for i in range(self.k_paths):
            if i < len(options):
                features.extend(self._extract_path_features(options[i]))
            else:
                features.extend(self._get_padding_features())

        return np.array(features, dtype=np.float32)

    def _normalize_bandwidth(self, bandwidth_gbps: float) -> float:
        """Normalize bandwidth to [0, 1] range."""
        return bandwidth_gbps / self.MAX_BANDWIDTH_GBPS

    def _extract_path_features(self, opt: PathOption) -> list[float]:
        """Extract features from a single path option."""
        return [
            opt.weight_km / self.MAX_WEIGHT_KM,
            opt.congestion,
            1.0 if opt.is_feasible else 0.0,
            (opt.slots_needed or 0) / self.MAX_SLOTS,
        ]

    def _get_padding_features(self) -> list[float]:
        """
        Get padding features for missing paths.

        Padding values chosen to represent "worst case" path:
        - weight: 0.0 (no path)
        - congestion: 1.0 (fully congested)
        - feasible: 0.0 (not available)
        - slots: 0.0 (not needed)
        """
        return [0.0, 1.0, 0.0, 0.0]

    def build_batch(
        self,
        requests: list[Request],
        options_batch: list[list[PathOption]],
        network_states: list[NetworkState],
    ) -> np.ndarray:
        """
        Build feature matrix for batch inference.

        Args:
            requests: List of requests
            options_batch: List of option lists (one per request)
            network_states: List of network states

        Returns:
            Feature matrix of shape (batch_size, feature_size)
        """
        batch = [
            self.build(req, opts, ns)
            for req, opts, ns in zip(requests, options_batch, network_states)
        ]
        return np.stack(batch)
```

### 4. Feature Documentation

```python
# Feature vector layout for K=5 paths
FEATURE_LAYOUT = {
    0: ("bandwidth", "Request bandwidth (normalized by 1000 Gbps)"),
    # Path 0
    1: ("path_0_weight", "Path 0 length (normalized by 10000 km)"),
    2: ("path_0_congestion", "Path 0 congestion (0-1)"),
    3: ("path_0_feasible", "Path 0 feasibility (0 or 1)"),
    4: ("path_0_slots", "Path 0 slots needed (normalized by 100)"),
    # Path 1
    5: ("path_1_weight", "Path 1 length"),
    6: ("path_1_congestion", "Path 1 congestion"),
    7: ("path_1_feasible", "Path 1 feasibility"),
    8: ("path_1_slots", "Path 1 slots needed"),
    # Path 2
    9: ("path_2_weight", "Path 2 length"),
    10: ("path_2_congestion", "Path 2 congestion"),
    11: ("path_2_feasible", "Path 2 feasibility"),
    12: ("path_2_slots", "Path 2 slots needed"),
    # Path 3
    13: ("path_3_weight", "Path 3 length"),
    14: ("path_3_congestion", "Path 3 congestion"),
    15: ("path_3_feasible", "Path 3 feasibility"),
    16: ("path_3_slots", "Path 3 slots needed"),
    # Path 4
    17: ("path_4_weight", "Path 4 length"),
    18: ("path_4_congestion", "Path 4 congestion"),
    19: ("path_4_feasible", "Path 4 feasibility"),
    20: ("path_4_slots", "Path 4 slots needed"),
}
```

### 5. Integration with MLControlPolicy

```python
class MLControlPolicy:
    """ML policy using FeatureBuilder."""

    def __init__(self, model_path: str, k_paths: int = 5, **kwargs):
        # ... model loading ...
        self._feature_builder = FeatureBuilder(k_paths=k_paths)

    def _build_features(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> np.ndarray:
        """Build features using FeatureBuilder."""
        return self._feature_builder.build(request, options, network_state)
```

### 6. Extended Features (Future)

For more advanced models, additional features can be added:

```python
class ExtendedFeatureBuilder(FeatureBuilder):
    """Extended features including network state."""

    FEATURES_PER_PATH = 6  # Additional: hop_count, protection_feasible

    def _extract_path_features(self, opt: PathOption) -> list[float]:
        """Extract extended features."""
        base = super()._extract_path_features(opt)
        extended = [
            opt.hop_count / 10.0,  # Normalized hop count
            1.0 if opt.both_paths_feasible else 0.0,  # Protection OK
        ]
        return base + extended

    def _get_padding_features(self) -> list[float]:
        return super()._get_padding_features() + [0.0, 0.0]
```

---

## Verification

- [ ] Feature size matches k_paths configuration
- [ ] All features normalized to reasonable ranges
- [ ] Padding applied for fewer than k_paths options
- [ ] Feature layout matches RL training
- [ ] Batch building works correctly
- [ ] Features are float32 dtype

---

## Test Cases to Implement

```python
class TestFeatureBuilder:
    """Tests for FeatureBuilder."""

    def test_feature_size(self) -> None:
        """Feature size should match 1 + 4*k_paths."""
        builder = FeatureBuilder(k_paths=5)
        assert builder.feature_size == 21

        builder = FeatureBuilder(k_paths=3)
        assert builder.feature_size == 13

    def test_build_with_all_paths(self) -> None:
        """Should build correct features with full path list."""
        builder = FeatureBuilder(k_paths=3)
        request = MockRequest(bandwidth_gbps=100.0)
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 500.0, True, "QPSK", 4, 0.3),
            PathOption.from_unprotected_route(1, ["A", "C"], 800.0, False, None, None, 0.7),
            PathOption.from_unprotected_route(2, ["A", "D"], 600.0, True, "QPSK", 8, 0.5),
        ]

        features = builder.build(request, options, None)

        assert features.shape == (13,)
        assert features[0] == 0.1  # 100/1000
        assert features[1] == 0.05  # 500/10000
        assert features[2] == 0.3  # congestion
        assert features[3] == 1.0  # feasible
        assert features[4] == 0.04  # 4/100

    def test_build_with_padding(self) -> None:
        """Should pad missing paths correctly."""
        builder = FeatureBuilder(k_paths=3)
        request = MockRequest(bandwidth_gbps=100.0)
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 500.0, True, "QPSK", 4, 0.3),
        ]

        features = builder.build(request, options, None)

        # Path 1 and 2 should be padded
        assert features[5] == 0.0  # path_1_weight padding
        assert features[6] == 1.0  # path_1_congestion padding
        assert features[7] == 0.0  # path_1_feasible padding
        assert features[8] == 0.0  # path_1_slots padding

    def test_build_empty_options(self) -> None:
        """Should handle empty options with all padding."""
        builder = FeatureBuilder(k_paths=2)
        request = MockRequest(bandwidth_gbps=50.0)

        features = builder.build(request, [], None)

        assert features.shape == (9,)  # 1 + 2*4
        assert features[0] == 0.05  # bandwidth
        # All path features should be padding
        assert features[3] == 0.0  # path_0_feasible (padding)

    def test_dtype_is_float32(self) -> None:
        """Features should be float32."""
        builder = FeatureBuilder(k_paths=3)
        features = builder.build(MockRequest(100.0), [], None)
        assert features.dtype == np.float32

    def test_batch_build(self) -> None:
        """Should build correct batch of features."""
        builder = FeatureBuilder(k_paths=2)

        batch_features = builder.build_batch(
            [MockRequest(100.0), MockRequest(200.0)],
            [[], []],
            [None, None],
        )

        assert batch_features.shape == (2, 9)
        assert batch_features[0, 0] == 0.1
        assert batch_features[1, 0] == 0.2
```

---

## Next Task

Proceed to **P5.3.e** to implement the complete MLControlPolicy.
