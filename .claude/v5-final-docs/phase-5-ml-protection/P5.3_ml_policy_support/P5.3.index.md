# P5.3 Index - ML Policy Support

**Phase:** 5 - ML Control + Protection Integration
**Sub-phase:** P5.3
**Status:** Not Started

---

## Goals

Enable deployment of pre-trained ML models for path selection:
1. Support multiple ML frameworks (PyTorch, sklearn, ONNX)
2. Provide robust fallback when models fail
3. Implement action masking for feasibility constraints
4. Design feature engineering compatible with RL observations

---

## Key Deliverables

| # | Deliverable | Description |
|---|-------------|-------------|
| 1 | `fusion/policies/ml_policy.py` | MLControlPolicy class |
| 2 | Model loading utilities | Framework-specific loaders |
| 3 | Feature engineering | Consistent feature vector construction |
| 4 | Fallback mechanism | Graceful degradation to heuristics |

---

## Supported Model Types

| Framework | File Extensions | Inference Method |
|-----------|----------------|------------------|
| PyTorch | `.pt`, `.pth` | `model(tensor)` |
| scikit-learn | `.joblib`, `.pkl` | `model.predict_proba()` |
| ONNX | `.onnx` | `session.run()` |

---

## Constraints

1. **Deployment only** - No online training in ML policies (use RL for that)
2. **update() is no-op** - Pre-trained models don't learn during simulation
3. **Fallback required** - Must gracefully degrade when model fails
4. **Feasibility respected** - Action masking enforces is_feasible constraint
5. **Deterministic inference** - Same input produces same output (no sampling)

---

## Dependencies

### From P5.1
- `ControlPolicy` protocol from `fusion/interfaces/control_policy.py`
- `PathOption` dataclass from `fusion/rl/adapter.py`

### From P5.2
- `FirstFeasiblePolicy` for default fallback

### External
- `torch` (optional, for PyTorch models)
- `numpy` (required)
- `joblib` (optional, for sklearn models)
- `onnxruntime` (optional, for ONNX models)

---

## Micro-Tasks

| ID | File | Type | Description |
|----|------|------|-------------|
| P5.3.a | `P5.3.a_context_extraction_ml_patterns.md` | context-extraction | Extract existing ML policy patterns |
| P5.3.b | `P5.3.b_design_ml_control_policy.md` | design | Design MLControlPolicy class |
| P5.3.c | `P5.3.c_design_fallback_mechanism.md` | design | Design graceful degradation |
| P5.3.d | `P5.3.d_design_feature_engineering.md` | design | Design feature vector construction |
| P5.3.e | `P5.3.e_implement_ml_policy.md` | wiring-plan | Implement MLControlPolicy |
| P5.3.f | `P5.3.f_verification_plan.md` | verification-plan | Tests for ML policy |

---

## Shared Context Files

| File | Purpose |
|------|---------|
| `P5.3.shared_context_model_formats.md` | Model loading patterns and feature formats |

---

## Feature Vector Format

The feature vector must match the RL observation space for model compatibility:

```python
# Per-request features
features = [
    request.bandwidth_gbps / 1000.0,  # Normalized bandwidth
]

# Per-path features (repeated for each of K paths)
for opt in options:
    features.extend([
        opt.weight_km / 10000.0,           # Normalized length
        opt.congestion,                     # Already 0-1
        1.0 if opt.is_feasible else 0.0,   # Feasibility flag
        (opt.slots_needed or 0) / 100.0,   # Normalized slots
    ])
```

---

## MLControlPolicy Interface

```python
class MLControlPolicy(ControlPolicy):
    def __init__(
        self,
        model_path: str,
        device: str = "cpu",
        model_type: str = "pytorch",
        fallback_policy: ControlPolicy | None = None,
    ) -> None:
        ...

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select action using ML model with fallback."""
        ...

    def update(self, request: Request, action: int, reward: float) -> None:
        """No-op - pre-trained models don't learn online."""
        pass
```

---

## Exit Criteria

- [ ] MLControlPolicy supports PyTorch, sklearn, ONNX models
- [ ] Fallback to heuristic policy on model failure
- [ ] Feature engineering matches RL observation space
- [ ] Action masking enforces feasibility constraints
- [ ] Model errors are caught and logged
- [ ] Unit tests with mock models achieve >= 90% coverage
- [ ] MLControlPolicy exported from `fusion/policies/__init__.py`

---

## Next Sub-Phase

After completing P5.3, proceed to:
- **P5.4** (Protection Pipeline) - Can run in parallel if P5.3 started first
- **P5.5** (Orchestrator Integration) - After P5.4 complete
