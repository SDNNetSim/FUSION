# Task ID: P5.2.c - Design First/Shortest Policies

**Sub-phase:** P5.2
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design `FirstFeasiblePolicy` and `ShortestFeasiblePolicy` - the two simplest heuristic policies for path selection.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.b_design_heuristic_base.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.shared_context_selection_logic.md`
- `fusion/rl/adapter.py` (PathOption)

---

## Outputs

### 1. FirstFeasiblePolicy

```python
class FirstFeasiblePolicy(HeuristicPolicy):
    """
    Select the first feasible path in index order.

    This is the simplest path selection heuristic. It iterates through
    the options list and returns the first path where is_feasible=True.

    This policy relies on the routing pipeline to provide paths in a
    meaningful order (e.g., sorted by length). It's equivalent to
    "K-Shortest Path First Fit" when paths are pre-sorted.

    Selection Logic:
        1. Iterate through options in index order
        2. Return first option where is_feasible=True
        3. Return -1 if no feasible option exists

    Time Complexity: O(n) worst case, O(1) best case
    Space Complexity: O(1)

    Example:
        >>> policy = FirstFeasiblePolicy()
        >>> options = [
        ...     PathOption(..., is_feasible=False),  # Index 0: blocked
        ...     PathOption(..., is_feasible=True),   # Index 1: available
        ...     PathOption(..., is_feasible=True),   # Index 2: available
        ... ]
        >>> policy.select_action(request, options, network_state)
        1  # Returns first feasible (index 1)
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select the first feasible path.

        Args:
            request: The incoming request (not used by this policy)
            options: List of path options to choose from
            network_state: Current network state (not used by this policy)

        Returns:
            Index of first feasible path, or -1 if none feasible
        """
        for opt in options:
            if opt.is_feasible:
                return opt.path_index
        return -1
```

### 2. ShortestFeasiblePolicy

```python
class ShortestFeasiblePolicy(HeuristicPolicy):
    """
    Select the shortest feasible path by distance.

    This policy finds all feasible paths and selects the one with the
    minimum weight_km (path length in kilometers).

    Unlike FirstFeasiblePolicy, this doesn't rely on pre-sorting and
    always finds the globally shortest feasible path.

    Selection Logic:
        1. Filter to feasible options
        2. Find option with minimum weight_km
        3. Return its path_index, or -1 if none feasible

    Tie Breaking:
        When multiple paths have the same weight_km, the first one
        encountered (lowest index) is selected.

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list

    Example:
        >>> policy = ShortestFeasiblePolicy()
        >>> options = [
        ...     PathOption(..., weight_km=150.0, is_feasible=True),   # Index 0
        ...     PathOption(..., weight_km=100.0, is_feasible=False),  # Index 1: blocked
        ...     PathOption(..., weight_km=120.0, is_feasible=True),   # Index 2
        ... ]
        >>> policy.select_action(request, options, network_state)
        2  # Returns shortest feasible (120 km at index 2)
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select the shortest feasible path by weight_km.

        Args:
            request: The incoming request (not used by this policy)
            options: List of path options to choose from
            network_state: Current network state (not used by this policy)

        Returns:
            Index of shortest feasible path, or -1 if none feasible
        """
        # Filter to feasible options
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        # Find minimum weight_km
        shortest = min(feasible, key=lambda opt: opt.weight_km)
        return shortest.path_index
```

### 3. Design Comparison

| Aspect | FirstFeasiblePolicy | ShortestFeasiblePolicy |
|--------|---------------------|------------------------|
| **Strategy** | Order-based | Optimization-based |
| **Uses request** | No | No |
| **Uses network_state** | No | No |
| **Metric** | None (index order) | weight_km |
| **Pre-sorting required** | Yes (for optimal results) | No |
| **Time complexity** | O(1) to O(n) | O(n) |
| **Space complexity** | O(1) | O(n) |
| **Deterministic** | Yes | Yes |
| **Tie-breaking** | N/A (first match) | First occurrence |

### 4. Edge Case Handling

Both policies handle edge cases identically:

```python
# Empty options list
>>> policy.select_action(request, [], network_state)
-1

# All options infeasible
>>> options = [
...     PathOption(..., is_feasible=False),
...     PathOption(..., is_feasible=False),
... ]
>>> policy.select_action(request, options, network_state)
-1

# Single feasible option
>>> options = [PathOption(..., is_feasible=True)]
>>> policy.select_action(request, options, network_state)
0

# Single infeasible option
>>> options = [PathOption(..., is_feasible=False)]
>>> policy.select_action(request, options, network_state)
-1
```

### 5. Usage Examples

```python
from fusion.policies.heuristic_policy import FirstFeasiblePolicy, ShortestFeasiblePolicy

# Create policies
first_fit = FirstFeasiblePolicy()
shortest = ShortestFeasiblePolicy()

# Create sample options
options = [
    PathOption.from_unprotected_route(
        path_index=0,
        path=["A", "B", "C"],
        weight_km=150.0,
        is_feasible=True,
        modulation="QPSK",
        slots_needed=4,
        congestion=0.3,
    ),
    PathOption.from_unprotected_route(
        path_index=1,
        path=["A", "D", "C"],
        weight_km=100.0,
        is_feasible=False,  # Blocked
        modulation=None,
        slots_needed=None,
        congestion=0.9,
    ),
    PathOption.from_unprotected_route(
        path_index=2,
        path=["A", "E", "F", "C"],
        weight_km=120.0,
        is_feasible=True,
        modulation="QPSK",
        slots_needed=4,
        congestion=0.5,
    ),
]

# FirstFeasiblePolicy: returns index 0 (first feasible)
action1 = first_fit.select_action(request, options, network_state)
assert action1 == 0

# ShortestFeasiblePolicy: returns index 2 (shortest feasible at 120 km)
action2 = shortest.select_action(request, options, network_state)
assert action2 == 2
```

---

## Verification

- [ ] FirstFeasiblePolicy returns first is_feasible=True option
- [ ] ShortestFeasiblePolicy returns minimum weight_km among feasible
- [ ] Both return -1 for empty options
- [ ] Both return -1 when all options infeasible
- [ ] Both handle single-option cases
- [ ] Both have comprehensive docstrings
- [ ] Both satisfy ControlPolicy protocol

---

## Test Cases to Implement

```python
# In fusion/tests/policies/test_heuristic_policy.py

class TestFirstFeasiblePolicy:
    """Tests for FirstFeasiblePolicy."""

    def test_selects_first_feasible(self) -> None:
        """Should select first feasible option."""
        policy = FirstFeasiblePolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, False, None, None, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 150, True, "QPSK", 4, 0.3),
            PathOption.from_unprotected_route(2, ["A", "D"], 200, True, "QPSK", 4, 0.2),
        ]
        action = policy.select_action(None, options, None)
        assert action == 1

    def test_returns_negative_one_when_empty(self) -> None:
        """Should return -1 for empty options."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_returns_negative_one_when_all_infeasible(self) -> None:
        """Should return -1 when all options infeasible."""
        policy = FirstFeasiblePolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, False, None, None, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 150, False, None, None, 0.3),
        ]
        action = policy.select_action(None, options, None)
        assert action == -1

    def test_returns_zero_when_first_is_feasible(self) -> None:
        """Should return 0 when first option is feasible."""
        policy = FirstFeasiblePolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, True, "QPSK", 4, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 50, True, "QPSK", 4, 0.3),
        ]
        action = policy.select_action(None, options, None)
        assert action == 0  # First, not shortest


class TestShortestFeasiblePolicy:
    """Tests for ShortestFeasiblePolicy."""

    def test_selects_shortest_feasible(self) -> None:
        """Should select shortest feasible option by weight_km."""
        policy = ShortestFeasiblePolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 150, True, "QPSK", 4, 0.3),
            PathOption.from_unprotected_route(1, ["A", "C"], 100, False, None, None, 0.5),
            PathOption.from_unprotected_route(2, ["A", "D"], 120, True, "QPSK", 4, 0.2),
        ]
        action = policy.select_action(None, options, None)
        assert action == 2  # Shortest feasible (120 km)

    def test_returns_negative_one_when_empty(self) -> None:
        """Should return -1 for empty options."""
        policy = ShortestFeasiblePolicy()
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_returns_negative_one_when_all_infeasible(self) -> None:
        """Should return -1 when all options infeasible."""
        policy = ShortestFeasiblePolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, False, None, None, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 150, False, None, None, 0.3),
        ]
        action = policy.select_action(None, options, None)
        assert action == -1

    def test_ignores_shorter_infeasible_path(self) -> None:
        """Should ignore shorter paths that are infeasible."""
        policy = ShortestFeasiblePolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, False, None, None, 0.5),  # Shorter but blocked
            PathOption.from_unprotected_route(1, ["A", "C"], 200, True, "QPSK", 4, 0.3),
        ]
        action = policy.select_action(None, options, None)
        assert action == 1  # Only feasible option

    def test_tie_breaking_first_occurrence(self) -> None:
        """When tied on weight_km, should select first occurrence."""
        policy = ShortestFeasiblePolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, True, "QPSK", 4, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 100, True, "QPSK", 4, 0.3),  # Same weight
        ]
        action = policy.select_action(None, options, None)
        assert action == 0  # First with minimum weight
```

---

## Next Task

Proceed to **P5.2.d** to design LeastCongestedPolicy, RandomFeasiblePolicy, and LoadBalancedPolicy.
