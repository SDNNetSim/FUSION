# Task ID: P5.2.e - Implement Heuristic Policies

**Sub-phase:** P5.2
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** wiring-plan

---

## Purpose

Implement the complete `fusion/policies/heuristic_policy.py` file containing all heuristic policies designed in P5.2.b, P5.2.c, and P5.2.d.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.b_design_heuristic_base.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.c_design_first_shortest_policies.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.d_design_congestion_policies.md`

---

## Outputs

### 1. Create `fusion/policies/heuristic_policy.py`

```python
"""
Heuristic policies for path selection.

This module provides deterministic, rule-based path selection strategies
implementing the ControlPolicy protocol. Available policies:

- FirstFeasiblePolicy: Select first feasible path (K-shortest first fit)
- ShortestFeasiblePolicy: Select shortest feasible path by distance
- LeastCongestedPolicy: Select least congested feasible path
- RandomFeasiblePolicy: Randomly select among feasible paths
- LoadBalancedPolicy: Balance path length and congestion

All policies implement the ControlPolicy protocol but do not learn
from experience (update() is a no-op).

Example:
    >>> from fusion.policies.heuristic_policy import ShortestFeasiblePolicy
    >>> policy = ShortestFeasiblePolicy()
    >>> action = policy.select_action(request, options, network_state)

Note:
    Heuristic policies are typically used as:
    - Default selection strategies
    - Baselines for RL/ML comparison
    - Fallback when ML models fail
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.rl.adapter import PathOption


class HeuristicPolicy(ABC):
    """
    Abstract base class for heuristic path selection policies.

    Heuristic policies are deterministic (except RandomFeasiblePolicy),
    rule-based strategies that select paths without learning. They serve as:

    1. Default selection strategies
    2. Baselines for RL/ML comparison
    3. Fallback policies when ML models fail

    All subclasses must implement select_action(). The update() method
    is a no-op since heuristics don't learn.

    This class implements the ControlPolicy protocol.
    """

    @abstractmethod
    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select an action (path index) based on heuristic rule.

        Args:
            request: The incoming request (may be used for context)
            options: List of available PathOptions
            network_state: Current network state (read-only)

        Returns:
            Selected path index (0 to len(options)-1), or -1 if none valid
        """
        ...

    def update(self, request: Request, action: int, reward: float) -> None:
        """
        Update policy based on experience.

        Heuristic policies do not learn, so this is a no-op.

        Args:
            request: The request that was served (ignored)
            action: The action taken (ignored)
            reward: The reward received (ignored)
        """
        pass

    def get_name(self) -> str:
        """Return the policy name for logging."""
        return self.__class__.__name__

    def _get_feasible_options(
        self,
        options: list[PathOption],
    ) -> list[PathOption]:
        """Filter options to only feasible ones."""
        return [opt for opt in options if opt.is_feasible]

    def _get_selectable_options(
        self,
        options: list[PathOption],
    ) -> list[PathOption]:
        """
        Filter options to selectable ones (protection-aware).

        For protected paths, checks both_paths_feasible.
        For unprotected paths, checks is_feasible.
        """
        result = []
        for opt in options:
            if opt.is_protected:
                if opt.both_paths_feasible:
                    result.append(opt)
            else:
                if opt.is_feasible:
                    result.append(opt)
        return result


class FirstFeasiblePolicy(HeuristicPolicy):
    """
    Select the first feasible path in index order.

    This is the simplest heuristic. It iterates through options and
    returns the first path where is_feasible=True. Equivalent to
    "K-Shortest Path First Fit" when paths are pre-sorted by length.

    Selection Logic:
        1. Iterate through options in index order
        2. Return first option where is_feasible=True
        3. Return -1 if no feasible option exists

    Time Complexity: O(n) worst case, O(1) best case
    Space Complexity: O(1)
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select the first feasible path."""
        for opt in options:
            if opt.is_feasible:
                return opt.path_index
        return -1


class ShortestFeasiblePolicy(HeuristicPolicy):
    """
    Select the shortest feasible path by distance.

    Finds all feasible paths and selects the one with minimum
    weight_km (path length in kilometers).

    Selection Logic:
        1. Filter to feasible options
        2. Find option with minimum weight_km
        3. Return its path_index, or -1 if none feasible

    Tie Breaking: First occurrence when tied on weight_km.

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select the shortest feasible path by weight_km."""
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        shortest = min(feasible, key=lambda opt: opt.weight_km)
        return shortest.path_index


class LeastCongestedPolicy(HeuristicPolicy):
    """
    Select the least congested feasible path.

    Prioritizes paths with lower congestion values to distribute
    load across the network and reduce fragmentation.

    Selection Logic:
        1. Filter to feasible options
        2. Find option with minimum congestion (0.0 to 1.0)
        3. Return its path_index, or -1 if none feasible

    Tie Breaking: First occurrence when tied on congestion.

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select the least congested feasible path."""
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        least_congested = min(feasible, key=lambda opt: opt.congestion)
        return least_congested.path_index


class RandomFeasiblePolicy(HeuristicPolicy):
    """
    Randomly select among feasible paths.

    Uniformly samples from all feasible paths. Useful for:
    - Exploration during training
    - Baseline comparison (random performance)
    - Load distribution across multiple paths

    Uses numpy's random number generator with optional seed.

    Selection Logic:
        1. Filter to feasible options
        2. Uniformly sample one option
        3. Return its path_index, or -1 if none feasible

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list

    Attributes:
        _rng: Numpy random generator
        _seed: Original seed for reset
    """

    def __init__(self, seed: int | None = None) -> None:
        """
        Initialize with optional random seed.

        Args:
            seed: Random seed for reproducibility. If None, uses
                  system entropy (non-reproducible).
        """
        self._rng = np.random.default_rng(seed)
        self._seed = seed

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Randomly select a feasible path."""
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        selected = self._rng.choice(feasible)
        return selected.path_index

    def reset_rng(self, seed: int | None = None) -> None:
        """
        Reset the random number generator.

        Args:
            seed: New seed. If None, uses the original seed.
        """
        if seed is None:
            seed = self._seed
        self._rng = np.random.default_rng(seed)


class LoadBalancedPolicy(HeuristicPolicy):
    """
    Select path balancing length and congestion.

    Combines path length (weight_km) and congestion into a weighted score:

        score = alpha * normalized_length + (1 - alpha) * congestion

    Where normalized_length = weight_km / max_weight_km among feasible paths.

    Alpha Parameter:
        - 0.0: Pure congestion-based (same as LeastCongestedPolicy)
        - 0.5: Equal weight to length and congestion (default)
        - 1.0: Pure length-based (same as ShortestFeasiblePolicy)

    Selection Logic:
        1. Filter to feasible options
        2. Normalize weight_km to [0, 1] range
        3. Compute weighted score for each option
        4. Return option with minimum score

    Tie Breaking: First occurrence when tied on score.

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list

    Attributes:
        _alpha: Weight for path length (0.0 to 1.0)
    """

    def __init__(self, alpha: float = 0.5) -> None:
        """
        Initialize with load balancing weight.

        Args:
            alpha: Weight for path length (0.0 to 1.0).
                   - 0.0 = prioritize low congestion
                   - 1.0 = prioritize short length
                   - 0.5 = equal balance (default)

        Raises:
            ValueError: If alpha is not in [0, 1] range
        """
        if not 0.0 <= alpha <= 1.0:
            raise ValueError(f"alpha must be in [0, 1], got {alpha}")
        self._alpha = alpha

    @property
    def alpha(self) -> float:
        """Current alpha value."""
        return self._alpha

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select path with minimum weighted score."""
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        max_weight = max(opt.weight_km for opt in feasible)
        if max_weight == 0:
            max_weight = 1.0  # Avoid division by zero

        def compute_score(opt: PathOption) -> float:
            normalized_length = opt.weight_km / max_weight
            return self._alpha * normalized_length + (1 - self._alpha) * opt.congestion

        best = min(feasible, key=compute_score)
        return best.path_index
```

### 2. Update `fusion/policies/__init__.py`

```python
"""
FUSION Control Policies Package.

This package provides path selection policies implementing the ControlPolicy
protocol. Available policy types:

Heuristic Policies:
    - FirstFeasiblePolicy: Selects first feasible path
    - ShortestFeasiblePolicy: Selects shortest feasible path
    - LeastCongestedPolicy: Selects least congested path
    - RandomFeasiblePolicy: Random selection among feasible
    - LoadBalancedPolicy: Weighted length + congestion

Example:
    >>> from fusion.policies import FirstFeasiblePolicy, ControlPolicy
    >>> policy = FirstFeasiblePolicy()
    >>> isinstance(policy, ControlPolicy)
    True
"""

from fusion.interfaces.control_policy import ControlPolicy, PolicyAction
from fusion.policies.heuristic_policy import (
    FirstFeasiblePolicy,
    HeuristicPolicy,
    LeastCongestedPolicy,
    LoadBalancedPolicy,
    RandomFeasiblePolicy,
    ShortestFeasiblePolicy,
)

__all__ = [
    # Protocol
    "ControlPolicy",
    "PolicyAction",
    # Base class
    "HeuristicPolicy",
    # Heuristic policies
    "FirstFeasiblePolicy",
    "ShortestFeasiblePolicy",
    "LeastCongestedPolicy",
    "RandomFeasiblePolicy",
    "LoadBalancedPolicy",
]
```

### 3. Directory Structure After Task

```
fusion/
├── interfaces/
│   ├── __init__.py
│   └── control_policy.py
├── policies/
│   ├── __init__.py              # UPDATED with heuristic exports
│   └── heuristic_policy.py      # NEW: All heuristic policies
└── rl/
    └── adapter.py
```

---

## Verification Commands

```bash
# Import test
python -c "from fusion.policies import FirstFeasiblePolicy, ShortestFeasiblePolicy, LeastCongestedPolicy, RandomFeasiblePolicy, LoadBalancedPolicy; print('OK')"

# Protocol compliance test
python -c "from fusion.interfaces.control_policy import ControlPolicy; from fusion.policies import FirstFeasiblePolicy; assert isinstance(FirstFeasiblePolicy(), ControlPolicy); print('OK')"

# Type checking
mypy fusion/policies/heuristic_policy.py

# Linting
ruff check fusion/policies/heuristic_policy.py
```

---

## Verification Checklist

- [ ] HeuristicPolicy ABC created with select_action abstract
- [ ] FirstFeasiblePolicy implemented correctly
- [ ] ShortestFeasiblePolicy implemented correctly
- [ ] LeastCongestedPolicy implemented correctly
- [ ] RandomFeasiblePolicy implemented with seed support
- [ ] LoadBalancedPolicy implemented with alpha validation
- [ ] All policies pass isinstance(policy, ControlPolicy)
- [ ] All policies exported from `__init__.py`
- [ ] All files pass mypy type checking
- [ ] All files pass ruff linting

---

## Next Task

Proceed to **P5.2.f** to create the verification test suite.
