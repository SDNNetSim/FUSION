# P5.2 Index - Heuristic + Composite Policies

**Phase:** 5 - ML Control + Protection Integration
**Sub-phase:** P5.2
**Status:** Not Started

---

## Goals

1. Implement baseline heuristic policies for path selection
2. Implement composite policies (FallbackPolicy, TiebreakingPolicy) for policy composition
3. Create policy registry for extensible policy management
4. Provide baselines for RL/ML performance comparison
5. Act as fallback policies when ML models fail
6. Demonstrate ControlPolicy protocol usage

**REVISION NOTE**: This file has been updated to include composite policies and the policy registry per V4 specification requirements.

---

## Key Deliverables

| # | Deliverable | Description |
|---|-------------|-------------|
| 1 | `fusion/policies/heuristic_policy.py` | HeuristicPolicy base class and all implementations |
| 2 | `fusion/policies/composite_policy.py` | **NEW**: FallbackPolicy and TiebreakingPolicy |
| 3 | `fusion/policies/registry.py` | **NEW**: Policy registry for extensibility |
| 4 | Policy exports in `fusion/policies/__init__.py` | Public API for all policies |

---

## Policies to Implement

### Heuristic Policies

| Policy Class | Selection Criterion | Learning |
|--------------|---------------------|----------|
| `FirstFeasiblePolicy` | First path with `is_feasible=True` (index order) | No |
| `ShortestFeasiblePolicy` | Feasible path with minimum `weight_km` | No |
| `LeastCongestedPolicy` | Feasible path with minimum `congestion` | No |
| `RandomFeasiblePolicy` | Random selection among feasible paths | No |
| `LoadBalancedPolicy` | Weighted combination: `alpha * length + (1-alpha) * congestion` | No |
| `ModulationAwarePolicy` | **NEW**: Feasible path with most efficient modulation | No |

### Composite Policies

| Policy Class | Behavior | Use Case |
|--------------|----------|----------|
| `FallbackPolicy` | Chain policies, use first valid action | ML with heuristic fallback |
| `TiebreakingPolicy` | Primary policy, secondary for ties | Shortest path with congestion tiebreak |

---

## Constraints

1. **All policies must implement ControlPolicy** - Protocol compliance is mandatory
2. **All policies must implement get_name()** - Required for logging and metrics
3. **update() must be a no-op** - Heuristics do not learn from experience
4. **Respect feasibility** - Only select paths where `is_feasible=True`
5. **Deterministic except Random** - Same input produces same output (RandomFeasible uses seed)
6. **Handle edge cases** - Empty options, all infeasible, ties

---

## Dependencies

### From P5.1
- `ControlPolicy` protocol from `fusion/interfaces/control_policy.py`
- `PathOption` dataclass from `fusion/rl/adapter.py`

### From Earlier Phases
- `Request` from Phase 1
- `NetworkState` from Phase 2

---

## Micro-Tasks

| ID | File | Type | Description |
|----|------|------|-------------|
| P5.2.a | `P5.2.a_context_extraction_heuristics.md` | context-extraction | Extract existing heuristic patterns |
| P5.2.b | `P5.2.b_design_heuristic_base.md` | design | Design HeuristicPolicy base class |
| P5.2.c | `P5.2.c_design_first_shortest_policies.md` | design | Design First/Shortest policies |
| P5.2.d | `P5.2.d_design_congestion_policies.md` | design | Design congestion-aware policies |
| P5.2.e | `P5.2.e_design_composite_policies.md` | design | **NEW**: Design FallbackPolicy and TiebreakingPolicy |
| P5.2.f | `P5.2.f_design_policy_registry.md` | design | **NEW**: Design policy registry |
| P5.2.g | `P5.2.g_implement_heuristic_policies.md` | wiring-plan | Implement all heuristic policies |
| P5.2.h | `P5.2.h_implement_composite_policies.md` | wiring-plan | **NEW**: Implement composite policies |
| P5.2.i | `P5.2.i_verification_plan.md` | verification-plan | Unit tests for all policies |

---

## Shared Context Files

| File | Purpose |
|------|---------|
| `P5.2.shared_context_selection_logic.md` | Selection algorithms and tie-breaking rules |

---

## Selection Logic Summary

### FirstFeasiblePolicy
```python
def select_action(self, request, options, network_state) -> int:
    for opt in options:
        if opt.is_feasible:
            return opt.path_index
    return -1

def get_name(self) -> str:
    return "FirstFeasiblePolicy"
```

### ShortestFeasiblePolicy
```python
def select_action(self, request, options, network_state) -> int:
    feasible = [o for o in options if o.is_feasible]
    if not feasible:
        return -1
    return min(feasible, key=lambda o: o.weight_km).path_index

def get_name(self) -> str:
    return "ShortestFeasiblePolicy"
```

### LeastCongestedPolicy
```python
def select_action(self, request, options, network_state) -> int:
    feasible = [o for o in options if o.is_feasible]
    if not feasible:
        return -1
    return min(feasible, key=lambda o: o.congestion).path_index

def get_name(self) -> str:
    return "LeastCongestedPolicy"
```

### RandomFeasiblePolicy
```python
def __init__(self, seed: int = 42):
    self._rng = np.random.default_rng(seed)

def select_action(self, request, options, network_state) -> int:
    feasible = [o for o in options if o.is_feasible]
    if not feasible:
        return -1
    return self._rng.choice(feasible).path_index

def get_name(self) -> str:
    return f"RandomFeasiblePolicy(seed={self._seed})"
```

### LoadBalancedPolicy
```python
def __init__(self, alpha: float = 0.5):
    self.alpha = alpha

def select_action(self, request, options, network_state) -> int:
    feasible = [o for o in options if o.is_feasible]
    if not feasible:
        return -1
    max_length = max(o.weight_km for o in feasible)
    if max_length == 0:
        max_length = 1.0

    def score(o):
        norm_length = o.weight_km / max_length
        return self.alpha * norm_length + (1 - self.alpha) * o.congestion

    return min(feasible, key=score).path_index

def get_name(self) -> str:
    return f"LoadBalancedPolicy(alpha={self.alpha})"
```

### ModulationAwarePolicy
```python
# Modulation efficiency ranking (higher = more efficient)
MODULATION_EFFICIENCY = {
    "16QAM": 4,
    "8QAM": 3,
    "QPSK": 2,
    "BPSK": 1,
}

def select_action(self, request, options, network_state) -> int:
    feasible = [o for o in options if o.is_feasible and o.modulation]
    if not feasible:
        return -1

    def efficiency(o):
        return MODULATION_EFFICIENCY.get(o.modulation, 0)

    return max(feasible, key=efficiency).path_index

def get_name(self) -> str:
    return "ModulationAwarePolicy"
```

---

## Composite Policies Summary

### FallbackPolicy

Chain multiple policies, returning the first valid action:

```python
class FallbackPolicy:
    """
    Chain policies, using fallback when primary returns invalid.

    Enables ML policies to gracefully degrade to heuristics.

    Example:
        >>> policy = FallbackPolicy(
        ...     MLControlPolicy("model.pt"),
        ...     FirstFeasiblePolicy(),
        ... )
        >>> # Uses ML; if ML fails or returns -1, uses FirstFeasible
    """

    def __init__(self, *policies: ControlPolicy) -> None:
        if not policies:
            raise ValueError("At least one policy required")
        self.policies = policies

    def select_action(self, request, options, network_state) -> int:
        for policy in self.policies:
            action = policy.select_action(request, options, network_state)
            if action >= 0 and action < len(options) and options[action].is_feasible:
                return action
        return -1

    def update(self, request, action, reward) -> None:
        # Update all policies
        for policy in self.policies:
            policy.update(request, action, reward)

    def get_name(self) -> str:
        names = [p.get_name() for p in self.policies]
        return f"FallbackPolicy({' -> '.join(names)})"
```

### TiebreakingPolicy

Use secondary policy for tiebreaking:

```python
class TiebreakingPolicy:
    """
    Primary policy with secondary for tiebreaking.

    When primary returns ties (multiple options with same score),
    secondary policy selects among tied options.

    Example:
        >>> policy = TiebreakingPolicy(
        ...     ShortestFeasiblePolicy(),
        ...     LeastCongestedPolicy(),
        ... )
        >>> # Select shortest; if tie, pick least congested
    """

    def __init__(
        self,
        primary: ControlPolicy,
        secondary: ControlPolicy,
        tie_threshold: float = 1e-6,
    ) -> None:
        self.primary = primary
        self.secondary = secondary
        self.tie_threshold = tie_threshold

    def select_action(self, request, options, network_state) -> int:
        # Get primary selection
        primary_action = self.primary.select_action(request, options, network_state)
        if primary_action < 0:
            return -1

        # Find tied options (same weight as selected)
        selected = options[primary_action]
        ties = [
            o for o in options
            if o.is_feasible and abs(o.weight_km - selected.weight_km) < self.tie_threshold
        ]

        if len(ties) <= 1:
            return primary_action

        # Use secondary policy on tied options
        secondary_action = self.secondary.select_action(request, ties, network_state)
        if secondary_action >= 0 and secondary_action < len(ties):
            return ties[secondary_action].path_index

        return primary_action

    def update(self, request, action, reward) -> None:
        self.primary.update(request, action, reward)
        self.secondary.update(request, action, reward)

    def get_name(self) -> str:
        return f"TiebreakingPolicy({self.primary.get_name()}, tiebreak={self.secondary.get_name()})"
```

---

## Policy Registry

Extensible registry for policy discovery and instantiation:

```python
"""
Policy registry for extensible policy management.

Provides registration, discovery, and factory functionality.
"""

from typing import Callable, TypeVar

T = TypeVar("T")

# Global registry
POLICY_REGISTRY: dict[str, type] = {}


def register_policy(name: str | None = None) -> Callable[[type[T]], type[T]]:
    """
    Decorator to register a policy class.

    Args:
        name: Optional name override. Defaults to class name.

    Example:
        >>> @register_policy("shortest")
        ... class ShortestFeasiblePolicy:
        ...     ...
    """
    def decorator(cls: type[T]) -> type[T]:
        policy_name = name or cls.__name__
        POLICY_REGISTRY[policy_name] = cls
        return cls
    return decorator


def get_policy(name: str, **kwargs) -> "ControlPolicy":
    """
    Get policy instance by name.

    Args:
        name: Registered policy name
        **kwargs: Arguments passed to policy constructor

    Returns:
        Policy instance

    Raises:
        KeyError: If policy not found

    Example:
        >>> policy = get_policy("first_feasible")
        >>> policy = get_policy("load_balanced", alpha=0.7)
    """
    if name not in POLICY_REGISTRY:
        raise KeyError(
            f"Policy '{name}' not found. "
            f"Available: {list(POLICY_REGISTRY.keys())}"
        )
    return POLICY_REGISTRY[name](**kwargs)


def list_policies() -> list[str]:
    """List all registered policy names."""
    return list(POLICY_REGISTRY.keys())


# Pre-register built-in policies
def _register_builtins():
    """Register all built-in policies."""
    from fusion.policies.heuristic_policy import (
        FirstFeasiblePolicy,
        ShortestFeasiblePolicy,
        LeastCongestedPolicy,
        RandomFeasiblePolicy,
        LoadBalancedPolicy,
        ModulationAwarePolicy,
    )
    from fusion.policies.composite_policy import (
        FallbackPolicy,
        TiebreakingPolicy,
    )

    policies = {
        "first_feasible": FirstFeasiblePolicy,
        "shortest_feasible": ShortestFeasiblePolicy,
        "least_congested": LeastCongestedPolicy,
        "random": RandomFeasiblePolicy,
        "load_balanced": LoadBalancedPolicy,
        "modulation_aware": ModulationAwarePolicy,
        "fallback": FallbackPolicy,
        "tiebreaking": TiebreakingPolicy,
    }
    POLICY_REGISTRY.update(policies)
```

---

## Exit Criteria

- [ ] `HeuristicPolicy` abstract base class implemented
- [ ] All 6 heuristic policies implemented and tested
- [ ] `FallbackPolicy` implemented with chaining behavior
- [ ] `TiebreakingPolicy` implemented with tie detection
- [ ] Policy registry with registration/discovery functions
- [ ] All policies pass ControlPolicy isinstance() check
- [ ] All policies implement get_name() method
- [ ] All policies handle edge cases (empty options, all infeasible)
- [ ] Tie-breaking is deterministic (except RandomFeasible)
- [ ] RandomFeasiblePolicy supports seeded RNG
- [ ] LoadBalancedPolicy alpha parameter configurable
- [ ] Unit tests achieve >= 95% coverage
- [ ] All policies exported from `fusion/policies/__init__.py`
- [ ] All policies registered in POLICY_REGISTRY

---

## Next Sub-Phase

After completing P5.2, proceed to:
- **P5.3** (ML Policy Support) - Can run in parallel with P5.4
- **P5.4** (Protection Pipeline) - Can run in parallel with P5.3
