# Shared Context: Selection Logic Patterns

**Purpose:** Document path selection algorithms and patterns for P5.2 tasks
**Used by:** P5.2.a, P5.2.b, P5.2.c, P5.2.d, P5.2.e tasks

---

## Sources

- `fusion/modules/rl/policies/ksp_ff_policy.py` - First-fit implementation
- `fusion/modules/rl/policies/one_plus_one_policy.py` - Protection-aware selection
- `.claude/v4-docs/architecture/heuristic_policies.md` (if exists)

---

## PathOption Fields Used for Selection

| Field | Type | Used By | Description |
|-------|------|---------|-------------|
| `path_index` | `int` | All | Return value for selection |
| `is_feasible` | `bool` | All | Primary filter - must be True |
| `weight_km` | `float` | Shortest, LoadBalanced | Path length in km |
| `congestion` | `float` | LeastCongested, LoadBalanced | Congestion 0-1 |
| `both_paths_feasible` | `bool` | All (protected) | For protection: both paths OK |

---

## Selection Algorithm Patterns

### Pattern 1: First-Match Selection

Used by: `FirstFeasiblePolicy`

```python
def select_first_feasible(options: list[PathOption]) -> int:
    """Return first feasible path index, or -1 if none."""
    for opt in options:
        if opt.is_feasible:
            return opt.path_index
    return -1
```

**Characteristics:**
- O(n) time complexity
- Order-dependent (relies on options being sorted)
- Deterministic
- Assumes options[0] is "best" if feasible

### Pattern 2: Minimum-Key Selection

Used by: `ShortestFeasiblePolicy`, `LeastCongestedPolicy`

```python
def select_minimum_key(
    options: list[PathOption],
    key: Callable[[PathOption], float],
) -> int:
    """Return feasible path with minimum key value, or -1 if none."""
    feasible = [opt for opt in options if opt.is_feasible]
    if not feasible:
        return -1
    return min(feasible, key=key).path_index
```

**Characteristics:**
- O(n) time complexity (filter + min)
- Order-independent
- Deterministic (ties broken by first occurrence in min())

### Pattern 3: Random Selection

Used by: `RandomFeasiblePolicy`

```python
def select_random_feasible(
    options: list[PathOption],
    rng: np.random.Generator,
) -> int:
    """Return random feasible path index, or -1 if none."""
    feasible = [opt for opt in options if opt.is_feasible]
    if not feasible:
        return -1
    return rng.choice(feasible).path_index
```

**Characteristics:**
- O(n) time complexity (filter + choice)
- Order-independent
- Non-deterministic (unless seeded)
- Requires RNG state management

### Pattern 4: Weighted Score Selection

Used by: `LoadBalancedPolicy`

```python
def select_by_weighted_score(
    options: list[PathOption],
    alpha: float,  # Weight for length (0 = congestion only, 1 = length only)
) -> int:
    """Return feasible path with minimum weighted score, or -1 if none."""
    feasible = [opt for opt in options if opt.is_feasible]
    if not feasible:
        return -1

    # Normalize length to 0-1 range
    max_length = max(opt.weight_km for opt in feasible)
    if max_length == 0:
        max_length = 1.0  # Avoid division by zero

    def score(opt: PathOption) -> float:
        normalized_length = opt.weight_km / max_length
        return alpha * normalized_length + (1 - alpha) * opt.congestion

    return min(feasible, key=score).path_index
```

**Characteristics:**
- O(n) time complexity (multiple passes)
- Order-independent
- Deterministic (ties broken by first occurrence)
- Configurable via alpha parameter

---

## Tie-Breaking Rules

### Default Behavior (Python `min`)
When multiple options have the same key value, Python's `min()` returns the first one encountered:

```python
# If opt[1].weight_km == opt[3].weight_km (both minimum)
# min(options, key=lambda o: o.weight_km) returns opt[1]
```

### Explicit Tie-Breaking (Optional Enhancement)
For deterministic tie-breaking based on secondary criteria:

```python
def select_with_tiebreaker(
    options: list[PathOption],
    primary_key: Callable[[PathOption], float],
    secondary_key: Callable[[PathOption], float],
) -> int:
    """Select with explicit tie-breaking on secondary key."""
    feasible = [opt for opt in options if opt.is_feasible]
    if not feasible:
        return -1
    return min(feasible, key=lambda o: (primary_key(o), secondary_key(o))).path_index
```

---

## Feasibility Handling

### Standard Feasibility (Unprotected Paths)

```python
if opt.is_feasible:
    # Path can be selected
```

### Protection-Aware Feasibility

For protected paths, use `both_paths_feasible`:

```python
if opt.is_protected:
    # For protected paths, both primary and backup must be feasible
    if opt.both_paths_feasible:
        # Safe to select
else:
    # Unprotected path
    if opt.is_feasible:
        # Safe to select
```

### Unified Check

```python
def is_selectable(opt: PathOption) -> bool:
    """Check if option can be selected considering protection."""
    if opt.is_protected:
        return opt.both_paths_feasible
    return opt.is_feasible
```

---

## Edge Case Handling

### Empty Options List

```python
def select_action(self, request, options, network_state) -> int:
    if not options:
        return -1  # No options available
    # ... proceed with selection
```

### All Options Infeasible

```python
def select_action(self, request, options, network_state) -> int:
    feasible = [opt for opt in options if opt.is_feasible]
    if not feasible:
        return -1  # All paths blocked
    # ... proceed with selection
```

### Single Option

```python
def select_action(self, request, options, network_state) -> int:
    if len(options) == 1:
        return options[0].path_index if options[0].is_feasible else -1
    # ... proceed with multi-option selection
```

---

## Configuration Parameters

### LoadBalancedPolicy: alpha

| Alpha Value | Behavior |
|-------------|----------|
| `0.0` | Pure congestion-based (same as LeastCongestedPolicy) |
| `0.5` | Equal weight to length and congestion |
| `1.0` | Pure length-based (same as ShortestFeasiblePolicy) |

### RandomFeasiblePolicy: seed

```python
# Reproducible random selection
policy = RandomFeasiblePolicy(seed=42)

# Non-reproducible (uses system entropy)
policy = RandomFeasiblePolicy(seed=None)
```

---

## Performance Considerations

| Policy | Time Complexity | Space Complexity |
|--------|-----------------|------------------|
| FirstFeasible | O(n) worst case, O(1) best | O(1) |
| ShortestFeasible | O(n) | O(n) for feasible list |
| LeastCongested | O(n) | O(n) for feasible list |
| RandomFeasible | O(n) | O(n) for feasible list |
| LoadBalanced | O(n) | O(n) for feasible list |

All policies are efficient for typical K values (K=3 to K=10 paths).

---

## Integration with ControlPolicy

All heuristic policies follow this pattern:

```python
class SomeHeuristicPolicy(HeuristicPolicy):
    """Description of selection strategy."""

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        # 1. Handle empty options
        if not options:
            return -1

        # 2. Filter to feasible
        feasible = [opt for opt in options if opt.is_feasible]
        if not feasible:
            return -1

        # 3. Apply selection logic
        selected = self._select(feasible)
        return selected.path_index

    def update(self, request: Request, action: int, reward: float) -> None:
        # Heuristics don't learn
        pass
```
