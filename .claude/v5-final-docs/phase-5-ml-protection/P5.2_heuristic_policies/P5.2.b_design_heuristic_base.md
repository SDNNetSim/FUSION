# Task ID: P5.2.b - Design HeuristicPolicy Base Class

**Sub-phase:** P5.2
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design the `HeuristicPolicy` abstract base class that all heuristic policies inherit from. This provides common functionality and ensures ControlPolicy protocol compliance.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.1_control_policy_protocol/P5.1.b_design_control_policy_protocol.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.shared_context_selection_logic.md`
- `fusion/interfaces/control_policy.py`

---

## Outputs

### 1. HeuristicPolicy Base Class Design

```python
"""
Heuristic policies for path selection.

This module provides the HeuristicPolicy abstract base class and concrete
implementations for deterministic, rule-based path selection strategies.

All heuristic policies implement the ControlPolicy protocol but do not
learn from experience (update() is a no-op).

Example:
    >>> policy = FirstFeasiblePolicy()
    >>> action = policy.select_action(request, options, network_state)
    >>> policy.update(request, action, reward)  # No-op for heuristics
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.rl.adapter import PathOption


class HeuristicPolicy(ABC):
    """
    Abstract base class for heuristic path selection policies.

    Heuristic policies are deterministic (except RandomFeasiblePolicy),
    rule-based strategies that select paths without learning from experience.
    They serve as:

    1. Default selection strategies
    2. Baselines for RL/ML comparison
    3. Fallback policies when ML models fail

    All subclasses must implement select_action(). The update() method
    is implemented as a no-op since heuristics don't learn.

    This class implements the ControlPolicy protocol, so all subclasses
    are automatically valid ControlPolicy implementations.

    Attributes:
        None - heuristics are typically stateless

    Example:
        >>> class MyHeuristic(HeuristicPolicy):
        ...     def select_action(self, request, options, network_state):
        ...         for opt in options:
        ...             if opt.is_feasible:
        ...                 return opt.path_index
        ...         return -1
        >>>
        >>> policy = MyHeuristic()
        >>> isinstance(policy, ControlPolicy)  # True
    """

    @abstractmethod
    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select an action (path index) based on heuristic rule.

        Subclasses must implement this method with their specific
        selection logic. All implementations should:

        1. Handle empty options list (return -1)
        2. Only select feasible paths (is_feasible=True)
        3. Return valid path_index or -1 for no valid action

        Args:
            request: The incoming request (may be used for context)
            options: List of available PathOptions
            network_state: Current network state (read-only)

        Returns:
            Selected path index (0 to len(options)-1), or -1 if none valid
        """
        ...

    def update(self, request: Request, action: int, reward: float) -> None:
        """
        Update policy based on experience.

        Heuristic policies do not learn, so this is a no-op.
        This method exists to satisfy the ControlPolicy protocol.

        Args:
            request: The request that was served (ignored)
            action: The action taken (ignored)
            reward: The reward received (ignored)
        """
        pass  # Heuristics don't learn

    def get_name(self) -> str:
        """
        Return the policy name for logging and identification.

        Returns:
            The class name by default, can be overridden
        """
        return self.__class__.__name__

    def _get_feasible_options(
        self,
        options: list[PathOption],
    ) -> list[PathOption]:
        """
        Filter options to only feasible ones.

        Helper method for subclasses to extract feasible options.

        Args:
            options: All path options

        Returns:
            List of options where is_feasible=True
        """
        return [opt for opt in options if opt.is_feasible]

    def _get_selectable_options(
        self,
        options: list[PathOption],
    ) -> list[PathOption]:
        """
        Filter options to selectable ones (protection-aware).

        For protected paths, checks both_paths_feasible.
        For unprotected paths, checks is_feasible.

        Args:
            options: All path options

        Returns:
            List of options that can be safely selected
        """
        result = []
        for opt in options:
            if opt.is_protected:
                if opt.both_paths_feasible:
                    result.append(opt)
            else:
                if opt.is_feasible:
                    result.append(opt)
        return result
```

### 2. Design Rationale Table

| Decision | Rationale |
|----------|-----------|
| **ABC inheritance** | Enforces select_action() implementation in subclasses |
| **Protocol compliance** | HeuristicPolicy instances satisfy ControlPolicy protocol |
| **No-op update()** | Heuristics don't learn; empty implementation is explicit |
| **get_name() method** | Useful for logging, debugging, experiment tracking |
| **_get_feasible_options()** | DRY - common filtering logic for subclasses |
| **_get_selectable_options()** | Protection-aware filtering for advanced use |
| **Stateless design** | Most heuristics don't need state (RandomFeasible is exception) |
| **TYPE_CHECKING guard** | Avoid circular imports while keeping type hints |

### 3. Protocol Compliance Verification

```python
from fusion.interfaces.control_policy import ControlPolicy

# HeuristicPolicy subclasses automatically satisfy ControlPolicy
class ConcreteHeuristic(HeuristicPolicy):
    def select_action(self, request, options, network_state) -> int:
        return 0 if options and options[0].is_feasible else -1

policy = ConcreteHeuristic()

# This assertion passes because HeuristicPolicy has both required methods
assert isinstance(policy, ControlPolicy)
```

### 4. Subclass Template

Template for implementing new heuristic policies:

```python
class MyHeuristicPolicy(HeuristicPolicy):
    """
    Description of the selection strategy.

    Selection Logic:
        [Describe how paths are ranked/selected]

    Example:
        >>> policy = MyHeuristicPolicy()
        >>> action = policy.select_action(request, options, network_state)
    """

    def __init__(self, param1: type = default, param2: type = default) -> None:
        """
        Initialize the policy.

        Args:
            param1: Description
            param2: Description
        """
        self.param1 = param1
        self.param2 = param2

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """Select path using [strategy name]."""
        # 1. Handle empty options
        if not options:
            return -1

        # 2. Filter to feasible
        feasible = self._get_feasible_options(options)
        if not feasible:
            return -1

        # 3. Apply selection logic
        selected = self._select_best(feasible)
        return selected.path_index

    def _select_best(self, feasible: list[PathOption]) -> PathOption:
        """Apply specific selection logic."""
        # Implementation here
        ...
```

### 5. Helper Method Usage Examples

```python
class ExamplePolicy(HeuristicPolicy):
    """Example showing helper method usage."""

    def select_action(self, request, options, network_state) -> int:
        # Method 1: Simple feasibility filter
        feasible = self._get_feasible_options(options)

        # Method 2: Protection-aware filter
        selectable = self._get_selectable_options(options)

        # Use whichever is appropriate for the policy
        if not feasible:
            return -1
        return feasible[0].path_index
```

---

## Verification

- [ ] HeuristicPolicy ABC defined with select_action() as abstract
- [ ] update() implemented as no-op pass statement
- [ ] get_name() returns class name by default
- [ ] Helper methods (_get_feasible_options, _get_selectable_options) provided
- [ ] TYPE_CHECKING guard used for type imports
- [ ] Comprehensive docstrings for class and methods
- [ ] Subclass template provided

---

## Test Cases to Implement

```python
# In fusion/tests/policies/test_heuristic_policy.py

class TestHeuristicPolicyBase:
    """Test HeuristicPolicy base class."""

    def test_cannot_instantiate_abstract(self) -> None:
        """HeuristicPolicy is abstract and cannot be instantiated."""
        with pytest.raises(TypeError):
            HeuristicPolicy()  # type: ignore

    def test_subclass_must_implement_select_action(self) -> None:
        """Subclass without select_action should fail."""
        class BadSubclass(HeuristicPolicy):
            pass  # Missing select_action

        with pytest.raises(TypeError):
            BadSubclass()

    def test_valid_subclass_instantiates(self) -> None:
        """Valid subclass should instantiate."""
        class ValidSubclass(HeuristicPolicy):
            def select_action(self, request, options, network_state) -> int:
                return 0

        policy = ValidSubclass()
        assert policy is not None

    def test_update_is_noop(self) -> None:
        """update() should do nothing (no-op)."""
        class ValidSubclass(HeuristicPolicy):
            def select_action(self, request, options, network_state) -> int:
                return 0

        policy = ValidSubclass()
        # Should not raise
        policy.update(None, 0, 1.0)

    def test_get_name_returns_class_name(self) -> None:
        """get_name() should return class name."""
        class MyCustomPolicy(HeuristicPolicy):
            def select_action(self, request, options, network_state) -> int:
                return 0

        policy = MyCustomPolicy()
        assert policy.get_name() == "MyCustomPolicy"

    def test_get_feasible_options_filters_correctly(self) -> None:
        """_get_feasible_options should filter to is_feasible=True."""
        class TestPolicy(HeuristicPolicy):
            def select_action(self, request, options, network_state) -> int:
                return 0

        policy = TestPolicy()

        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 50, True, "QPSK", 4, 0.3),
            PathOption.from_unprotected_route(1, ["A", "C"], 60, False, None, None, 0.8),
            PathOption.from_unprotected_route(2, ["A", "D"], 70, True, "QPSK", 4, 0.5),
        ]

        feasible = policy._get_feasible_options(options)
        assert len(feasible) == 2
        assert all(opt.is_feasible for opt in feasible)

    def test_is_control_policy(self) -> None:
        """HeuristicPolicy subclasses should be ControlPolicy instances."""
        class ValidSubclass(HeuristicPolicy):
            def select_action(self, request, options, network_state) -> int:
                return 0

        policy = ValidSubclass()
        assert isinstance(policy, ControlPolicy)
```

---

## Next Task

Proceed to **P5.2.c** to design FirstFeasiblePolicy and ShortestFeasiblePolicy.
