# Task ID: P5.2.f - Verification Plan: Heuristic Policies

**Sub-phase:** P5.2
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** verification-plan

---

## Purpose

Define comprehensive unit tests for all heuristic policies to ensure correctness, protocol compliance, and proper edge case handling.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.e_implement_heuristic_policies.md`
- `fusion/policies/heuristic_policy.py`
- `fusion/rl/adapter.py` (PathOption)

---

## Outputs

### 1. Test File Structure

```
fusion/tests/
└── policies/
    ├── __init__.py
    ├── conftest.py                    # Shared fixtures
    └── test_heuristic_policy.py       # All heuristic policy tests
```

### 2. Create `fusion/tests/policies/__init__.py`

```python
"""Tests for fusion.policies package."""
```

### 3. Create `fusion/tests/policies/conftest.py`

```python
"""
Shared fixtures for policy tests.

Provides reusable PathOption fixtures and test helpers.
"""

from __future__ import annotations

import pytest

from fusion.rl.adapter import PathOption


@pytest.fixture
def single_feasible_option() -> list[PathOption]:
    """Single feasible PathOption."""
    return [
        PathOption.from_unprotected_route(
            path_index=0,
            path=["A", "B"],
            weight_km=100.0,
            is_feasible=True,
            modulation="QPSK",
            slots_needed=4,
            congestion=0.5,
        ),
    ]


@pytest.fixture
def single_infeasible_option() -> list[PathOption]:
    """Single infeasible PathOption."""
    return [
        PathOption.from_unprotected_route(
            path_index=0,
            path=["A", "B"],
            weight_km=100.0,
            is_feasible=False,
            modulation=None,
            slots_needed=None,
            congestion=0.8,
        ),
    ]


@pytest.fixture
def mixed_feasibility_options() -> list[PathOption]:
    """Mix of feasible and infeasible options."""
    return [
        PathOption.from_unprotected_route(0, ["A", "B"], 150.0, False, None, None, 0.7),
        PathOption.from_unprotected_route(1, ["A", "C"], 100.0, True, "QPSK", 4, 0.3),
        PathOption.from_unprotected_route(2, ["A", "D"], 200.0, True, "QPSK", 4, 0.5),
        PathOption.from_unprotected_route(3, ["A", "E"], 120.0, False, None, None, 0.2),
    ]


@pytest.fixture
def all_feasible_options() -> list[PathOption]:
    """All feasible options with varying metrics."""
    return [
        PathOption.from_unprotected_route(0, ["A", "B"], 150.0, True, "QPSK", 4, 0.7),
        PathOption.from_unprotected_route(1, ["A", "C"], 100.0, True, "QPSK", 4, 0.3),
        PathOption.from_unprotected_route(2, ["A", "D"], 200.0, True, "QPSK", 4, 0.5),
        PathOption.from_unprotected_route(3, ["A", "E"], 120.0, True, "QPSK", 4, 0.2),
    ]


@pytest.fixture
def all_infeasible_options() -> list[PathOption]:
    """All infeasible options."""
    return [
        PathOption.from_unprotected_route(0, ["A", "B"], 150.0, False, None, None, 0.7),
        PathOption.from_unprotected_route(1, ["A", "C"], 100.0, False, None, None, 0.3),
    ]


@pytest.fixture
def tied_weight_options() -> list[PathOption]:
    """Options with identical weight_km for tie-breaking tests."""
    return [
        PathOption.from_unprotected_route(0, ["A", "B"], 100.0, True, "QPSK", 4, 0.5),
        PathOption.from_unprotected_route(1, ["A", "C"], 100.0, True, "QPSK", 4, 0.3),
        PathOption.from_unprotected_route(2, ["A", "D"], 100.0, True, "QPSK", 4, 0.7),
    ]


@pytest.fixture
def tied_congestion_options() -> list[PathOption]:
    """Options with identical congestion for tie-breaking tests."""
    return [
        PathOption.from_unprotected_route(0, ["A", "B"], 150.0, True, "QPSK", 4, 0.5),
        PathOption.from_unprotected_route(1, ["A", "C"], 100.0, True, "QPSK", 4, 0.5),
        PathOption.from_unprotected_route(2, ["A", "D"], 200.0, True, "QPSK", 4, 0.5),
    ]


@pytest.fixture
def protected_options() -> list[PathOption]:
    """Protected path options."""
    return [
        PathOption.from_protected_route(
            path_index=0,
            primary_path=["A", "B", "C"],
            backup_path=["A", "D", "C"],
            primary_weight=100.0,
            backup_weight=150.0,
            primary_feasible=True,
            backup_feasible=True,
            primary_modulation="QPSK",
            backup_modulation="QPSK",
            slots_needed=4,
            congestion=0.3,
        ),
        PathOption.from_protected_route(
            path_index=1,
            primary_path=["A", "E", "C"],
            backup_path=["A", "F", "C"],
            primary_weight=80.0,
            backup_weight=120.0,
            primary_feasible=True,
            backup_feasible=False,  # Backup infeasible
            primary_modulation="QPSK",
            backup_modulation=None,
            slots_needed=4,
            congestion=0.5,
        ),
    ]
```

### 4. Create `fusion/tests/policies/test_heuristic_policy.py`

```python
"""
Tests for heuristic policies.

Comprehensive test suite covering:
- HeuristicPolicy base class
- FirstFeasiblePolicy
- ShortestFeasiblePolicy
- LeastCongestedPolicy
- RandomFeasiblePolicy
- LoadBalancedPolicy
"""

from __future__ import annotations

import pytest

from fusion.interfaces.control_policy import ControlPolicy
from fusion.policies.heuristic_policy import (
    FirstFeasiblePolicy,
    HeuristicPolicy,
    LeastCongestedPolicy,
    LoadBalancedPolicy,
    RandomFeasiblePolicy,
    ShortestFeasiblePolicy,
)
from fusion.rl.adapter import PathOption


class TestHeuristicPolicyBase:
    """Tests for HeuristicPolicy abstract base class."""

    def test_cannot_instantiate_abstract(self) -> None:
        """HeuristicPolicy is abstract and cannot be instantiated."""
        with pytest.raises(TypeError, match="abstract"):
            HeuristicPolicy()  # type: ignore

    def test_subclass_must_implement_select_action(self) -> None:
        """Subclass without select_action should fail to instantiate."""

        class IncompletePolicy(HeuristicPolicy):
            pass  # Missing select_action

        with pytest.raises(TypeError, match="abstract"):
            IncompletePolicy()

    def test_valid_subclass_instantiates(self) -> None:
        """Valid subclass should instantiate correctly."""

        class ValidPolicy(HeuristicPolicy):
            def select_action(self, request, options, network_state) -> int:
                return 0

        policy = ValidPolicy()
        assert policy is not None

    def test_update_is_noop(self) -> None:
        """update() should complete without side effects."""
        policy = FirstFeasiblePolicy()
        # Should not raise or have any effect
        policy.update(None, 0, 1.0)
        policy.update(None, -1, -0.5)

    def test_get_name_returns_class_name(self) -> None:
        """get_name() should return the class name."""
        assert FirstFeasiblePolicy().get_name() == "FirstFeasiblePolicy"
        assert ShortestFeasiblePolicy().get_name() == "ShortestFeasiblePolicy"
        assert LeastCongestedPolicy().get_name() == "LeastCongestedPolicy"
        assert RandomFeasiblePolicy().get_name() == "RandomFeasiblePolicy"
        assert LoadBalancedPolicy().get_name() == "LoadBalancedPolicy"

    def test_all_policies_implement_control_policy(self) -> None:
        """All heuristic policies should satisfy ControlPolicy protocol."""
        policies = [
            FirstFeasiblePolicy(),
            ShortestFeasiblePolicy(),
            LeastCongestedPolicy(),
            RandomFeasiblePolicy(),
            LoadBalancedPolicy(),
        ]
        for policy in policies:
            assert isinstance(policy, ControlPolicy), f"{policy.get_name()} failed"


class TestFirstFeasiblePolicy:
    """Tests for FirstFeasiblePolicy."""

    def test_selects_first_feasible(self, mixed_feasibility_options) -> None:
        """Should select first feasible option (index 1)."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, mixed_feasibility_options, None)
        assert action == 1

    def test_returns_zero_when_first_is_feasible(self, all_feasible_options) -> None:
        """Should return 0 when first option is feasible."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, all_feasible_options, None)
        assert action == 0

    def test_empty_options_returns_negative_one(self) -> None:
        """Should return -1 for empty options list."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_all_infeasible_returns_negative_one(self, all_infeasible_options) -> None:
        """Should return -1 when all options are infeasible."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, all_infeasible_options, None)
        assert action == -1

    def test_single_feasible_option(self, single_feasible_option) -> None:
        """Should handle single feasible option."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, single_feasible_option, None)
        assert action == 0

    def test_single_infeasible_option(self, single_infeasible_option) -> None:
        """Should handle single infeasible option."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, single_infeasible_option, None)
        assert action == -1


class TestShortestFeasiblePolicy:
    """Tests for ShortestFeasiblePolicy."""

    def test_selects_shortest_feasible(self, mixed_feasibility_options) -> None:
        """Should select shortest feasible (100km at index 1)."""
        policy = ShortestFeasiblePolicy()
        action = policy.select_action(None, mixed_feasibility_options, None)
        assert action == 1

    def test_ignores_shorter_infeasible(self) -> None:
        """Should ignore shorter paths that are infeasible."""
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 50.0, False, None, None, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 100.0, True, "QPSK", 4, 0.3),
        ]
        policy = ShortestFeasiblePolicy()
        action = policy.select_action(None, options, None)
        assert action == 1

    def test_tie_breaking_first_occurrence(self, tied_weight_options) -> None:
        """When tied on weight_km, should select first occurrence."""
        policy = ShortestFeasiblePolicy()
        action = policy.select_action(None, tied_weight_options, None)
        assert action == 0  # First with minimum weight

    def test_empty_options_returns_negative_one(self) -> None:
        """Should return -1 for empty options list."""
        policy = ShortestFeasiblePolicy()
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_all_infeasible_returns_negative_one(self, all_infeasible_options) -> None:
        """Should return -1 when all options are infeasible."""
        policy = ShortestFeasiblePolicy()
        action = policy.select_action(None, all_infeasible_options, None)
        assert action == -1


class TestLeastCongestedPolicy:
    """Tests for LeastCongestedPolicy."""

    def test_selects_least_congested(self, all_feasible_options) -> None:
        """Should select least congested (0.2 at index 3)."""
        policy = LeastCongestedPolicy()
        action = policy.select_action(None, all_feasible_options, None)
        assert action == 3

    def test_ignores_less_congested_infeasible(self) -> None:
        """Should ignore infeasible paths even if less congested."""
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100.0, True, "QPSK", 4, 0.8),
            PathOption.from_unprotected_route(1, ["A", "C"], 200.0, False, None, None, 0.1),
        ]
        policy = LeastCongestedPolicy()
        action = policy.select_action(None, options, None)
        assert action == 0

    def test_tie_breaking_first_occurrence(self, tied_congestion_options) -> None:
        """When tied on congestion, should select first occurrence."""
        policy = LeastCongestedPolicy()
        action = policy.select_action(None, tied_congestion_options, None)
        assert action == 0  # First with minimum congestion

    def test_empty_options_returns_negative_one(self) -> None:
        """Should return -1 for empty options list."""
        policy = LeastCongestedPolicy()
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_all_infeasible_returns_negative_one(self, all_infeasible_options) -> None:
        """Should return -1 when all options are infeasible."""
        policy = LeastCongestedPolicy()
        action = policy.select_action(None, all_infeasible_options, None)
        assert action == -1


class TestRandomFeasiblePolicy:
    """Tests for RandomFeasiblePolicy."""

    def test_selects_from_feasible_only(self) -> None:
        """Should only select from feasible options."""
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100.0, False, None, None, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 200.0, True, "QPSK", 4, 0.3),
        ]
        policy = RandomFeasiblePolicy(seed=42)
        # Run multiple times - should always return 1 (only feasible)
        for _ in range(10):
            action = policy.select_action(None, options, None)
            assert action == 1

    def test_reproducible_with_seed(self, all_feasible_options) -> None:
        """Same seed should produce same sequence."""
        policy1 = RandomFeasiblePolicy(seed=42)
        policy2 = RandomFeasiblePolicy(seed=42)

        actions1 = [policy1.select_action(None, all_feasible_options, None) for _ in range(20)]
        actions2 = [policy2.select_action(None, all_feasible_options, None) for _ in range(20)]

        assert actions1 == actions2

    def test_different_seeds_produce_different_results(self, all_feasible_options) -> None:
        """Different seeds should (likely) produce different sequences."""
        policy1 = RandomFeasiblePolicy(seed=42)
        policy2 = RandomFeasiblePolicy(seed=123)

        actions1 = [policy1.select_action(None, all_feasible_options, None) for _ in range(20)]
        actions2 = [policy2.select_action(None, all_feasible_options, None) for _ in range(20)]

        # Very unlikely to be identical with different seeds
        assert actions1 != actions2

    def test_reset_rng_restores_sequence(self, all_feasible_options) -> None:
        """reset_rng should restore reproducibility."""
        policy = RandomFeasiblePolicy(seed=42)

        actions1 = [policy.select_action(None, all_feasible_options, None) for _ in range(10)]
        policy.reset_rng()  # Reset to original seed
        actions2 = [policy.select_action(None, all_feasible_options, None) for _ in range(10)]

        assert actions1 == actions2

    def test_reset_rng_with_new_seed(self, all_feasible_options) -> None:
        """reset_rng with new seed should change sequence."""
        policy = RandomFeasiblePolicy(seed=42)

        actions1 = [policy.select_action(None, all_feasible_options, None) for _ in range(10)]
        policy.reset_rng(seed=999)
        actions2 = [policy.select_action(None, all_feasible_options, None) for _ in range(10)]

        assert actions1 != actions2

    def test_empty_options_returns_negative_one(self) -> None:
        """Should return -1 for empty options list."""
        policy = RandomFeasiblePolicy(seed=42)
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_all_infeasible_returns_negative_one(self, all_infeasible_options) -> None:
        """Should return -1 when all options are infeasible."""
        policy = RandomFeasiblePolicy(seed=42)
        action = policy.select_action(None, all_infeasible_options, None)
        assert action == -1

    def test_covers_all_feasible_options(self, all_feasible_options) -> None:
        """Should eventually select all feasible options given enough samples."""
        policy = RandomFeasiblePolicy(seed=None)  # Use system entropy
        selected = set()

        for _ in range(1000):
            action = policy.select_action(None, all_feasible_options, None)
            selected.add(action)
            if len(selected) == len(all_feasible_options):
                break

        assert selected == {0, 1, 2, 3}


class TestLoadBalancedPolicy:
    """Tests for LoadBalancedPolicy."""

    def test_alpha_zero_equals_least_congested(self) -> None:
        """alpha=0 should behave like LeastCongestedPolicy."""
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100.0, True, "QPSK", 4, 0.8),
            PathOption.from_unprotected_route(1, ["A", "C"], 200.0, True, "QPSK", 4, 0.2),
        ]
        policy = LoadBalancedPolicy(alpha=0.0)
        action = policy.select_action(None, options, None)
        assert action == 1  # Lower congestion wins

    def test_alpha_one_equals_shortest(self) -> None:
        """alpha=1 should behave like ShortestFeasiblePolicy."""
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100.0, True, "QPSK", 4, 0.9),
            PathOption.from_unprotected_route(1, ["A", "C"], 200.0, True, "QPSK", 4, 0.1),
        ]
        policy = LoadBalancedPolicy(alpha=1.0)
        action = policy.select_action(None, options, None)
        assert action == 0  # Shorter wins

    def test_balanced_selection(self) -> None:
        """alpha=0.5 should balance both metrics."""
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 200.0, True, "QPSK", 4, 0.2),
            PathOption.from_unprotected_route(1, ["A", "C"], 100.0, True, "QPSK", 4, 0.8),
        ]
        policy = LoadBalancedPolicy(alpha=0.5)
        # opt0: 0.5*1.0 + 0.5*0.2 = 0.6
        # opt1: 0.5*0.5 + 0.5*0.8 = 0.65
        action = policy.select_action(None, options, None)
        assert action == 0  # Lower combined score

    def test_alpha_property(self) -> None:
        """alpha property should return configured value."""
        policy = LoadBalancedPolicy(alpha=0.75)
        assert policy.alpha == 0.75

    def test_rejects_alpha_below_zero(self) -> None:
        """Should reject alpha < 0."""
        with pytest.raises(ValueError, match="alpha must be in"):
            LoadBalancedPolicy(alpha=-0.1)

    def test_rejects_alpha_above_one(self) -> None:
        """Should reject alpha > 1."""
        with pytest.raises(ValueError, match="alpha must be in"):
            LoadBalancedPolicy(alpha=1.5)

    def test_accepts_alpha_boundaries(self) -> None:
        """Should accept alpha exactly 0 and 1."""
        policy0 = LoadBalancedPolicy(alpha=0.0)
        policy1 = LoadBalancedPolicy(alpha=1.0)
        assert policy0.alpha == 0.0
        assert policy1.alpha == 1.0

    def test_handles_zero_max_weight(self) -> None:
        """Should handle case where all paths have weight_km=0."""
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 0.0, True, "QPSK", 4, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 0.0, True, "QPSK", 4, 0.3),
        ]
        policy = LoadBalancedPolicy(alpha=0.5)
        action = policy.select_action(None, options, None)
        # Should not crash; congestion becomes deciding factor
        assert action == 1  # Lower congestion

    def test_empty_options_returns_negative_one(self) -> None:
        """Should return -1 for empty options list."""
        policy = LoadBalancedPolicy()
        action = policy.select_action(None, [], None)
        assert action == -1

    def test_all_infeasible_returns_negative_one(self, all_infeasible_options) -> None:
        """Should return -1 when all options are infeasible."""
        policy = LoadBalancedPolicy()
        action = policy.select_action(None, all_infeasible_options, None)
        assert action == -1


class TestProtectionAwareness:
    """Test that policies work correctly with protected paths."""

    def test_first_feasible_with_protection(self, protected_options) -> None:
        """FirstFeasible should select based on is_feasible (primary)."""
        policy = FirstFeasiblePolicy()
        action = policy.select_action(None, protected_options, None)
        # Both have primary feasible, so returns first
        assert action == 0

    def test_shortest_feasible_with_protection(self, protected_options) -> None:
        """ShortestFeasible should consider primary weight_km."""
        policy = ShortestFeasiblePolicy()
        # opt0: 100km, opt1: 80km (shorter but backup infeasible)
        action = policy.select_action(None, protected_options, None)
        # Basic policy only checks is_feasible, not both_paths_feasible
        assert action == 1  # Shorter primary wins

    def test_protection_aware_selection(self, protected_options) -> None:
        """Demo of protection-aware filtering using helper method."""

        class ProtectionAwarePolicy(HeuristicPolicy):
            def select_action(self, request, options, network_state) -> int:
                selectable = self._get_selectable_options(options)
                if not selectable:
                    return -1
                return selectable[0].path_index

        policy = ProtectionAwarePolicy()
        action = policy.select_action(None, protected_options, None)
        # Only opt0 has both_paths_feasible=True
        assert action == 0
```

---

## Verification Commands

```bash
# Run all heuristic policy tests
pytest fusion/tests/policies/test_heuristic_policy.py -v

# Run with coverage
pytest fusion/tests/policies/test_heuristic_policy.py \
    --cov=fusion/policies/heuristic_policy \
    --cov-report=term-missing

# Run specific test class
pytest fusion/tests/policies/test_heuristic_policy.py::TestLoadBalancedPolicy -v

# Type checking
mypy fusion/tests/policies/test_heuristic_policy.py
```

---

## Coverage Requirements

| Policy | Target | Notes |
|--------|--------|-------|
| HeuristicPolicy (base) | 100% | Abstract methods, helpers |
| FirstFeasiblePolicy | 100% | Simple logic |
| ShortestFeasiblePolicy | 100% | min() selection |
| LeastCongestedPolicy | 100% | min() selection |
| RandomFeasiblePolicy | 95% | RNG operations |
| LoadBalancedPolicy | 100% | Score computation |

---

## Verification Checklist

- [ ] All test classes have meaningful docstrings
- [ ] Fixtures provide reusable test data
- [ ] Base class tests verify ABC behavior
- [ ] Each policy has tests for:
  - [ ] Normal selection
  - [ ] Empty options
  - [ ] All infeasible options
  - [ ] Tie-breaking (where applicable)
- [ ] RandomFeasiblePolicy tests verify:
  - [ ] Reproducibility with seed
  - [ ] reset_rng() functionality
  - [ ] Coverage of all options
- [ ] LoadBalancedPolicy tests verify:
  - [ ] alpha extremes (0, 1)
  - [ ] alpha validation
  - [ ] Zero weight edge case
- [ ] Protection-aware tests included
- [ ] All tests pass
- [ ] Coverage meets targets

---

## Next Sub-Phase

After completing P5.2, proceed to **P5.3** (ML Policy Support) or **P5.4** (Protection Pipeline).
