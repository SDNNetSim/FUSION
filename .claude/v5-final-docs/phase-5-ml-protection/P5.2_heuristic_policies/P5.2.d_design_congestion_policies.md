# Task ID: P5.2.d - Design Congestion-Aware Policies

**Sub-phase:** P5.2
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** design

---

## Purpose

Design `LeastCongestedPolicy`, `RandomFeasiblePolicy`, and `LoadBalancedPolicy` - heuristic policies that consider congestion and/or introduce randomness for exploration.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.b_design_heuristic_base.md`
- `.claude/v5-final-docs/phase-5-ml-protection/P5.2_heuristic_policies/P5.2.shared_context_selection_logic.md`
- `fusion/rl/adapter.py` (PathOption)

---

## Outputs

### 1. LeastCongestedPolicy

```python
class LeastCongestedPolicy(HeuristicPolicy):
    """
    Select the least congested feasible path.

    This policy prioritizes paths with lower congestion values, which
    helps distribute load across the network and reduce fragmentation.

    The congestion field in PathOption is a normalized value from 0.0
    (no congestion) to 1.0 (fully congested).

    Selection Logic:
        1. Filter to feasible options
        2. Find option with minimum congestion
        3. Return its path_index, or -1 if none feasible

    Tie Breaking:
        When multiple paths have the same congestion, the first one
        encountered (lowest index) is selected.

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list

    Example:
        >>> policy = LeastCongestedPolicy()
        >>> options = [
        ...     PathOption(..., congestion=0.7, is_feasible=True),   # Index 0
        ...     PathOption(..., congestion=0.2, is_feasible=False),  # Index 1: blocked
        ...     PathOption(..., congestion=0.4, is_feasible=True),   # Index 2
        ... ]
        >>> policy.select_action(request, options, network_state)
        2  # Returns least congested feasible (0.4 at index 2)
    """

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select the least congested feasible path.

        Args:
            request: The incoming request (not used by this policy)
            options: List of path options to choose from
            network_state: Current network state (not used by this policy)

        Returns:
            Index of least congested feasible path, or -1 if none feasible
        """
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        least_congested = min(feasible, key=lambda opt: opt.congestion)
        return least_congested.path_index
```

### 2. RandomFeasiblePolicy

```python
import numpy as np


class RandomFeasiblePolicy(HeuristicPolicy):
    """
    Randomly select among feasible paths.

    This policy uniformly samples from all feasible paths. It's useful for:
    - Exploration during training
    - Baseline comparison (random performance)
    - Load distribution across multiple paths

    The policy uses numpy's random number generator, which can be seeded
    for reproducibility.

    Selection Logic:
        1. Filter to feasible options
        2. Uniformly sample one option
        3. Return its path_index, or -1 if none feasible

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list

    Example:
        >>> policy = RandomFeasiblePolicy(seed=42)
        >>> options = [
        ...     PathOption(..., is_feasible=True),   # Index 0
        ...     PathOption(..., is_feasible=True),   # Index 1
        ...     PathOption(..., is_feasible=True),   # Index 2
        ... ]
        >>> policy.select_action(request, options, network_state)
        # Returns random index among {0, 1, 2}
    """

    def __init__(self, seed: int | None = None) -> None:
        """
        Initialize with optional random seed.

        Args:
            seed: Random seed for reproducibility. If None, uses
                  system entropy (non-reproducible).
        """
        self._rng = np.random.default_rng(seed)
        self._seed = seed

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Randomly select a feasible path.

        Args:
            request: The incoming request (not used by this policy)
            options: List of path options to choose from
            network_state: Current network state (not used by this policy)

        Returns:
            Index of randomly selected feasible path, or -1 if none feasible
        """
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        selected = self._rng.choice(feasible)
        return selected.path_index

    def reset_rng(self, seed: int | None = None) -> None:
        """
        Reset the random number generator.

        Args:
            seed: New seed. If None, uses the original seed.
        """
        if seed is None:
            seed = self._seed
        self._rng = np.random.default_rng(seed)
```

### 3. LoadBalancedPolicy

```python
class LoadBalancedPolicy(HeuristicPolicy):
    """
    Select path balancing length and congestion.

    This policy combines path length (weight_km) and congestion into a
    weighted score. The alpha parameter controls the trade-off:

    - alpha = 0.0: Pure congestion-based (same as LeastCongestedPolicy)
    - alpha = 0.5: Equal weight to length and congestion
    - alpha = 1.0: Pure length-based (same as ShortestFeasiblePolicy)

    Score Formula:
        score = alpha * normalized_length + (1 - alpha) * congestion

    Where normalized_length = weight_km / max_weight_km among feasible paths.

    Selection Logic:
        1. Filter to feasible options
        2. Normalize weight_km to [0, 1] range
        3. Compute weighted score for each option
        4. Return option with minimum score

    Tie Breaking:
        When multiple paths have the same score, the first one
        encountered (lowest index) is selected.

    Time Complexity: O(n)
    Space Complexity: O(n) for feasible list

    Example:
        >>> policy = LoadBalancedPolicy(alpha=0.5)
        >>> options = [
        ...     PathOption(..., weight_km=200, congestion=0.2, is_feasible=True),
        ...     PathOption(..., weight_km=100, congestion=0.8, is_feasible=True),
        ... ]
        >>> # Option 0: score = 0.5 * 1.0 + 0.5 * 0.2 = 0.6
        >>> # Option 1: score = 0.5 * 0.5 + 0.5 * 0.8 = 0.65
        >>> policy.select_action(request, options, network_state)
        0  # Lower combined score
    """

    def __init__(self, alpha: float = 0.5) -> None:
        """
        Initialize with load balancing weight.

        Args:
            alpha: Weight for path length (0.0 to 1.0).
                   - 0.0 = prioritize low congestion
                   - 1.0 = prioritize short length
                   - 0.5 = equal balance (default)

        Raises:
            ValueError: If alpha is not in [0, 1] range
        """
        if not 0.0 <= alpha <= 1.0:
            raise ValueError(f"alpha must be in [0, 1], got {alpha}")
        self._alpha = alpha

    @property
    def alpha(self) -> float:
        """Current alpha value."""
        return self._alpha

    def select_action(
        self,
        request: Request,
        options: list[PathOption],
        network_state: NetworkState,
    ) -> int:
        """
        Select path with minimum weighted score.

        Args:
            request: The incoming request (not used by this policy)
            options: List of path options to choose from
            network_state: Current network state (not used by this policy)

        Returns:
            Index of best balanced path, or -1 if none feasible
        """
        feasible = self._get_feasible_options(options)

        if not feasible:
            return -1

        # Handle edge case: all paths have same length
        max_weight = max(opt.weight_km for opt in feasible)
        if max_weight == 0:
            max_weight = 1.0  # Avoid division by zero

        def compute_score(opt: PathOption) -> float:
            normalized_length = opt.weight_km / max_weight
            return self._alpha * normalized_length + (1 - self._alpha) * opt.congestion

        best = min(feasible, key=compute_score)
        return best.path_index
```

### 4. Design Comparison

| Aspect | LeastCongested | Random | LoadBalanced |
|--------|----------------|--------|--------------|
| **Primary metric** | congestion | None | weight_km + congestion |
| **Deterministic** | Yes | No (unless seeded) | Yes |
| **State** | None | RNG state | alpha parameter |
| **Configurable** | No | seed | alpha |
| **Use case** | Load distribution | Exploration | Balanced optimization |

### 5. Parameter Guidance

#### RandomFeasiblePolicy Seed

```python
# Reproducible experiments
policy = RandomFeasiblePolicy(seed=42)

# Production (varied behavior)
policy = RandomFeasiblePolicy(seed=None)

# Reset during simulation
policy.reset_rng(seed=123)
```

#### LoadBalancedPolicy Alpha

| Alpha | Behavior | Best For |
|-------|----------|----------|
| 0.0 | Pure congestion | Avoiding hotspots |
| 0.25 | Congestion-heavy | High traffic scenarios |
| 0.5 | Balanced | General use (default) |
| 0.75 | Length-heavy | Low latency requirements |
| 1.0 | Pure length | Shortest path optimization |

---

## Verification

- [ ] LeastCongestedPolicy selects minimum congestion among feasible
- [ ] RandomFeasiblePolicy uses seeded RNG correctly
- [ ] RandomFeasiblePolicy.reset_rng() works as expected
- [ ] LoadBalancedPolicy validates alpha in [0, 1]
- [ ] LoadBalancedPolicy handles zero max_weight edge case
- [ ] All policies return -1 for empty/all-infeasible options
- [ ] All policies have comprehensive docstrings

---

## Test Cases to Implement

```python
# In fusion/tests/policies/test_heuristic_policy.py

class TestLeastCongestedPolicy:
    """Tests for LeastCongestedPolicy."""

    def test_selects_least_congested(self) -> None:
        """Should select path with minimum congestion."""
        policy = LeastCongestedPolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, True, "QPSK", 4, 0.7),
            PathOption.from_unprotected_route(1, ["A", "C"], 200, True, "QPSK", 4, 0.3),
            PathOption.from_unprotected_route(2, ["A", "D"], 150, True, "QPSK", 4, 0.5),
        ]
        action = policy.select_action(None, options, None)
        assert action == 1  # Lowest congestion (0.3)

    def test_ignores_less_congested_infeasible(self) -> None:
        """Should ignore infeasible paths even if less congested."""
        policy = LeastCongestedPolicy()
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, True, "QPSK", 4, 0.8),
            PathOption.from_unprotected_route(1, ["A", "C"], 200, False, None, None, 0.1),  # Blocked
        ]
        action = policy.select_action(None, options, None)
        assert action == 0

    def test_returns_negative_one_when_empty(self) -> None:
        """Should return -1 for empty options."""
        policy = LeastCongestedPolicy()
        action = policy.select_action(None, [], None)
        assert action == -1


class TestRandomFeasiblePolicy:
    """Tests for RandomFeasiblePolicy."""

    def test_selects_from_feasible_only(self) -> None:
        """Should only select from feasible options."""
        policy = RandomFeasiblePolicy(seed=42)
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, False, None, None, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 200, True, "QPSK", 4, 0.3),
        ]
        action = policy.select_action(None, options, None)
        assert action == 1  # Only feasible option

    def test_reproducible_with_seed(self) -> None:
        """Same seed should produce same sequence."""
        options = [
            PathOption.from_unprotected_route(i, ["A", str(i)], 100, True, "QPSK", 4, 0.5)
            for i in range(5)
        ]

        policy1 = RandomFeasiblePolicy(seed=42)
        policy2 = RandomFeasiblePolicy(seed=42)

        actions1 = [policy1.select_action(None, options, None) for _ in range(10)]
        actions2 = [policy2.select_action(None, options, None) for _ in range(10)]

        assert actions1 == actions2

    def test_reset_rng(self) -> None:
        """reset_rng should restore reproducibility."""
        policy = RandomFeasiblePolicy(seed=42)
        options = [
            PathOption.from_unprotected_route(i, ["A", str(i)], 100, True, "QPSK", 4, 0.5)
            for i in range(5)
        ]

        actions1 = [policy.select_action(None, options, None) for _ in range(5)]
        policy.reset_rng()  # Reset to original seed
        actions2 = [policy.select_action(None, options, None) for _ in range(5)]

        assert actions1 == actions2

    def test_returns_negative_one_when_empty(self) -> None:
        """Should return -1 for empty options."""
        policy = RandomFeasiblePolicy(seed=42)
        action = policy.select_action(None, [], None)
        assert action == -1


class TestLoadBalancedPolicy:
    """Tests for LoadBalancedPolicy."""

    def test_alpha_zero_equals_least_congested(self) -> None:
        """alpha=0 should behave like LeastCongestedPolicy."""
        policy = LoadBalancedPolicy(alpha=0.0)
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, True, "QPSK", 4, 0.8),  # Shorter but congested
            PathOption.from_unprotected_route(1, ["A", "C"], 200, True, "QPSK", 4, 0.2),  # Longer but clear
        ]
        action = policy.select_action(None, options, None)
        assert action == 1  # Lower congestion wins

    def test_alpha_one_equals_shortest(self) -> None:
        """alpha=1 should behave like ShortestFeasiblePolicy."""
        policy = LoadBalancedPolicy(alpha=1.0)
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 100, True, "QPSK", 4, 0.9),  # Shorter
            PathOption.from_unprotected_route(1, ["A", "C"], 200, True, "QPSK", 4, 0.1),  # Longer
        ]
        action = policy.select_action(None, options, None)
        assert action == 0  # Shorter wins

    def test_balanced_selection(self) -> None:
        """alpha=0.5 should balance both metrics."""
        policy = LoadBalancedPolicy(alpha=0.5)
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 200, True, "QPSK", 4, 0.2),  # Long, clear
            PathOption.from_unprotected_route(1, ["A", "C"], 100, True, "QPSK", 4, 0.8),  # Short, congested
        ]
        # Normalized: opt0 length=1.0, opt1 length=0.5
        # opt0 score = 0.5*1.0 + 0.5*0.2 = 0.6
        # opt1 score = 0.5*0.5 + 0.5*0.8 = 0.65
        action = policy.select_action(None, options, None)
        assert action == 0  # Lower combined score

    def test_rejects_invalid_alpha(self) -> None:
        """Should reject alpha outside [0, 1]."""
        with pytest.raises(ValueError, match="alpha must be in"):
            LoadBalancedPolicy(alpha=-0.1)
        with pytest.raises(ValueError, match="alpha must be in"):
            LoadBalancedPolicy(alpha=1.5)

    def test_handles_zero_max_weight(self) -> None:
        """Should handle case where all paths have weight_km=0."""
        policy = LoadBalancedPolicy(alpha=0.5)
        options = [
            PathOption.from_unprotected_route(0, ["A", "B"], 0.0, True, "QPSK", 4, 0.5),
            PathOption.from_unprotected_route(1, ["A", "C"], 0.0, True, "QPSK", 4, 0.3),
        ]
        action = policy.select_action(None, options, None)
        # Should not crash; congestion becomes deciding factor
        assert action == 1  # Lower congestion

    def test_returns_negative_one_when_empty(self) -> None:
        """Should return -1 for empty options."""
        policy = LoadBalancedPolicy()
        action = policy.select_action(None, [], None)
        assert action == -1
```

---

## Next Task

Proceed to **P5.2.e** to implement the complete heuristic_policy.py file.
