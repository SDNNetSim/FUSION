# Task ID: P5.2.a - Context Extraction: Existing Heuristic Patterns

**Sub-phase:** P5.2
**Scope:** Phase 5 - ML Control + Protection only
**Task type:** context-extraction

---

## Purpose

Extract and document existing heuristic policy patterns from the legacy codebase to inform the design of new heuristic policies implementing the ControlPolicy protocol.

---

## Context to load before running this task

- `fusion/modules/rl/policies/ksp_ff_policy.py` - KSPFFPolicy (first-fit)
- `fusion/modules/rl/policies/one_plus_one_policy.py` - OnePlusOnePolicy (protection)
- `fusion/modules/rl/utils/action_masking.py` - Action mask utilities
- `.claude/v5-final-docs/phase-5-ml-protection/P5.1_control_policy_protocol/P5.1.shared_context_existing_policies.md`

---

## Outputs

### 1. Existing Heuristic Implementations

#### KSPFFPolicy (K-Shortest Path First Fit)

```python
# From fusion/modules/rl/policies/ksp_ff_policy.py

class KSPFFPolicy(PathPolicy):
    """
    K-Shortest Path First Fit Policy.

    Selects the first feasible path from a list of K shortest paths.
    Assumes paths are pre-sorted by length (shortest first).

    This is the simplest heuristic baseline - no learning, deterministic,
    fast O(K) selection time.
    """

    def select_path(self, state: dict[str, Any], action_mask: list[bool]) -> int:
        """
        Select first feasible path.

        Args:
            state: Not used by this policy
            action_mask: Boolean list where True = feasible path

        Returns:
            Index of first True in action_mask, or -1 if all False
        """
        for i, is_valid in enumerate(action_mask):
            if is_valid:
                return i
        return -1

    def get_name(self) -> str:
        return "KSP-FF"
```

**Key Observations:**
- Does not use `state` dict at all (pure mask-based)
- Relies on paths being pre-sorted by routing algorithm
- O(K) time complexity in worst case
- Deterministic output

#### OnePlusOnePolicy (1+1 Protection)

```python
# From fusion/modules/rl/policies/one_plus_one_policy.py

class OnePlusOnePolicy(PathPolicy):
    """
    1+1 Dedicated Protection Policy.

    Selects path pairs where both primary and backup are feasible.
    Used when protection is enabled.

    Selection logic considers:
    1. Both primary and backup must be feasible
    2. Prefers shorter total path length
    3. May consider disjointness metrics
    """

    def select_path(self, state: dict[str, Any], action_mask: list[bool]) -> int:
        """
        Select best protected path pair.

        Args:
            state: Contains path metrics including backup feasibility
            action_mask: Primary path feasibility mask

        Returns:
            Index of best protected path pair, or -1 if none available
        """
        paths_info = state.get('paths', [])
        best_idx = -1
        best_score = float('inf')

        for i, (is_primary_feasible, path_info) in enumerate(zip(action_mask, paths_info)):
            if not is_primary_feasible:
                continue

            # Check backup feasibility (may be encoded in failure_mask or similar)
            backup_feasible = path_info.get('backup_feasible', True)
            if not backup_feasible:
                continue

            # Score based on total length
            primary_hops = path_info.get('path_hops', 0)
            backup_hops = path_info.get('backup_hops', 0)
            total_score = primary_hops + backup_hops

            if total_score < best_score:
                best_score = total_score
                best_idx = i

        return best_idx

    def get_name(self) -> str:
        return "1+1"
```

**Key Observations:**
- Uses `state` dict for backup path info
- Dual feasibility check (primary AND backup)
- Optimization criterion: minimize total hops
- Still deterministic

### 2. Selection Pattern Categories

#### Category A: Order-Based (First Match)
- **Example:** KSPFFPolicy
- **Logic:** Return first True in mask
- **Pros:** Fast, simple, predictable
- **Cons:** Relies on pre-sorting

#### Category B: Metric-Based (Minimum Key)
- **Example:** OnePlusOnePolicy (minimizes hops)
- **Logic:** Find minimum of some metric among feasible options
- **Pros:** Optimizes specific criterion
- **Cons:** Slightly slower (full scan)

#### Category C: Stochastic (Random)
- **Example:** Not in legacy code, but needed for exploration
- **Logic:** Random selection among feasible
- **Pros:** Useful for diversity, exploration
- **Cons:** Non-deterministic without seed

#### Category D: Composite (Weighted)
- **Example:** Not in legacy code, but needed for load balancing
- **Logic:** Combine multiple metrics with weights
- **Pros:** Balances competing objectives
- **Cons:** Requires tuning weights

### 3. Action Masking Utilities

```python
# From fusion/modules/rl/utils/action_masking.py

def apply_action_mask(logits: np.ndarray, mask: list[bool]) -> np.ndarray:
    """
    Apply action mask to logits by setting invalid actions to -inf.

    Args:
        logits: Raw model outputs (Q-values, policy logits, etc.)
        mask: Boolean mask where True = valid action

    Returns:
        Masked logits with -inf for invalid actions
    """
    masked = logits.copy()
    for i, valid in enumerate(mask):
        if not valid:
            masked[i] = float('-inf')
    return masked


def get_valid_actions(mask: list[bool]) -> list[int]:
    """
    Get list of valid action indices from mask.

    Args:
        mask: Boolean mask where True = valid action

    Returns:
        List of indices where mask is True
    """
    return [i for i, valid in enumerate(mask) if valid]


def sample_valid_action(
    mask: list[bool],
    rng: np.random.Generator | None = None,
) -> int:
    """
    Randomly sample a valid action from mask.

    Args:
        mask: Boolean mask where True = valid action
        rng: Random number generator (uses default if None)

    Returns:
        Random valid action index, or -1 if none valid
    """
    valid = get_valid_actions(mask)
    if not valid:
        return -1
    if rng is None:
        rng = np.random.default_rng()
    return rng.choice(valid)
```

### 4. Gap Analysis: Legacy vs New

| Feature | Legacy (PathPolicy) | New (ControlPolicy) |
|---------|---------------------|---------------------|
| **Feasibility source** | Separate `action_mask` list | `PathOption.is_feasible` |
| **Path metrics** | `state['paths']` dict entries | `PathOption` dataclass fields |
| **Length info** | `path_hops` (int) | `weight_km` (float, km) |
| **Congestion** | `min_residual_slots` (indirect) | `congestion` (float, 0-1) |
| **Protection** | Embedded in state dict | `both_paths_feasible` property |
| **Learning** | No method | `update()` method (no-op for heuristics) |

### 5. Policies to Implement (New)

Based on legacy patterns and gaps:

| Policy | Based On | Metric | New Capability |
|--------|----------|--------|----------------|
| `FirstFeasiblePolicy` | KSPFFPolicy | None (order) | Protocol compliance |
| `ShortestFeasiblePolicy` | - | `weight_km` | Direct km-based selection |
| `LeastCongestedPolicy` | - | `congestion` | New metric |
| `RandomFeasiblePolicy` | `sample_valid_action` | Random | Seeded RNG |
| `LoadBalancedPolicy` | - | `weight_km + congestion` | Weighted combination |

### 6. Migration Mapping

#### First-Fit Migration

```python
# Legacy
class KSPFFPolicy(PathPolicy):
    def select_path(self, state, action_mask) -> int:
        for i, valid in enumerate(action_mask):
            if valid:
                return i
        return -1

# New
class FirstFeasiblePolicy(HeuristicPolicy):
    def select_action(self, request, options, network_state) -> int:
        for opt in options:
            if opt.is_feasible:
                return opt.path_index
        return -1
```

#### Minimum-Key Migration

```python
# Legacy (hypothetical)
def select_shortest(state, action_mask) -> int:
    best_idx = -1
    best_hops = float('inf')
    for i, (valid, path) in enumerate(zip(action_mask, state['paths'])):
        if valid and path['path_hops'] < best_hops:
            best_hops = path['path_hops']
            best_idx = i
    return best_idx

# New
class ShortestFeasiblePolicy(HeuristicPolicy):
    def select_action(self, request, options, network_state) -> int:
        feasible = [opt for opt in options if opt.is_feasible]
        if not feasible:
            return -1
        return min(feasible, key=lambda o: o.weight_km).path_index
```

---

## Verification

- [ ] KSPFFPolicy implementation documented
- [ ] OnePlusOnePolicy implementation documented
- [ ] Action masking utilities documented
- [ ] Selection pattern categories identified
- [ ] Gap analysis completed
- [ ] Migration mappings provided

---

## Next Task

Proceed to **P5.2.b** to design the HeuristicPolicy base class.
