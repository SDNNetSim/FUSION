# P3.3 Shared Context: Simulation Entrypoints

## Purpose

This document summarizes the current SimulationEngine structure and entry points for SDNController calls.

## Source Files

- `fusion/core/simulation.py` (SimulationEngine class)
- `fusion/core/sdn_controller.py` (SDNController class)

## SimulationEngine Structure

```python
class SimulationEngine:
    def __init__(self, engine_props: dict):
        self.engine_props = engine_props
        self.topology = None
        self.sdn_obj = SDNController(engine_props)
        self.stats = SimStats(engine_props, sim_info)
        # Request storage
        self.reqs_dict: dict[tuple[int, float], dict] = {}
        self.reqs_status_dict: dict[tuple[int, float], dict] = {}

    def run(self, seed: int | None = None) -> int:
        """Main simulation loop."""
        ...

    def init_iter(self, iteration: int, seed: int | None = None):
        """Initialize iteration."""
        ...

    def end_iter(self, iteration: int, print_flag: bool = True) -> bool:
        """End iteration, calculate stats."""
        ...

    def handle_arrival(self, current_time: tuple[int, float]) -> None:
        """Handle request arrival event."""
        ...

    def handle_release(self, current_time: tuple[int, float]) -> None:
        """Handle request release event."""
        ...
```

## Current SDNController Call Sites

### 1. handle_arrival (lines ~337-389)

```python
def handle_arrival(self, current_time: tuple[int, float]) -> None:
    request_dict = self.reqs_dict[current_time]

    # Update SDN properties with request data
    self.sdn_obj.sdn_props.update_params(
        request_id=request_dict['req_id'],
        source=request_dict['source'],
        destination=request_dict['destination'],
        # ... more fields
    )

    # Process request through SDNController
    self.sdn_obj.handle_event(request_dict, 'arrival')

    # Update stats
    self.update_arrival_params(current_time, request_dict)

    # Optional: ML dataset logging
    if self.engine_props.get('log_dataset'):
        self._log_dataset_entry(request_dict)
```

### 2. handle_release (lines ~394-476)

```python
def handle_release(self, current_time: tuple[int, float]) -> None:
    request_dict = self.reqs_dict[current_time]
    stored_state = self.reqs_status_dict.get(current_time, {})

    # Retrieve state stored during arrival
    lightpath_ids = stored_state.get('lightpath_id_list', [])

    # Process release through SDNController
    self.sdn_obj.handle_event(request_dict, 'release')

    # Update utilization stats
    self.stats.update_utilization_dict(
        self.sdn_obj.sdn_props.lightpath_status_dict
    )
```

### 3. update_arrival_params (lines ~480-550)

```python
def update_arrival_params(
    self, current_time: tuple[int, float], request_dict: dict
) -> None:
    """Store request state and update stats after arrival."""
    # Store state for release
    self.reqs_status_dict[current_time] = {
        'was_routed': self.sdn_obj.sdn_props.was_routed,
        'lightpath_id_list': self.sdn_obj.sdn_props.lightpath_id_list.copy(),
        'path_list': self.sdn_obj.sdn_props.path_list,
        # ... more fields
    }

    # Update stats
    self.stats.iter_update(
        req_data=request_dict,
        sdn_data=self.sdn_obj.sdn_props,
        network_spectrum_dict=self.sdn_obj.sdn_props.network_spectrum_dict,
    )
```

## Key Data Flows

### Arrival Flow (Current)

```
request_dict
    |
    v
sdn_obj.sdn_props.update_params(...)
    |
    v
sdn_obj.handle_event(request_dict, 'arrival')
    |
    +-- Routing.get_route()
    +-- SpectrumAssignment.get_spectrum()
    +-- Grooming.handle_grooming() (if enabled)
    +-- SnrMeasurements.check_snr() (if enabled)
    |
    v
reqs_status_dict[current_time] = {...}  # Store for release
    |
    v
stats.iter_update(req_data, sdn_data, network_spectrum_dict)
```

### Arrival Flow (New Path)

```
request_dict
    |
    v
request = Request.from_legacy_dict(current_time, request_dict, config)
    |
    v
result = orchestrator.handle_arrival(request, network_state)
    |
    +-- GroomingPipeline.try_groom()
    +-- RoutingPipeline.find_routes()
    +-- SpectrumPipeline.find_spectrum()
    +-- SNRPipeline.validate()
    +-- SlicingPipeline.try_slice()
    |
    v
_requests[current_time] = request  # Store for release
    |
    v
stats.record_arrival(request, result, network_state)
```

## State Storage Comparison

### Legacy Path (reqs_status_dict)

```python
reqs_status_dict[current_time] = {
    'was_routed': bool,
    'lightpath_id_list': list[int],
    'path_list': list[str],
    'bandwidth_list': list[float],
    'modulation_list': list[str],
    'core_list': list[int],
    'band_list': list[str],
    'start_slot_list': list[int],
    'end_slot_list': list[int],
    'was_groomed': bool,
    'was_sliced': bool,
}
```

### New Path (_requests dict)

```python
_requests[current_time] = Request(
    request_id=int,
    source=str,
    destination=str,
    bandwidth_gbps=int,
    status=RequestStatus,
    lightpath_ids=list[int],
    block_reason=str | None,
)
```

## Configuration Access

### Legacy Path

```python
# Reads from engine_props dict
route_method = self.engine_props.get('route_method', 'k_shortest_path')
grooming_enabled = self.engine_props.get('grooming_enabled', False)
```

### New Path

```python
# Reads from SimulationConfig
route_method = self._config.route_method
grooming_enabled = self._config.grooming_enabled
```

## Topology Handling

```python
def create_topology(self) -> None:
    """Create network topology."""
    # Topology created and stored
    self.topology = create_topology_from_config(self.engine_props)

    # SDNController needs topology reference
    self.sdn_obj.sdn_props.topology = self.topology

    # For new path: NetworkState wraps topology
    # self._network_state = NetworkState(self.topology, self._config)
```

## Key Methods to Wire

| Method | Purpose | New Path Equivalent |
|--------|---------|---------------------|
| `__init__` | Initialize components | Add orchestrator creation |
| `handle_arrival` | Process arrival | Call orchestrator.handle_arrival |
| `handle_release` | Process release | Call orchestrator.handle_release |
| `update_arrival_params` | Store state + stats | Store request + call stats |
| `init_iter` | Reset per iteration | Reset network_state |
| `create_topology` | Create topology | Wrap in NetworkState |

## Environment Variable Support

```python
import os

def __init__(self, engine_props: dict):
    # Support environment variable override
    use_orch_env = os.environ.get('USE_ORCHESTRATOR', '').lower()
    use_orch_props = engine_props.get('use_orchestrator', False)

    self._use_orchestrator = (
        use_orch_env in ('1', 'true', 'yes') or use_orch_props
    )
```
