# Task ID: P3.3.d - Verify Wiring

**Sub-phase:** P3.3
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** verification-plan

## Purpose

Create tests and verification procedures to ensure both legacy and new paths work correctly.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.3_feature_flag_and_wiring/P3.3.c_wire_orchestrator.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.3_feature_flag_and_wiring/P3.3.shared_context_simulation_entrypoints.md`

## Outputs

### 1. Feature Flag Tests

```python
# fusion/tests/core/test_simulation_feature_flag.py
"""Tests for simulation engine feature flag."""

from __future__ import annotations

import os
from unittest.mock import MagicMock, patch

import pytest


class TestFeatureFlagResolution:
    """Tests for _use_orchestrator flag resolution."""

    def test_default_is_legacy_path(self) -> None:
        """Default is to use legacy SDNController path."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test'}

        with patch.object(SimulationEngine, '_init_shared_components'):
            with patch.object(SimulationEngine, '_init_legacy_path'):
                engine = SimulationEngine(engine_props)

        assert engine._use_orchestrator is False

    def test_engine_props_enables_orchestrator(self) -> None:
        """engine_props can enable orchestrator path."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': True}

        with patch.object(SimulationEngine, '_init_shared_components'):
            with patch.object(SimulationEngine, '_init_orchestrator_path'):
                engine = SimulationEngine(engine_props)

        assert engine._use_orchestrator is True

    def test_env_var_overrides_props(self) -> None:
        """Environment variable overrides engine_props."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': False}

        with patch.dict(os.environ, {'USE_ORCHESTRATOR': '1'}):
            with patch.object(SimulationEngine, '_init_shared_components'):
                with patch.object(SimulationEngine, '_init_orchestrator_path'):
                    engine = SimulationEngine(engine_props)

        assert engine._use_orchestrator is True

    def test_env_var_false_overrides_props_true(self) -> None:
        """Environment variable False overrides props True."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': True}

        with patch.dict(os.environ, {'USE_ORCHESTRATOR': '0'}):
            with patch.object(SimulationEngine, '_init_shared_components'):
                with patch.object(SimulationEngine, '_init_legacy_path'):
                    engine = SimulationEngine(engine_props)

        assert engine._use_orchestrator is False


class TestLegacyPathInit:
    """Tests for legacy path initialization."""

    def test_creates_sdn_controller(self) -> None:
        """Legacy path creates SDNController."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': False}

        with patch('fusion.core.simulation.SDNController') as MockController:
            with patch.object(SimulationEngine, '_init_shared_components'):
                engine = SimulationEngine(engine_props)

        assert engine.sdn_obj is not None
        MockController.assert_called_once()

    def test_no_orchestrator_created(self) -> None:
        """Legacy path does not create orchestrator."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': False}

        with patch('fusion.core.simulation.SDNController'):
            with patch.object(SimulationEngine, '_init_shared_components'):
                engine = SimulationEngine(engine_props)

        assert engine._orchestrator is None


class TestOrchestratorPathInit:
    """Tests for orchestrator path initialization."""

    def test_creates_orchestrator(self) -> None:
        """Orchestrator path creates SDNOrchestrator."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': True}

        with patch('fusion.core.simulation.PipelineFactory') as MockFactory:
            with patch('fusion.core.simulation.SimulationConfig'):
                with patch.object(SimulationEngine, '_init_shared_components'):
                    with patch.object(SimulationEngine, 'create_topology'):
                        engine = SimulationEngine(engine_props)
                        engine.create_topology()

        MockFactory.create_orchestrator.assert_called_once()

    def test_no_sdn_controller_created(self) -> None:
        """Orchestrator path does not create SDNController."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': True}

        with patch('fusion.core.simulation.PipelineFactory'):
            with patch('fusion.core.simulation.SimulationConfig'):
                with patch.object(SimulationEngine, '_init_shared_components'):
                    engine = SimulationEngine(engine_props)

        assert engine.sdn_obj is None
```

### 2. Handle Arrival Tests

```python
# fusion/tests/core/test_simulation_arrival.py
"""Tests for handle_arrival with both paths."""

from __future__ import annotations

from unittest.mock import MagicMock, patch

import pytest


class TestHandleArrivalLegacy:
    """Tests for handle_arrival legacy path."""

    def test_calls_sdn_controller(self) -> None:
        """Legacy path calls SDNController.handle_event."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': False}

        with patch('fusion.core.simulation.SDNController') as MockController:
            mock_sdn = MagicMock()
            MockController.return_value = mock_sdn

            with patch.object(SimulationEngine, '_init_shared_components'):
                engine = SimulationEngine(engine_props)

        current_time = (1, 0.5)
        engine.reqs_dict[current_time] = {
            'req_id': 1,
            'source': 'A',
            'destination': 'B',
            'bandwidth': 100,
            'arrive': 0.5,
            'depart': 1.5,
        }

        with patch.object(engine, 'update_arrival_params'):
            engine.handle_arrival(current_time)

        mock_sdn.handle_event.assert_called_once()

    def test_does_not_call_orchestrator(self) -> None:
        """Legacy path does not call orchestrator."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': False}

        with patch('fusion.core.simulation.SDNController'):
            with patch.object(SimulationEngine, '_init_shared_components'):
                engine = SimulationEngine(engine_props)

        # Orchestrator should be None
        assert engine._orchestrator is None


class TestHandleArrivalOrchestrator:
    """Tests for handle_arrival orchestrator path."""

    def test_calls_orchestrator(self) -> None:
        """Orchestrator path calls SDNOrchestrator.handle_arrival."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': True}

        mock_orchestrator = MagicMock()
        mock_result = MagicMock()
        mock_result.success = True
        mock_result.lightpaths_created = []
        mock_result.lightpaths_groomed = []
        mock_result.is_groomed = False
        mock_result.is_sliced = False
        mock_orchestrator.handle_arrival.return_value = mock_result

        with patch('fusion.core.simulation.PipelineFactory') as MockFactory:
            MockFactory.create_orchestrator.return_value = mock_orchestrator
            with patch('fusion.core.simulation.SimulationConfig'):
                with patch('fusion.core.simulation.NetworkState'):
                    with patch.object(SimulationEngine, '_init_shared_components'):
                        engine = SimulationEngine(engine_props)
                        engine._orchestrator = mock_orchestrator
                        engine._network_state = MagicMock()
                        engine._config = MagicMock()

        current_time = (1, 0.5)
        engine.reqs_dict[current_time] = {
            'req_id': 1,
            'source': 'A',
            'destination': 'B',
            'bandwidth': 100,
            'arrive': 0.5,
            'depart': 1.5,
        }

        with patch.object(engine, '_update_stats_from_result'):
            with patch('fusion.core.simulation.Request') as MockRequest:
                mock_request = MagicMock()
                MockRequest.from_legacy_dict.return_value = mock_request
                engine.handle_arrival(current_time)

        mock_orchestrator.handle_arrival.assert_called_once()

    def test_stores_request_for_release(self) -> None:
        """Orchestrator path stores request for later release."""
        from fusion.core.simulation import SimulationEngine

        engine_props = {'topology': 'test', 'use_orchestrator': True}

        mock_orchestrator = MagicMock()
        mock_result = MagicMock()
        mock_result.success = True
        mock_orchestrator.handle_arrival.return_value = mock_result

        with patch('fusion.core.simulation.PipelineFactory'):
            with patch('fusion.core.simulation.SimulationConfig'):
                with patch.object(SimulationEngine, '_init_shared_components'):
                    engine = SimulationEngine(engine_props)
                    engine._orchestrator = mock_orchestrator
                    engine._network_state = MagicMock()
                    engine._config = MagicMock()
                    engine._requests = {}

        current_time = (1, 0.5)
        engine.reqs_dict[current_time] = {'req_id': 1, 'source': 'A', 'destination': 'B'}

        with patch.object(engine, '_update_stats_from_result'):
            with patch('fusion.core.simulation.Request') as MockRequest:
                mock_request = MagicMock()
                MockRequest.from_legacy_dict.return_value = mock_request
                engine.handle_arrival(current_time)

        assert current_time in engine._requests
        assert engine._requests[current_time] is mock_request
```

### 3. Integration Tests

```python
# fusion/tests/integration/test_dual_path_integration.py
"""Integration tests for dual-path simulation."""

from __future__ import annotations

import os
from unittest.mock import patch

import pytest


@pytest.mark.integration
class TestDualPathIntegration:
    """Integration tests comparing both paths."""

    @pytest.fixture
    def base_config(self) -> dict:
        """Base configuration for tests."""
        return {
            'topology': 'NSFNet',
            'num_requests': 100,
            'max_iterations': 1,
            'seed': 42,
        }

    def test_legacy_path_runs(self, base_config) -> None:
        """Legacy path completes simulation."""
        from fusion.core.simulation import SimulationEngine

        base_config['use_orchestrator'] = False

        engine = SimulationEngine(base_config)
        result = engine.run(seed=42)

        assert result == 0  # Success

    @pytest.mark.skip(reason="Requires full orchestrator implementation")
    def test_orchestrator_path_runs(self, base_config) -> None:
        """Orchestrator path completes simulation."""
        from fusion.core.simulation import SimulationEngine

        base_config['use_orchestrator'] = True

        engine = SimulationEngine(base_config)
        result = engine.run(seed=42)

        assert result == 0  # Success

    @pytest.mark.skip(reason="Requires full orchestrator implementation")
    def test_both_paths_produce_similar_stats(self, base_config) -> None:
        """Both paths produce similar blocking statistics."""
        from fusion.core.simulation import SimulationEngine

        # Run legacy path
        base_config['use_orchestrator'] = False
        legacy_engine = SimulationEngine(base_config)
        legacy_engine.run(seed=42)
        legacy_blocking = legacy_engine.stats.block_mean

        # Run orchestrator path
        base_config['use_orchestrator'] = True
        orch_engine = SimulationEngine(base_config)
        orch_engine.run(seed=42)
        orch_blocking = orch_engine.stats.block_mean

        # Should be within 2% tolerance
        assert abs(legacy_blocking - orch_blocking) < 0.02
```

### 4. Verification Commands

```bash
# Run feature flag tests
pytest fusion/tests/core/test_simulation_feature_flag.py -v

# Run arrival tests
pytest fusion/tests/core/test_simulation_arrival.py -v

# Run all simulation tests with legacy path
pytest tests/ -v -k "simulation"

# Run all simulation tests with orchestrator path
USE_ORCHESTRATOR=1 pytest tests/ -v -k "simulation"

# Type checking
mypy fusion/core/simulation.py --strict

# Linting
ruff check fusion/core/simulation.py
```

### 5. Manual Verification Checklist

```markdown
## P3.3 Verification Checklist

### Feature Flag
- [ ] Default is False (legacy path)
- [ ] engine_props['use_orchestrator'] enables new path
- [ ] USE_ORCHESTRATOR env var overrides config
- [ ] Logging indicates which path

### Legacy Path (use_orchestrator=False)
- [ ] SDNController created
- [ ] handle_arrival calls sdn_obj.handle_event
- [ ] handle_release calls sdn_obj.handle_event
- [ ] Stats updated via existing methods
- [ ] All existing tests pass

### Orchestrator Path (use_orchestrator=True)
- [ ] SDNOrchestrator created via PipelineFactory
- [ ] NetworkState created and managed
- [ ] handle_arrival calls orchestrator.handle_arrival
- [ ] handle_release calls orchestrator.handle_release
- [ ] Request stored for release
- [ ] Stats updated via _update_stats_from_result

### Code Quality
- [ ] mypy --strict passes
- [ ] ruff check passes
- [ ] No breaking changes to legacy path
```

## Exit Criteria

P3.3 is complete when:

- [ ] Feature flag mechanism works correctly
- [ ] Legacy path unchanged and all tests pass
- [ ] New path wiring complete
- [ ] Both paths update stats correctly
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes
- [ ] Integration tests pass for both paths

## Next Sub-phase

After P3.3 verification completes, proceed to [P3.4 Stats Integration](../P3.4_stats_integration/P3.4.index.md).
