# Task ID: P3.3.e - Feature Flag Interactions

**Sub-phase:** P3.3
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design
**Priority:** MEDIUM (Gap Analysis)

## Purpose

Document the interactions between feature flags and their effect on pipeline execution. This specification covers valid/invalid flag combinations, flag precedence, and behavioral differences.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.3_feature_flag_and_wiring/P3.3.b_design_feature_flag.md`
- `.claude/ARCHITECTURE_REFACTOR_PLAN_V3.md` (feature flag matrix)

## Feature Flags

### Primary Flags

| Flag | Type | Default | Description |
|------|------|---------|-------------|
| `use_orchestrator` | bool | False | Use new orchestrator vs legacy SDNController |
| `grooming_enabled` | bool | False | Enable traffic grooming |
| `snr_enabled` | bool | False | Enable SNR validation |
| `slicing_enabled` | bool | False | Enable request slicing |
| `protection_enabled` | bool | False | Enable 1+1 protection |
| `congestion_check_enabled` | bool | True | Enable SNR recheck on congestion |
| `can_partially_serve` | bool | False | Accept partial service |

### Secondary Flags

| Flag | Type | Default | Description |
|------|------|---------|-------------|
| `node_disjoint_protection` | bool | False | Require node disjoint protection paths |
| `band_filtering_enabled` | bool | True | Filter by band in SNR (legacy compat) |
| `multi_band_enabled` | bool | False | Allow multi-band allocation |

## Flag Interaction Matrix

### Basic Combinations (No Protection)

| grooming | snr | slicing | Pipeline Flow |
|----------|-----|---------|---------------|
| F | F | F | Route -> Spectrum |
| T | F | F | Groom -> Route -> Spectrum |
| F | T | F | Route -> Spectrum -> SNR |
| T | T | F | Groom -> Route -> Spectrum -> SNR |
| F | F | T | Route -> Spectrum (slice on fail) |
| T | F | T | Groom -> Route -> Spectrum (slice on fail) |
| F | T | T | Route -> Spectrum -> SNR (slice on fail) |
| T | T | T | Groom -> Route -> Spectrum -> SNR (slice on fail) |

### With Protection

| protection | grooming | snr | Pipeline Flow |
|------------|----------|-----|---------------|
| T | F | F | Route(W) -> Route(P) -> Spectrum(W) -> Spectrum(P) |
| T | F | T | Route(W) -> Route(P) -> Spec(W) -> Spec(P) -> SNR(W) -> SNR(P) |
| T | T | F | Groom -> Route(W) -> Route(P) -> Spec(W) -> Spec(P) |
| T | T | T | Groom -> Route(W) -> Route(P) -> Spec -> SNR(both) |

(W) = Working path, (P) = Protection path

## Invalid Combinations

### Combination 1: slicing=True with grooming=False

```python
# WARNING: Slicing depends on same-path routing from grooming
if config.slicing_enabled and not config.grooming_enabled:
    logger.warning(
        "slicing_enabled=True without grooming_enabled may cause "
        "inefficient allocations (slices may use different paths)"
    )
```

**Reason**: Slicing works best when all slices use the same path. Without grooming, each slice may be routed independently.

**Behavior**: Allowed but warned. Slices may use different paths.

### Combination 2: protection=True with slicing=True

```python
# UNSUPPORTED: Protection + slicing is complex
if config.protection_enabled and config.slicing_enabled:
    raise ConfigurationError(
        "protection_enabled and slicing_enabled cannot both be True. "
        "Protection requires single lightpath per request."
    )
```

**Reason**: Protection requires dedicated backup for each lightpath. Sliced requests have multiple lightpaths, making protection complex.

**Behavior**: Rejected at configuration validation.

### Combination 3: congestion_check without snr

```python
# Implied dependency
if config.congestion_check_enabled and not config.snr_enabled:
    logger.info(
        "congestion_check_enabled has no effect without snr_enabled"
    )
    config.congestion_check_enabled = False
```

**Reason**: Congestion check uses SNR revalidation. Without SNR, there's nothing to recheck.

**Behavior**: Auto-disabled with info log.

## Flag Precedence

### Environment Variable > Config File > Default

```python
def resolve_flag(name: str, env_name: str, config: dict, default: bool) -> bool:
    """Resolve flag with precedence: env > config > default."""
    import os

    # 1. Environment variable (highest priority)
    env_val = os.environ.get(env_name, '').lower()
    if env_val in ('1', 'true', 'yes'):
        return True
    if env_val in ('0', 'false', 'no'):
        return False

    # 2. Config file
    if name in config:
        return bool(config[name])

    # 3. Default
    return default
```

### Example Resolution

```bash
# Config file: grooming_enabled = true
# Environment: GROOMING_ENABLED=0

# Result: grooming_enabled = False (env overrides config)
```

## Pipeline Activation Rules

### Rule 1: Pipeline Created Only if Enabled

```python
@staticmethod
def create_pipeline_set(config: SimulationConfig) -> PipelineSet:
    """Create pipelines based on enabled flags."""
    # Always created
    routing = RoutingPipeline(...)
    spectrum = SpectrumPipeline(...)

    # Conditionally created
    grooming = GroomingPipeline(...) if config.grooming_enabled else None
    snr = SNRPipeline(...) if config.snr_enabled else None
    slicing = SlicingPipeline(...) if config.slicing_enabled else None
    protection = ProtectionPipeline(...) if config.protection_enabled else None
    congestion = CongestionHandler(...) if (
        config.congestion_check_enabled and config.snr_enabled
    ) else None

    return PipelineSet(
        routing=routing,
        spectrum=spectrum,
        grooming=grooming,
        snr=snr,
        slicing=slicing,
        protection=protection,
        congestion=congestion,
    )
```

### Rule 2: Flag Check Before Pipeline Call

```python
def handle_arrival(self, request, network_state):
    # Grooming: check flag AND pipeline exists
    if self.grooming and self.config.grooming_enabled:
        groom_result = self.grooming.try_groom(...)

    # SNR: check flag AND pipeline exists
    if self.snr and self.config.snr_enabled:
        snr_result = self.snr.validate(...)
```

### Rule 3: Partial Service Requires Flag

```python
# can_partially_serve affects failure handling
if groomed_lightpaths and self.config.can_partially_serve:
    # Keep partial allocation
    return AllocationResult(success=True, is_partially_groomed=True)
else:
    # Rollback and fail
    self.grooming.rollback(...)
    return AllocationResult(success=False)
```

## Configuration Validation

### Validation Function

```python
def validate_config(config: SimulationConfig) -> list[str]:
    """Validate configuration flags for consistency."""
    errors = []
    warnings = []

    # Error: protection + slicing
    if config.protection_enabled and config.slicing_enabled:
        errors.append(
            "protection_enabled and slicing_enabled cannot both be True"
        )

    # Warning: slicing without grooming
    if config.slicing_enabled and not config.grooming_enabled:
        warnings.append(
            "slicing_enabled without grooming_enabled may cause "
            "inefficient allocations"
        )

    # Info: congestion without SNR
    if config.congestion_check_enabled and not config.snr_enabled:
        warnings.append(
            "congestion_check_enabled has no effect without snr_enabled"
        )

    # Error: node_disjoint without protection
    if config.node_disjoint_protection and not config.protection_enabled:
        errors.append(
            "node_disjoint_protection requires protection_enabled=True"
        )

    return errors, warnings
```

### Startup Validation

```python
class SimulationEngine:
    def __init__(self, engine_props: dict):
        # ... other init ...

        if self._use_orchestrator:
            errors, warnings = validate_config(self._config)

            for warning in warnings:
                logger.warning(f"Config warning: {warning}")

            if errors:
                raise ConfigurationError(
                    "Invalid configuration:\n" +
                    "\n".join(f"  - {e}" for e in errors)
                )
```

## Runtime Flag Changes

### Supported: Environment Variable Override

```bash
# Can override at runtime via environment
USE_ORCHESTRATOR=1 python -m fusion.cli.run_sim
GROOMING_ENABLED=0 python -m fusion.cli.run_sim
```

### Not Supported: Mid-Simulation Changes

```python
# Flags are resolved at SimulationEngine init
# Changing environment mid-simulation has no effect
# Requires restart to pick up changes
```

## Testing Flag Combinations

### Test Matrix

```python
@pytest.mark.parametrize("grooming,snr,slicing,protection", [
    (False, False, False, False),  # Basic
    (True, False, False, False),   # Grooming only
    (False, True, False, False),   # SNR only
    (True, True, False, False),    # Grooming + SNR
    (True, True, True, False),     # Full non-protected
    (False, True, False, True),    # Protection + SNR
    (True, True, False, True),     # Grooming + Protection + SNR
])
def test_flag_combination(grooming, snr, slicing, protection):
    """Test each valid flag combination."""
    config = SimulationConfig(
        grooming_enabled=grooming,
        snr_enabled=snr,
        slicing_enabled=slicing,
        protection_enabled=protection,
    )

    # Validate config
    errors, _ = validate_config(config)
    assert not errors

    # Run simulation
    engine = create_test_engine(config)
    result = engine.run(seed=42)
    assert result == 0
```

## Behavior Differences by Flag

### With grooming_enabled=True

- Attempts to groom onto existing lightpaths first
- May result in partial service if grooming partially succeeds
- Forces same path for remaining allocation after partial groom

### With snr_enabled=True

- Validates SNR after spectrum allocation
- May reject allocations that would otherwise succeed
- Triggers congestion check if enabled

### With slicing_enabled=True

- Falls back to slicing when single allocation fails
- May create multiple lightpaths per request
- Requires spectrum on all slices

### With protection_enabled=True

- Requires both working and protection paths
- May fail even when unprotected would succeed
- Creates two lightpaths per request

### With can_partially_serve=True

- Accepts partial grooming as success
- Does not rollback partial allocations on failure
- Affects blocking statistics

## Verification Checklist

- [ ] Flag interaction matrix documented
- [ ] Invalid combinations identified
- [ ] Config validation implemented
- [ ] Pipeline activation rules followed
- [ ] Flag precedence documented
- [ ] Test matrix covers all valid combinations
- [ ] Behavior differences documented

## Related Documents

- `P3.3.b_design_feature_flag.md` - Base feature flag design
- `P3.2.d_implement_orchestrator.md` - Orchestrator flag usage
- `P3.1.c_implement_pipeline_factory.md` - Pipeline creation
