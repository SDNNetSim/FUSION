# Task ID: P3.3.c - Wire Orchestrator into Simulation

**Sub-phase:** P3.3
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** refactor-plan

## Purpose

Wire the SDNOrchestrator into SimulationEngine with dual-path support.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.3_feature_flag_and_wiring/P3.3.b_design_feature_flag.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.3_feature_flag_and_wiring/P3.3.shared_context_simulation_entrypoints.md`
- `fusion/core/simulation.py` (handle_arrival, handle_release methods)

## Outputs

### 1. Modified handle_arrival

```python
def handle_arrival(self, current_time: tuple[int, float]) -> None:
    """
    Handle request arrival event.

    Routes to either legacy SDNController or new SDNOrchestrator
    based on the _use_orchestrator flag.
    """
    request_dict = self.reqs_dict[current_time]

    if self._use_orchestrator:
        self._handle_arrival_orchestrator(current_time, request_dict)
    else:
        self._handle_arrival_legacy(current_time, request_dict)

def _handle_arrival_legacy(
    self,
    current_time: tuple[int, float],
    request_dict: dict,
) -> None:
    """Handle arrival using legacy SDNController path."""
    # Update SDN properties with request data
    self.sdn_obj.sdn_props.update_params(
        request_id=request_dict['req_id'],
        source=request_dict['source'],
        destination=request_dict['destination'],
        bandwidth=request_dict['bandwidth'],
        arrive=request_dict['arrive'],
        depart=request_dict['depart'],
        request_type='arrival',
    )

    # Process through SDNController
    self.sdn_obj.handle_event(request_dict, 'arrival')

    # Update stats using legacy method
    self.update_arrival_params(current_time, request_dict)

    # Optional: Dataset logging
    if self.engine_props.get('log_dataset'):
        self._log_dataset_entry(request_dict)

def _handle_arrival_orchestrator(
    self,
    current_time: tuple[int, float],
    request_dict: dict,
) -> None:
    """Handle arrival using new SDNOrchestrator path."""
    from fusion.domain.request import Request

    # Convert legacy dict to Request object
    request = Request.from_legacy_dict(
        current_time, request_dict, self._config
    )

    # Process through orchestrator
    result = self._orchestrator.handle_arrival(request, self._network_state)

    # Store request for release handling
    self._requests[current_time] = request

    # Update stats using new method
    self._update_stats_from_result(request, result)

    # Optional: Dataset logging (adapted for new format)
    if self.engine_props.get('log_dataset'):
        self._log_dataset_entry_from_result(request, result)
```

### 2. Modified handle_release

```python
def handle_release(self, current_time: tuple[int, float]) -> None:
    """
    Handle request release event.

    Routes to either legacy SDNController or new SDNOrchestrator
    based on the _use_orchestrator flag.
    """
    request_dict = self.reqs_dict[current_time]

    if self._use_orchestrator:
        self._handle_release_orchestrator(current_time, request_dict)
    else:
        self._handle_release_legacy(current_time, request_dict)

def _handle_release_legacy(
    self,
    current_time: tuple[int, float],
    request_dict: dict,
) -> None:
    """Handle release using legacy SDNController path."""
    # Get stored state from arrival
    stored_state = self.reqs_status_dict.get(current_time, {})

    # Update SDN props for release
    self.sdn_obj.sdn_props.update_params(
        request_id=request_dict['req_id'],
        request_type='release',
        lightpath_id_list=stored_state.get('lightpath_id_list', []),
    )

    # Process through SDNController
    self.sdn_obj.handle_event(request_dict, 'release')

    # Update utilization stats
    self.stats.update_utilization_dict(
        self.sdn_obj.sdn_props.lightpath_status_dict
    )

def _handle_release_orchestrator(
    self,
    current_time: tuple[int, float],
    request_dict: dict,
) -> None:
    """Handle release using new SDNOrchestrator path."""
    # Get stored request from arrival
    request = self._requests.get(current_time)

    if request is None:
        # Request not found - log warning and skip
        logger.warning(f"No request found for release at {current_time}")
        return

    # Process through orchestrator
    self._orchestrator.handle_release(request, self._network_state)

    # Update utilization stats
    self.stats.update_utilization_dict(
        self._network_state.lightpath_status_dict
    )

    # Clean up stored request
    del self._requests[current_time]
```

### 3. Stats Update Method (New Path)

```python
def _update_stats_from_result(
    self,
    request: Request,
    result: AllocationResult,
) -> None:
    """
    Update stats from orchestrator allocation result.

    This method translates the new AllocationResult format into
    the stats tracking used by SimStats.
    """
    # Build request data dict for stats (compatible format)
    req_data = {
        'req_id': request.request_id,
        'source': request.source,
        'destination': request.destination,
        'bandwidth': request.bandwidth_gbps,
        'arrive': request.arrive_time,
        'depart': request.depart_time,
    }

    # Build SDN-like data for stats (compatible format)
    sdn_data = self._build_sdn_data_from_result(result)

    # Call stats update (same method as legacy path)
    self.stats.iter_update(
        req_data=req_data,
        sdn_data=sdn_data,
        network_spectrum_dict=self._network_state.network_spectrum_dict,
    )

def _build_sdn_data_from_result(
    self,
    result: AllocationResult,
) -> MagicMock:
    """Build SDN-props-like object from AllocationResult for stats."""
    from unittest.mock import MagicMock

    sdn_data = MagicMock()
    sdn_data.was_routed = result.success
    sdn_data.lightpath_id_list = (
        result.lightpaths_created + result.lightpaths_groomed
    )
    sdn_data.was_groomed = result.is_groomed
    sdn_data.was_sliced = result.is_sliced
    sdn_data.is_protected = result.is_protected

    # Set block reason if blocked
    if not result.success and result.block_reason:
        sdn_data.block_reason = result.block_reason.value
    else:
        sdn_data.block_reason = None

    return sdn_data
```

### 4. Iteration Initialization

```python
def init_iter(self, iteration: int, seed: int | None = None) -> None:
    """Initialize iteration for both paths."""
    # Shared initialization
    self._init_requests_for_iteration()

    if self._use_orchestrator:
        self._init_iter_orchestrator(iteration, seed)
    else:
        self._init_iter_legacy(iteration, seed)

def _init_iter_legacy(self, iteration: int, seed: int | None) -> None:
    """Initialize iteration for legacy path."""
    self.sdn_obj.reset_for_iteration()
    # ... existing init_iter code ...

def _init_iter_orchestrator(self, iteration: int, seed: int | None) -> None:
    """Initialize iteration for orchestrator path."""
    # Reset network state for new iteration
    self._network_state.reset()

    # Clear request storage
    self._requests.clear()

    # Reset stats (same as legacy)
    self.stats.init_iter_stats()
```

### 5. Complete Method Stubs

```python
# Add to SimulationEngine class

def _log_dataset_entry_from_result(
    self,
    request: Request,
    result: AllocationResult,
) -> None:
    """Log dataset entry from orchestrator result."""
    # Adapt existing dataset logging for new format
    if self.ml_metrics is not None:
        entry = {
            'request_id': request.request_id,
            'source': request.source,
            'destination': request.destination,
            'bandwidth': request.bandwidth_gbps,
            'success': result.success,
            'is_groomed': result.is_groomed,
            'is_sliced': result.is_sliced,
            'lightpaths': result.lightpaths_created,
        }
        self.ml_metrics.add_entry(entry)
```

### 6. Import Additions

```python
# At top of fusion/core/simulation.py

from __future__ import annotations

import logging
import os
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.core.orchestrator import SDNOrchestrator
    from fusion.core.pipeline_factory import PipelineSet
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import AllocationResult

logger = logging.getLogger(__name__)
```

## Verification Commands

```bash
# Type checking
mypy fusion/core/simulation.py --strict

# Linting
ruff check fusion/core/simulation.py

# Test legacy path (default)
pytest tests/integration/ -v

# Test new path
USE_ORCHESTRATOR=1 pytest tests/integration/ -v
```

## Important Notes

### Minimal Changes to Legacy Code

The legacy path methods (`_handle_arrival_legacy`, `_handle_release_legacy`)
should contain the **existing code** with minimal modifications. This ensures
the legacy path remains stable.

### Request Storage for Release

The new path stores `Request` objects in `_requests` dict:
- Key: `current_time` tuple
- Value: `Request` object
- Cleaned up after release

### Stats Compatibility

The `_build_sdn_data_from_result` method creates a mock object that looks
like `sdn_props` to maintain compatibility with existing `SimStats.iter_update`.

## Next Task

After implementing the wiring, proceed to `P3.3.d_verify_wiring.md`.
