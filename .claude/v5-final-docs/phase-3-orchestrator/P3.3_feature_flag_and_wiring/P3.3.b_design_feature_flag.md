# Task ID: P3.3.b - Design Feature Flag Mechanism

**Sub-phase:** P3.3
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design

## Purpose

Design the feature flag mechanism for switching between legacy SDNController and new SDNOrchestrator paths.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.3_feature_flag_and_wiring/P3.3.a_map_sdn_controller_calls.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.3_feature_flag_and_wiring/P3.3.shared_context_simulation_entrypoints.md`

## Outputs

### 1. Flag Sources (Priority Order)

```python
def _resolve_use_orchestrator(engine_props: dict) -> bool:
    """
    Resolve whether to use orchestrator from multiple sources.

    Priority (highest first):
    1. Environment variable USE_ORCHESTRATOR
    2. engine_props['use_orchestrator']
    3. Default: False
    """
    import os

    # Check environment variable (highest priority)
    env_value = os.environ.get('USE_ORCHESTRATOR', '').lower()
    if env_value in ('1', 'true', 'yes'):
        return True
    if env_value in ('0', 'false', 'no'):
        return False

    # Check engine_props
    return bool(engine_props.get('use_orchestrator', False))
```

### 2. Instance Variables Design

```python
class SimulationEngine:
    # Existing attributes
    engine_props: dict
    topology: Any
    stats: SimStats
    reqs_dict: dict[tuple[int, float], dict]
    reqs_status_dict: dict[tuple[int, float], dict]  # Legacy path

    # Feature flag
    _use_orchestrator: bool

    # Legacy path only (when _use_orchestrator=False)
    sdn_obj: SDNController | None

    # New path only (when _use_orchestrator=True)
    _config: SimulationConfig | None
    _network_state: NetworkState | None
    _orchestrator: SDNOrchestrator | None
    _requests: dict[tuple[int, float], Request]  # New path state storage
```

### 3. __init__ Implementation

```python
def __init__(self, engine_props: dict) -> None:
    """Initialize simulation engine with feature flag support."""
    self.engine_props = engine_props

    # Resolve feature flag
    self._use_orchestrator = self._resolve_use_orchestrator(engine_props)

    # Initialize path-specific components
    if self._use_orchestrator:
        self._init_orchestrator_path()
    else:
        self._init_legacy_path()

    # Initialize shared components
    self._init_shared_components()

def _resolve_use_orchestrator(self, engine_props: dict) -> bool:
    """Resolve feature flag from environment or config."""
    import os

    env_value = os.environ.get('USE_ORCHESTRATOR', '').lower()
    if env_value in ('1', 'true', 'yes'):
        return True
    if env_value in ('0', 'false', 'no'):
        return False

    return bool(engine_props.get('use_orchestrator', False))

def _init_legacy_path(self) -> None:
    """Initialize legacy SDNController path."""
    from fusion.core.sdn_controller import SDNController

    self.sdn_obj = SDNController(self.engine_props)

    # Placeholders for new path (for type checking)
    self._config = None
    self._network_state = None
    self._orchestrator = None
    self._requests = {}

def _init_orchestrator_path(self) -> None:
    """Initialize new SDNOrchestrator path."""
    from fusion.core.pipeline_factory import PipelineFactory
    from fusion.domain.config import SimulationConfig

    self._config = SimulationConfig.from_engine_props(self.engine_props)

    # Note: NetworkState needs topology, created later in create_topology
    self._network_state = None
    self._orchestrator = None

    # Request storage for new path
    self._requests: dict[tuple[int, float], Request] = {}

    # Placeholder for legacy path (for type checking)
    self.sdn_obj = None

def _init_shared_components(self) -> None:
    """Initialize components used by both paths."""
    sim_info = self._generate_sim_info()
    self.stats = SimStats(self.engine_props, sim_info)
    self.reqs_dict = {}
    self.reqs_status_dict = {}  # Used by legacy path
```

### 4. Topology Creation Integration

```python
def create_topology(self) -> None:
    """Create network topology and path-specific state."""
    # Create topology (shared)
    self.topology = self._create_topology_from_config()

    if self._use_orchestrator:
        # New path: create NetworkState and orchestrator
        from fusion.core.pipeline_factory import PipelineFactory
        from fusion.domain.network_state import NetworkState

        self._network_state = NetworkState(self.topology, self._config)
        self._orchestrator = PipelineFactory.create_orchestrator(self._config)
    else:
        # Legacy path: set topology on SDN props
        self.sdn_obj.sdn_props.topology = self.topology
        self.sdn_obj.sdn_props.network_spectrum_dict = \
            self._initialize_network_spectrum_dict()
```

### 5. Logging Integration

```python
import logging

logger = logging.getLogger(__name__)

def __init__(self, engine_props: dict) -> None:
    # ... initialization ...

    if self._use_orchestrator:
        logger.info("SimulationEngine using SDNOrchestrator path")
    else:
        logger.info("SimulationEngine using legacy SDNController path")
```

### 6. Property Access Pattern

```python
@property
def network_spectrum_dict(self) -> dict:
    """Get network spectrum dict from appropriate source."""
    if self._use_orchestrator:
        return self._network_state.network_spectrum_dict
    else:
        return self.sdn_obj.sdn_props.network_spectrum_dict

@property
def lightpath_status_dict(self) -> dict:
    """Get lightpath status dict from appropriate source."""
    if self._use_orchestrator:
        return self._network_state.lightpath_status_dict
    else:
        return self.sdn_obj.sdn_props.lightpath_status_dict
```

### 7. Configuration File Support

```ini
# config.ini
[simulation]
use_orchestrator = true
```

```python
# In config loading code
def load_config(config_file: str) -> dict:
    import configparser

    parser = configparser.ConfigParser()
    parser.read(config_file)

    engine_props = {}

    if parser.has_option('simulation', 'use_orchestrator'):
        engine_props['use_orchestrator'] = parser.getboolean(
            'simulation', 'use_orchestrator'
        )

    return engine_props
```

### 8. CLI Integration (Future)

```python
# In fusion/cli/run_sim.py
import argparse

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--use-orchestrator',
        action='store_true',
        help='Use new SDNOrchestrator path instead of legacy SDNController',
    )
    return parser.parse_args()

def main() -> None:
    args = parse_args()
    engine_props = load_config(args.config)

    if args.use_orchestrator:
        engine_props['use_orchestrator'] = True

    engine = SimulationEngine(engine_props)
    # ...
```

## Verification

After design, verify:
- [ ] Environment variable override works
- [ ] engine_props flag works
- [ ] Default is False (legacy path)
- [ ] Logging indicates which path
- [ ] Both paths can be initialized

## Next Task

After completing this design, proceed to `P3.3.c_wire_orchestrator.md`.
