# P3.2 Shared Context: Orchestrator Responsibilities

## Purpose

This document defines clear boundaries for what the SDNOrchestrator should and should not do, extracted from v4 architecture docs.

## Source Documents

- `.claude/v4-docs/architecture/orchestration.md`
- `.claude/v4-docs/migration/phase_3_orchestrator.md` (P3.2 section)
- `.claude/v4-docs/decisions/0007-orchestrator-design.md`

## Core Responsibilities

The SDNOrchestrator is responsible for:

| Responsibility | Description | Example |
|----------------|-------------|---------|
| Stage Sequencing | Deciding which pipeline to call next | `if self.grooming and self.config.grooming_enabled` |
| Feature Checking | Checking config flags before calling pipelines | `if not route_result.is_empty` |
| Result Combination | Merging groomed + allocated lightpaths | `_combine_results(groomed_lps, alloc_result)` |
| Rollback Coordination | Calling release on failure | `self.grooming.rollback(...)` |
| Error Handling | Returning appropriate BlockReason | `AllocationResult(success=False, block_reason=...)` |

## Non-Responsibilities

The SDNOrchestrator MUST NOT:

| Forbidden | Why | Where It Belongs |
|-----------|-----|------------------|
| Algorithm implementation | K-shortest-path, first-fit | Pipelines (RoutingAdapter, SpectrumAdapter) |
| Bandwidth calculations | Grooming bandwidth math | GroomingPipeline |
| SNR calculations | Signal quality formulas | SNRPipeline |
| Data structure access | Direct `cores_matrix` access | NetworkState methods |
| Value-based branching | `if modulation == "QPSK"` | Pipelines |
| State storage | Storing NetworkState | Receive per call only |

## Decision Flow Matrix

What the orchestrator CAN check:

| Check Type | Example | Allowed? |
|------------|---------|----------|
| Config flag | `self.config.grooming_enabled` | Yes |
| Pipeline availability | `self.grooming is not None` | Yes |
| Result status | `groom_result.fully_groomed` | Yes |
| Empty result | `route_result.is_empty` | Yes |

What the orchestrator CANNOT check:

| Check Type | Example | Allowed? |
|------------|---------|----------|
| Algorithm-specific | `if len(paths) > 3` | No |
| Data structure | `if cores_matrix[0][0] == 0` | No |
| Value comparison | `if snr_value < 8.5` | No |
| Modulation check | `if modulation == "16QAM"` | No |

## Pipeline Delegation Pattern

Correct orchestrator pattern:

```python
# CORRECT: Check config, delegate to pipeline
if self.grooming and self.config.grooming_enabled:
    groom_result = self.grooming.try_groom(request, network_state)
    if groom_result.fully_groomed:
        return AllocationResult(success=True, is_groomed=True)
```

Incorrect orchestrator pattern:

```python
# INCORRECT: Algorithm logic in orchestrator
if self.config.grooming_enabled:
    existing_lps = network_state.get_lightpaths_for_pair(src, dst)
    for lp in existing_lps:
        if lp.remaining_bandwidth >= request.bandwidth_gbps:  # BAD
            lp.allocate_bandwidth(request.bandwidth_gbps)     # BAD
            return AllocationResult(...)
```

## State Management Rules

### NetworkState Handling

```python
class SDNOrchestrator:
    def __init__(self, config, pipelines):
        self.config = config
        self.routing = pipelines.routing
        # ...
        # NOTE: No self._network_state = ...

    def handle_arrival(self, request, network_state):  # Received per call
        # Use network_state for this call only
        # Never store as self._network_state
        ...
```

### Why No State Storage?

1. **Thread safety**: Multiple calls could interfere
2. **Clarity**: Clear ownership of network state
3. **Testing**: Easy to inject mock state per test
4. **Consistency**: Matches pipeline protocol pattern

## Size Constraints

### File Size Limit: < 200 lines

Breakdown:
- Module docstring: ~10 lines
- Imports: ~15 lines
- Class docstring: ~20 lines
- `__init__`: ~15 lines
- `handle_arrival`: ~40 lines
- `handle_release`: ~15 lines
- Helper methods: ~4 x 20 lines = 80 lines

Total: ~195 lines (under limit)

### Method Size Limit: < 50 lines

Each method should:
- Do one thing
- Have clear entry and exit
- Delegate complex logic to helpers or pipelines

## Helper Method Guidelines

The orchestrator can have private helper methods for:

| Helper | Purpose | Example |
|--------|---------|---------|
| `_try_allocate_on_path` | Single path allocation attempt | Try spectrum + SNR |
| `_allocate_and_validate` | Create lightpath + validate | Create LP, check SNR |
| `_handle_failure` | Process allocation failure | Rollback grooming |
| `_combine_results` | Merge groomed + allocated | Build final result |

Each helper must follow the same rules:
- No algorithm logic
- No direct data structure access
- Delegate to pipelines

## Error Handling

### Block Reasons

The orchestrator uses BlockReason enum from Phase 1:

```python
class BlockReason(Enum):
    NO_ROUTE = "no_route"
    NO_SPECTRUM = "no_spectrum"
    SNR_FAILURE = "snr_failure"
    DISTANCE = "distance"
    CONGESTION = "congestion"
```

### Failure Flow

```python
def _handle_failure(self, request, groomed_lps, reason, network_state):
    # If partially groomed and can serve partial, accept it
    if groomed_lps and self.config.can_partially_serve:
        return AllocationResult(success=True, is_partially_groomed=True)

    # Otherwise, rollback and fail
    if groomed_lps:
        self.grooming.rollback(request, groomed_lps, network_state)

    request.status = RequestStatus.BLOCKED
    return AllocationResult(success=False, block_reason=reason)
```

## NetworkState Sharing Rules (V3 Compliance)

### Rule 1: Receive Per Call, Never Store

```python
# CORRECT: NetworkState passed to each method
def handle_arrival(self, request: Request, network_state: NetworkState) -> AllocationResult:
    # Use network_state for this call
    result = self.routing.find_routes(src, dst, bw, network_state)
    ...

# INCORRECT: Storing NetworkState reference
def __init__(self, config, pipelines, network_state):  # BAD
    self._network_state = network_state  # NEVER DO THIS
```

### Rule 2: Pipelines Also Receive Per Call

```python
# Every pipeline method receives network_state
groom_result = self.grooming.try_groom(request, network_state)
route_result = self.routing.find_routes(src, dst, bw, network_state)
spectrum_result = self.spectrum.find_spectrum(path, mods, bw, network_state)
snr_result = self.snr.validate(lightpath, network_state)
```

### Rule 3: No Pipeline Caching of State

```python
class RoutingPipeline:
    def find_routes(self, src, dst, bw, network_state):
        # Use network_state for this call only
        # Do NOT store: self._cached_state = network_state
        topology = network_state.topology  # Read topology
        ...
```

### Rule 4: State Mutation During Single Request

NetworkState may be mutated during a single request handling:
- `network_state.create_lightpath(...)` - Creates LP, occupies spectrum
- `network_state.release_lightpath(...)` - Releases LP, frees spectrum

These mutations are visible to subsequent pipeline calls within same request.

### Rule 5: SimulationEngine Owns Lifecycle

```python
class SimulationEngine:
    def __init__(self):
        # SimulationEngine creates and owns NetworkState
        self._network_state = NetworkState(topology, config)

    def handle_arrival(self, current_time):
        # Passes reference to orchestrator per call
        result = self._orchestrator.handle_arrival(request, self._network_state)

    def init_iter(self):
        # SimulationEngine resets state between iterations
        self._network_state.reset()
```

### Rule 6: Thread Safety (Phase 3 Scope)

Phase 3 assumes single-threaded execution:
- One request processed at a time
- No concurrent pipeline calls
- No locking required

Future phases may require thread safety considerations.

## Testing Considerations

The orchestrator should be testable with:

1. **Mock pipelines**: All pipeline calls can be mocked
2. **Mock NetworkState**: State mutations observable
3. **Config variations**: Different feature flag combinations
4. **Result verification**: AllocationResult fields correct

Example test structure:

```python
def test_handle_arrival_with_grooming():
    mock_config = MagicMock(grooming_enabled=True)
    mock_grooming = MagicMock()
    mock_grooming.try_groom.return_value = GroomingResult(fully_groomed=True)

    orchestrator = SDNOrchestrator(mock_config, mock_pipelines)
    result = orchestrator.handle_arrival(request, network_state)

    assert result.success is True
    assert result.is_groomed is True
    mock_grooming.try_groom.assert_called_once()
```
