# Task ID: P3.2.b - Design handle_arrival Method

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design

## Purpose

Design the `handle_arrival` method signature, parameters, and return value in detail.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.a_design_orchestration_flow.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.shared_context_orchestrator_responsibilities.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.e_design_allocation_result.md`

## Outputs

### 1. Method Signature

```python
def handle_arrival(
    self,
    request: Request,
    network_state: NetworkState,
    forced_path: list[str] | None = None,
) -> AllocationResult:
    """
    Handle request arrival by coordinating pipelines.

    This method orchestrates the allocation of network resources for
    an incoming request. It sequences through grooming, routing,
    spectrum assignment, SNR validation, and slicing stages as
    configured.

    Args:
        request: The incoming request to process.
            - Must have: source, destination, bandwidth_gbps, request_id
            - Will be modified: status, lightpath_ids, block_reason

        network_state: Current state of the network.
            - Passed per-call, not stored
            - Used for: topology, spectrum availability, lightpath info

        forced_path: Optional forced path from external source.
            - Used when grooming returns a forced path
            - Used when ML/RL policy specifies path
            - If provided, routing uses this path only

    Returns:
        AllocationResult containing:
            - success: Whether allocation succeeded
            - lightpaths_created: IDs of new lightpaths
            - lightpaths_groomed: IDs of lightpaths used for grooming
            - is_groomed: Whether any grooming occurred
            - is_partially_groomed: Mix of grooming and new allocation
            - is_sliced: Whether request was sliced
            - is_protected: Whether 1+1 protection applied
            - total_bandwidth_allocated_gbps: Bandwidth actually allocated
            - block_reason: Reason for failure (if success=False)

    Side Effects:
        - request.status updated to ROUTED or BLOCKED
        - request.lightpath_ids populated with allocated lightpath IDs
        - request.block_reason set if blocked
        - network_state modified (lightpaths created/released)

    Example:
        >>> result = orchestrator.handle_arrival(request, network_state)
        >>> if result.success:
        ...     print(f"Allocated {result.total_bandwidth_allocated_gbps} Gbps")
        ... else:
        ...     print(f"Blocked: {result.block_reason}")
    """
```

### 2. Input Validation

The method should validate inputs at entry:

```python
def handle_arrival(self, request, network_state, forced_path=None):
    # Validate request
    if request.source is None or request.destination is None:
        raise ValueError("Request must have source and destination")

    if request.bandwidth_gbps <= 0:
        raise ValueError("Request bandwidth must be positive")

    # Validate network_state (minimal check - not None)
    if network_state is None:
        raise ValueError("network_state cannot be None")

    # Initialize tracking variables
    groomed_lightpaths: list[int] = []
    remaining_bw = request.bandwidth_gbps

    # ... rest of method
```

### 3. Stage Implementation Outlines

#### Stage 1: Grooming

```python
# Stage 1: Grooming (if enabled)
if self.grooming and self.config.grooming_enabled:
    groom_result = self.grooming.try_groom(request, network_state)

    if groom_result.fully_groomed:
        # All bandwidth satisfied by existing lightpaths
        request.status = RequestStatus.ROUTED
        return AllocationResult(
            success=True,
            is_groomed=True,
            lightpaths_groomed=groom_result.lightpaths_used,
            total_bandwidth_allocated_gbps=request.bandwidth_gbps,
        )

    if groom_result.partially_groomed:
        # Some bandwidth from existing, need more from new
        groomed_lightpaths = groom_result.lightpaths_used
        remaining_bw = groom_result.remaining_bandwidth_gbps
        forced_path = groom_result.forced_path  # May override input
```

#### Stage 2: Routing

```python
# Stage 2: Routing
route_result = self.routing.find_routes(
    request.source,
    request.destination,
    remaining_bw,
    network_state,
    forced_path=forced_path,
)

if route_result.is_empty:
    return self._handle_failure(
        request, groomed_lightpaths, BlockReason.NO_ROUTE, network_state
    )
```

#### Stage 3: Path Iteration

```python
# Stage 3: Try each path
for path_idx, path in enumerate(route_result.paths):
    result = self._try_allocate_on_path(
        request,
        path,
        route_result.modulations[path_idx],
        route_result.weights_km[path_idx],
        remaining_bw,
        network_state,
    )

    if result is not None:
        return self._combine_results(request, groomed_lightpaths, result)
```

#### Stage 4: All Paths Failed

```python
# Stage 4: All paths failed
return self._handle_failure(
    request, groomed_lightpaths, BlockReason.NO_SPECTRUM, network_state
)
```

### 4. Complete Method (< 50 lines)

```python
def handle_arrival(
    self,
    request: Request,
    network_state: NetworkState,
    forced_path: list[str] | None = None,
) -> AllocationResult:
    """Handle request arrival by coordinating pipelines."""
    groomed_lightpaths: list[int] = []
    remaining_bw = request.bandwidth_gbps

    # Stage 1: Grooming
    if self.grooming and self.config.grooming_enabled:
        groom_result = self.grooming.try_groom(request, network_state)

        if groom_result.fully_groomed:
            request.status = RequestStatus.ROUTED
            return AllocationResult(
                success=True,
                is_groomed=True,
                lightpaths_groomed=groom_result.lightpaths_used,
                total_bandwidth_allocated_gbps=request.bandwidth_gbps,
            )

        if groom_result.partially_groomed:
            groomed_lightpaths = groom_result.lightpaths_used
            remaining_bw = groom_result.remaining_bandwidth_gbps
            forced_path = groom_result.forced_path

    # Stage 2: Routing
    route_result = self.routing.find_routes(
        request.source, request.destination,
        remaining_bw, network_state, forced_path=forced_path,
    )

    if route_result.is_empty:
        return self._handle_failure(
            request, groomed_lightpaths, BlockReason.NO_ROUTE, network_state
        )

    # Stage 3: Try each path
    for path_idx, path in enumerate(route_result.paths):
        result = self._try_allocate_on_path(
            request, path, route_result.modulations[path_idx],
            route_result.weights_km[path_idx], remaining_bw, network_state,
        )
        if result is not None:
            return self._combine_results(request, groomed_lightpaths, result)

    # Stage 4: All paths failed
    return self._handle_failure(
        request, groomed_lightpaths, BlockReason.NO_SPECTRUM, network_state
    )
```

**Line count: ~45 lines** (under 50 limit)

### 5. Return Value Cases

| Case | success | is_groomed | is_sliced | lightpaths_created | lightpaths_groomed |
|------|---------|------------|-----------|--------------------|--------------------|
| Fully groomed | True | True | False | [] | [lp_ids] |
| Partially groomed | True | True | False | [new_id] | [existing_ids] |
| New allocation | True | False | False | [lp_id] | [] |
| Sliced allocation | True | False | True | [lp_ids] | [] |
| Groomed + sliced | True | True | True | [lp_ids] | [existing_ids] |
| Blocked (no route) | False | False | False | [] | [] |
| Blocked (no spectrum) | False | False | False | [] | [] |

## Verification

After implementation, verify:
- [ ] Method signature matches design
- [ ] All stages implemented
- [ ] < 50 lines
- [ ] All return cases covered
- [ ] Side effects documented

## Next Task

After completing this design, proceed to `P3.2.c_design_helper_methods.md`.
