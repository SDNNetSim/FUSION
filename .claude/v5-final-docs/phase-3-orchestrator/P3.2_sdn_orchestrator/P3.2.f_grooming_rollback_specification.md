# Task ID: P3.2.f - Grooming Rollback Specification

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design
**Priority:** HIGH (Gap Analysis)

## Purpose

Define the complete semantics for grooming rollback when partial grooming succeeds but subsequent allocation fails. This specification ensures consistent behavior between legacy and new paths.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.d_implement_orchestrator.md`
- `.claude/ARCHITECTURE_REFACTOR_PLAN_V3.md` (grooming rollback rules)

## Rollback Trigger Conditions

### Condition 1: Partial Grooming + Failed Allocation

```
Sequence:
1. Request arrives needing 200 Gbps
2. GroomingPipeline finds existing LP with 100 Gbps spare capacity
3. Partial grooming succeeds: 100 Gbps groomed, 100 Gbps remaining
4. RoutingPipeline finds routes for remaining 100 Gbps
5. SpectrumPipeline finds spectrum
6. SNRPipeline validation FAILS

Decision Tree:
if can_partially_serve:
    # Keep partial grooming, mark as partial success
    return AllocationResult(success=True, is_partially_groomed=True)
else:
    # MUST rollback groomed bandwidth
    grooming.rollback(request, groomed_lightpaths, network_state)
    return AllocationResult(success=False, block_reason=SNR_FAILURE)
```

### Condition 2: Routing Failure After Partial Grooming

```
Sequence:
1. Partial grooming succeeds
2. RoutingPipeline returns NO_ROUTE (no paths available)
3. Same decision tree as Condition 1
```

### Condition 3: Spectrum Failure After Partial Grooming

```
Sequence:
1. Partial grooming succeeds
2. RoutingPipeline finds routes
3. SpectrumPipeline returns NO_SPECTRUM on all paths
4. Same decision tree as Condition 1
```

## Rollback Semantics

### GroomingPipeline.rollback() Contract

```python
def rollback(
    self,
    request: Request,
    groomed_lightpath_ids: list[int],
    network_state: NetworkState,
) -> None:
    """
    Rollback bandwidth allocated during partial grooming.

    MUST:
    1. For each groomed lightpath:
       - Remove request's bandwidth allocation from LP
       - Restore LP's remaining_bandwidth_gbps
       - Remove request_id from LP's request_allocations dict
    2. Clear request.lightpath_ids for groomed LPs
    3. NOT release/delete the groomed lightpaths themselves
    4. NOT affect other requests using the same lightpaths

    MUST NOT:
    1. Record utilization for rolled-back allocations
    2. Update stats for grooming success
    3. Modify lightpaths not in groomed_lightpath_ids
    """
```

### Rollback Implementation

```python
class GroomingPipeline:
    def rollback(
        self,
        request: Request,
        groomed_lightpath_ids: list[int],
        network_state: NetworkState,
    ) -> None:
        """Rollback groomed bandwidth allocations."""
        for lp_id in groomed_lightpath_ids:
            lp = network_state.get_lightpath(lp_id)
            if lp is None:
                logger.warning(f"Rollback: LP {lp_id} not found")
                continue

            # Get allocated bandwidth for this request
            allocated_bw = lp.request_allocations.get(request.request_id, 0)
            if allocated_bw == 0:
                continue

            # Restore bandwidth to lightpath
            lp.remaining_bandwidth_gbps += allocated_bw

            # Remove allocation record
            del lp.request_allocations[request.request_id]

            # Remove from request's lightpath list
            if lp_id in request.lightpath_ids:
                request.lightpath_ids.remove(lp_id)

            logger.debug(
                f"Rollback: Restored {allocated_bw} Gbps to LP {lp_id}"
            )
```

## Orchestrator Integration

### Updated _handle_failure Method

```python
def _handle_failure(
    self,
    request: Request,
    groomed_lightpaths: list[int],
    reason: BlockReason,
    network_state: NetworkState,
) -> AllocationResult:
    """Handle allocation failure with proper rollback."""
    from fusion.domain.request import RequestStatus
    from fusion.domain.results import AllocationResult

    # Check if partial service is acceptable
    if groomed_lightpaths and self.config.can_partially_serve:
        # Keep partial grooming - no rollback
        request.status = RequestStatus.ROUTED
        return AllocationResult(
            success=True,
            lightpaths_groomed=groomed_lightpaths,
            is_groomed=True,
            is_partially_groomed=True,
            total_bandwidth_allocated_gbps=self._calculate_groomed_bandwidth(
                groomed_lightpaths, request, network_state
            ),
        )

    # MUST rollback - partial service not acceptable
    if groomed_lightpaths and self.grooming:
        logger.debug(
            f"Rolling back {len(groomed_lightpaths)} groomed LPs for request {request.request_id}"
        )
        self.grooming.rollback(request, groomed_lightpaths, network_state)

    request.status = RequestStatus.BLOCKED
    request.block_reason = reason.value

    return AllocationResult(
        success=False,
        block_reason=reason,
        rollback_performed=True,  # New field for stats tracking
    )
```

## Stats Integration for Rollback

### Stats Tracking Rules

```python
# In StatsCollector

def record_arrival(self, request, result, network_state):
    """Record with rollback awareness."""
    self.total_requests += 1

    if result.success:
        self._record_successful_allocation(request, result, network_state)
    else:
        self._record_blocked_request(request, result)

        # Track rollback events
        if getattr(result, 'rollback_performed', False):
            self.grooming_rollbacks = getattr(self, 'grooming_rollbacks', 0) + 1
```

### Utilization Rules

```
CRITICAL: Utilization must NOT be recorded for rolled-back allocations.

During partial grooming:
1. Bandwidth is tentatively allocated
2. No utilization stats recorded yet
3. Only record utilization on FINAL success

On rollback:
1. Bandwidth restored to lightpath
2. No utilization entry created
3. Grooming rollback counter incremented
```

## Edge Cases

### Edge Case 1: Rollback Fails (LP Not Found)

```python
def rollback(self, request, groomed_lightpath_ids, network_state):
    for lp_id in groomed_lightpath_ids:
        lp = network_state.get_lightpath(lp_id)
        if lp is None:
            # LP was released by another request during processing
            # This should not happen in single-threaded mode
            # Log warning and continue
            logger.warning(f"Rollback: LP {lp_id} not found, skipping")
            continue
        # ... normal rollback
```

### Edge Case 2: Request Not in LP Allocations

```python
allocated_bw = lp.request_allocations.get(request.request_id, 0)
if allocated_bw == 0:
    # Request was never recorded in this LP
    # May indicate bug in grooming - log error
    logger.error(f"Rollback: Request {request.request_id} not in LP {lp_id}")
    continue
```

### Edge Case 3: Double Rollback

```python
# Guard against double rollback
if lp_id not in request.lightpath_ids:
    logger.debug(f"Rollback: LP {lp_id} already removed from request")
    continue
```

## Test Cases

```python
class TestGroomingRollback:
    """Tests for grooming rollback semantics."""

    def test_rollback_restores_bandwidth(self):
        """Rollback restores bandwidth to groomed lightpath."""
        # Setup: LP with 50 Gbps remaining
        # Groom: Request takes 50 Gbps -> LP has 0 remaining
        # Rollback: LP should have 50 Gbps again
        pass

    def test_rollback_removes_allocation_record(self):
        """Rollback removes request from LP's allocation dict."""
        pass

    def test_rollback_clears_request_lightpath_ids(self):
        """Rollback removes LP from request's lightpath_ids."""
        pass

    def test_rollback_does_not_release_lightpath(self):
        """Rollback does NOT release the lightpath itself."""
        pass

    def test_rollback_does_not_record_utilization(self):
        """Rolled-back allocations do not appear in utilization stats."""
        pass

    def test_partial_serve_skips_rollback(self):
        """When can_partially_serve=True, no rollback occurs."""
        pass

    def test_rollback_handles_missing_lp(self):
        """Rollback gracefully handles missing lightpath."""
        pass
```

## Verification Checklist

- [ ] GroomingPipeline.rollback() implemented per contract
- [ ] Orchestrator calls rollback when can_partially_serve=False
- [ ] Bandwidth correctly restored to lightpaths
- [ ] Request allocation records removed
- [ ] Utilization not recorded for rolled-back allocations
- [ ] Stats track rollback events
- [ ] Edge cases handled gracefully
- [ ] Unit tests pass
- [ ] Integration tests verify rollback behavior

## Related Documents

- `P3.2.d_implement_orchestrator.md` - Orchestrator implementation
- `P3.4.c_implement_stats_integration.md` - Stats integration
- `P3.3.c_wire_orchestrator.md` - Feature flag wiring
