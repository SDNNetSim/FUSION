# Task ID: P3.2.c - Design Helper Methods

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design

## Purpose

Design the private helper methods for SDNOrchestrator that keep `handle_arrival` concise.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.a_design_orchestration_flow.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.b_design_handle_arrival.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.shared_context_orchestrator_responsibilities.md`

## Outputs

### 1. Helper Method Overview

| Method | Purpose | Calls | Returns |
|--------|---------|-------|---------|
| `_try_allocate_on_path` | Try single path | spectrum, slicing | `AllocationResult \| None` |
| `_allocate_and_validate` | Create LP + SNR | network_state, snr | `AllocationResult \| None` |
| `_handle_failure` | Process failure | grooming (rollback) | `AllocationResult` |
| `_combine_results` | Merge results | - | `AllocationResult` |

### 2. _try_allocate_on_path

```python
def _try_allocate_on_path(
    self,
    request: Request,
    path: tuple[str, ...],
    modulations: tuple[str, ...],
    weight_km: float,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> AllocationResult | None:
    """
    Try to allocate on a single path.

    Attempts standard spectrum allocation first. If that fails and
    slicing is enabled, falls back to slicing the request.

    Args:
        request: Request being processed
        path: Candidate path (node sequence)
        modulations: Valid modulations for this path
        weight_km: Path length in km
        bandwidth_gbps: Bandwidth to allocate
        network_state: Current network state

    Returns:
        AllocationResult if allocation succeeded, None if failed

    Note:
        Does not handle grooming - that's done in handle_arrival
    """
    # Try standard allocation
    spectrum_result = self.spectrum.find_spectrum(
        path, modulations, bandwidth_gbps, network_state
    )

    if spectrum_result.is_free:
        alloc_result = self._allocate_and_validate(
            request, path, spectrum_result, weight_km,
            bandwidth_gbps, network_state,
        )
        if alloc_result is not None:
            return alloc_result

    # Fallback to slicing
    if self.slicing and self.config.slicing_enabled:
        return self.slicing.try_slice(
            request, path, modulations, bandwidth_gbps,
            network_state, self.spectrum, self.snr,
        )

    return None
```

**Line count: ~25 lines** (under 50 limit)

### 3. _allocate_and_validate

```python
def _allocate_and_validate(
    self,
    request: Request,
    path: tuple[str, ...],
    spectrum_result: SpectrumResult,
    weight_km: float,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> AllocationResult | None:
    """
    Allocate lightpath and validate SNR.

    Creates a new lightpath and optionally validates its SNR.
    If SNR validation fails, the lightpath is released.

    Args:
        request: Request being processed
        path: Path for the lightpath
        spectrum_result: Spectrum assignment result
        weight_km: Path length for SNR calculations
        bandwidth_gbps: Bandwidth to allocate
        network_state: Current network state

    Returns:
        AllocationResult if successful, None if SNR failed
    """
    # Create lightpath
    lightpath = network_state.create_lightpath(
        path=path,
        start_slot=spectrum_result.start_slot,
        end_slot=spectrum_result.end_slot,
        core=spectrum_result.core,
        band=spectrum_result.band,
        modulation=spectrum_result.modulation,
        bandwidth_gbps=bandwidth_gbps,
        path_weight_km=weight_km,
    )

    # SNR validation (if enabled)
    if self.snr and self.config.snr_enabled:
        snr_result = self.snr.validate(lightpath, network_state)
        if not snr_result.passed:
            network_state.release_lightpath(lightpath.lightpath_id)
            return None

    # Success - link request to lightpath
    lightpath.request_allocations[request.request_id] = bandwidth_gbps
    request.lightpath_ids.append(lightpath.lightpath_id)

    return AllocationResult(
        success=True,
        lightpaths_created=[lightpath.lightpath_id],
        total_bandwidth_allocated_gbps=bandwidth_gbps,
    )
```

**Line count: ~35 lines** (under 50 limit)

### 4. _handle_failure

```python
def _handle_failure(
    self,
    request: Request,
    groomed_lightpaths: list[int],
    reason: BlockReason,
    network_state: NetworkState,
) -> AllocationResult:
    """
    Handle allocation failure.

    If partial service is allowed and some grooming occurred,
    accepts the partial allocation. Otherwise, rolls back
    grooming and blocks the request.

    Args:
        request: Request that failed
        groomed_lightpaths: Lightpaths used for partial grooming
        reason: Reason for the failure
        network_state: Current network state (for rollback)

    Returns:
        AllocationResult (success or failure)
    """
    # Accept partial if allowed
    if groomed_lightpaths and self.config.can_partially_serve:
        request.status = RequestStatus.ROUTED
        return AllocationResult(
            success=True,
            lightpaths_groomed=groomed_lightpaths,
            is_groomed=True,
            is_partially_groomed=True,
        )

    # Rollback grooming if any
    if groomed_lightpaths and self.grooming:
        self.grooming.rollback(request, groomed_lightpaths, network_state)

    # Mark request as blocked
    request.status = RequestStatus.BLOCKED
    request.block_reason = reason.value

    return AllocationResult(success=False, block_reason=reason)
```

**Line count: ~25 lines** (under 50 limit)

### 5. _combine_results

```python
def _combine_results(
    self,
    request: Request,
    groomed_lightpaths: list[int],
    alloc_result: AllocationResult,
) -> AllocationResult:
    """
    Combine groomed and allocated results.

    Merges lightpaths from grooming with newly allocated
    lightpaths into a single result.

    Args:
        request: Request being processed
        groomed_lightpaths: Lightpaths from grooming stage
        alloc_result: Result from allocation stage

    Returns:
        Combined AllocationResult
    """
    request.status = RequestStatus.ROUTED

    return AllocationResult(
        success=True,
        lightpaths_created=alloc_result.lightpaths_created,
        lightpaths_groomed=groomed_lightpaths,
        is_groomed=len(groomed_lightpaths) > 0,
        is_partially_groomed=(
            len(groomed_lightpaths) > 0 and
            len(alloc_result.lightpaths_created) > 0
        ),
        is_sliced=alloc_result.is_sliced,
        total_bandwidth_allocated_gbps=alloc_result.total_bandwidth_allocated_gbps,
    )
```

**Line count: ~20 lines** (under 50 limit)

### 6. handle_release Method

```python
def handle_release(
    self,
    request: Request,
    network_state: NetworkState,
) -> None:
    """
    Handle request release.

    Releases bandwidth from all lightpaths associated with the
    request. If a lightpath has no remaining allocations, it
    is fully released.

    Args:
        request: Request to release
        network_state: Current network state

    Side Effects:
        - Lightpath bandwidth allocations updated
        - Empty lightpaths released
        - request.lightpath_ids cleared
        - request.status set to RELEASED
    """
    for lp_id in request.lightpath_ids:
        lp = network_state.get_lightpath(lp_id)
        if lp is None:
            continue

        # Release this request's bandwidth
        if request.request_id in lp.request_allocations:
            bw = lp.request_allocations.pop(request.request_id)
            lp.remaining_bandwidth_gbps += bw

        # Release lightpath if no more allocations
        if not lp.request_allocations:
            network_state.release_lightpath(lp_id)

    request.lightpath_ids.clear()
    request.status = RequestStatus.RELEASED
```

**Line count: ~20 lines** (under 50 limit)

### 7. Method Size Summary

| Method | Lines | Limit | Status |
|--------|-------|-------|--------|
| `handle_arrival` | ~45 | 50 | OK |
| `handle_release` | ~20 | 50 | OK |
| `_try_allocate_on_path` | ~25 | 50 | OK |
| `_allocate_and_validate` | ~35 | 50 | OK |
| `_handle_failure` | ~25 | 50 | OK |
| `_combine_results` | ~20 | 50 | OK |
| **Total** | ~170 | 200 | OK |

## Verification

After design, verify:
- [ ] Each method < 50 lines
- [ ] Total < 200 lines
- [ ] No algorithm logic in helpers
- [ ] Clear single responsibility per method
- [ ] All edge cases handled

## Next Task

After completing this design, proceed to `P3.2.d_implement_orchestrator.md`.
