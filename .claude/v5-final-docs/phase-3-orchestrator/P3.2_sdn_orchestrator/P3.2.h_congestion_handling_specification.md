# Task ID: P3.2.h - Congestion Handling Specification

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design
**Priority:** HIGH (Gap Analysis)

## Purpose

Define how the orchestrator handles congestion scenarios where a new allocation causes SNR degradation on existing lightpaths. This specification covers the SNR recheck flow, utilization rollback, and proper stats tracking.

## Context to load before running this task

- `.claude/ARCHITECTURE_REFACTOR_PLAN_V3.md` (congestion handling rules)
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.d_implement_orchestrator.md`

## Congestion Scenario Overview

### Problem Statement

```
Elastic Optical Networks with flexible spectrum:
- Adjacent channels cause inter-channel interference
- New allocation may increase interference on existing LPs
- Existing LPs that were passing SNR may now fail
- Must detect and handle this congestion scenario
```

### Congestion Flow

```
New LP Allocation Attempt:
1. Find path and spectrum
2. Create tentative lightpath (occupies spectrum)
3. Validate SNR for new LP
4. IF new LP passes SNR:
   a. Identify potentially affected existing LPs (neighbors)
   b. Recheck SNR for affected LPs
   c. IF any affected LP now fails:
      - ROLLBACK new allocation
      - Do NOT record utilization for rolled-back LP
      - Try next candidate path/spectrum
   d. ELSE: Commit allocation
5. ELSE: Release tentative LP, try next candidate
```

## SNR Recheck Pipeline

### CongestionHandler Interface

```python
class CongestionHandler(Protocol):
    """Handler for congestion detection and mitigation."""

    def find_affected_lightpaths(
        self,
        new_lp: Lightpath,
        network_state: NetworkState,
    ) -> list[int]:
        """
        Find existing lightpaths potentially affected by new allocation.

        Affected LPs are those sharing links with new LP and having
        adjacent or overlapping spectrum.
        """
        ...

    def recheck_affected_snr(
        self,
        affected_lp_ids: list[int],
        network_state: NetworkState,
        snr_pipeline: SNRPipeline,
    ) -> list[tuple[int, bool]]:
        """
        Recheck SNR for affected lightpaths.

        Returns:
            List of (lp_id, passed) tuples
        """
        ...
```

### Find Affected Lightpaths

```python
def find_affected_lightpaths(
    self,
    new_lp: Lightpath,
    network_state: NetworkState,
) -> list[int]:
    """Find LPs potentially affected by new allocation."""
    affected = []
    new_links = set(self._get_lightpath_links(new_lp))

    for lp in network_state.get_all_lightpaths():
        if lp.lightpath_id == new_lp.lightpath_id:
            continue

        lp_links = set(self._get_lightpath_links(lp))

        # Check for shared links
        shared_links = new_links & lp_links
        if not shared_links:
            continue

        # Check for spectrum proximity on shared links
        for link in shared_links:
            if self._is_spectrum_adjacent(new_lp, lp, link, network_state):
                affected.append(lp.lightpath_id)
                break

    return affected


def _is_spectrum_adjacent(
    self,
    new_lp: Lightpath,
    existing_lp: Lightpath,
    link: tuple[str, str],
    network_state: NetworkState,
) -> bool:
    """Check if LPs have adjacent spectrum on given link."""
    # Same core and band required for interference
    if new_lp.core != existing_lp.core or new_lp.band != existing_lp.band:
        return False

    # Check slot adjacency (within guard band distance)
    guard_band = network_state.config.guard_band_slots
    new_start, new_end = new_lp.start_slot, new_lp.end_slot
    exist_start, exist_end = existing_lp.start_slot, existing_lp.end_slot

    # Adjacent if within guard_band slots
    return (
        abs(new_start - exist_end) <= guard_band + 1 or
        abs(exist_start - new_end) <= guard_band + 1
    )
```

### Recheck Affected SNR

```python
def recheck_affected_snr(
    self,
    affected_lp_ids: list[int],
    network_state: NetworkState,
    snr_pipeline: SNRPipeline,
) -> list[tuple[int, bool]]:
    """Recheck SNR for affected lightpaths."""
    results = []

    for lp_id in affected_lp_ids:
        lp = network_state.get_lightpath(lp_id)
        if lp is None:
            continue

        snr_result = snr_pipeline.validate(lp, network_state)
        results.append((lp_id, snr_result.passed))

        if not snr_result.passed:
            logger.warning(
                f"SNR_RECHECK_FAIL: LP {lp_id} now fails SNR "
                f"(measured={snr_result.measured_snr_db:.2f}dB, "
                f"required={snr_result.required_snr_db:.2f}dB)"
            )

    return results
```

## Orchestrator Integration

### Updated _allocate_and_validate

```python
def _allocate_and_validate(
    self,
    request: Request,
    path: tuple[str, ...],
    spectrum_result: SpectrumResult,
    weight_km: float,
    bandwidth_gbps: int,
    network_state: NetworkState,
) -> AllocationResult | None:
    """Allocate lightpath with congestion handling."""
    from fusion.domain.results import AllocationResult

    # Create tentative lightpath
    lightpath = network_state.create_lightpath(
        path=path,
        start_slot=spectrum_result.start_slot,
        end_slot=spectrum_result.end_slot,
        core=spectrum_result.core,
        band=spectrum_result.band,
        modulation=spectrum_result.modulation,
        bandwidth_gbps=bandwidth_gbps,
        path_weight_km=weight_km,
    )

    # Stage 1: Validate SNR for new lightpath
    if self.snr and self.config.snr_enabled:
        snr_result = self.snr.validate(lightpath, network_state)
        if not snr_result.passed:
            network_state.release_lightpath(lightpath.lightpath_id)
            return None

    # Stage 2: Congestion check - recheck affected existing LPs
    if self.congestion_handler and self.config.congestion_check_enabled:
        congestion_result = self._handle_congestion_check(
            lightpath, network_state
        )
        if not congestion_result.passed:
            # ROLLBACK: Release new LP, do NOT record utilization
            network_state.release_lightpath(lightpath.lightpath_id)
            logger.debug(
                f"Congestion rollback for request {request.request_id}: "
                f"affected LP {congestion_result.failed_lp_id} would fail SNR"
            )
            return None

    # Success: Commit allocation
    lightpath.request_allocations[request.request_id] = bandwidth_gbps
    request.lightpath_ids.append(lightpath.lightpath_id)

    return AllocationResult(
        success=True,
        lightpaths_created=[lightpath.lightpath_id],
        total_bandwidth_allocated_gbps=bandwidth_gbps,
    )


def _handle_congestion_check(
    self,
    new_lp: Lightpath,
    network_state: NetworkState,
) -> CongestionCheckResult:
    """Perform congestion check on affected lightpaths."""
    # Find potentially affected LPs
    affected_ids = self.congestion_handler.find_affected_lightpaths(
        new_lp, network_state
    )

    if not affected_ids:
        return CongestionCheckResult(passed=True)

    # Recheck SNR for affected LPs
    recheck_results = self.congestion_handler.recheck_affected_snr(
        affected_ids, network_state, self.snr
    )

    # Check for failures
    for lp_id, passed in recheck_results:
        if not passed:
            return CongestionCheckResult(
                passed=False,
                failed_lp_id=lp_id,
            )

    return CongestionCheckResult(passed=True)
```

### CongestionCheckResult

```python
@dataclass
class CongestionCheckResult:
    """Result of congestion check."""
    passed: bool
    failed_lp_id: int | None = None
    affected_lp_count: int = 0
```

## Block Reason for Congestion

```python
class BlockReason(Enum):
    # Existing
    NO_ROUTE = "no_route"
    NO_SPECTRUM = "no_spectrum"
    SNR_FAILURE = "snr_failure"

    # Congestion-specific
    SNR_RECHECK_FAIL = "snr_recheck_fail"  # Existing LP would fail
    CONGESTION = "congestion"  # General congestion block
```

## Stats Integration

### Congestion Metrics

```python
# In StatsCollector
self.congestion_blocks: int = 0
self.snr_recheck_failures: int = 0
self.congestion_checks_performed: int = 0
self.affected_lps_checked: int = 0

def _record_blocked_request_new(self, request, result):
    # ... existing code ...

    if result.block_reason == BlockReason.SNR_RECHECK_FAIL:
        self.snr_recheck_failures += 1
        self.congestion_blocks += 1

        # Update block_reasons_dict with congestion category
        key = 'xt_threshold'  # Maps to crosstalk/interference threshold
        current = self.stats_props.block_reasons_dict.get(key) or 0
        self.stats_props.block_reasons_dict[key] = current + 1
```

### Utilization Rollback Rule

```
CRITICAL: When congestion check causes rollback:

1. DO NOT record utilization for the rolled-back lightpath
2. DO NOT count it as a successful allocation (even briefly)
3. The allocation was tentative and never committed

Implementation:
- Utilization is only recorded on RELEASE events
- If LP is released before any request completes, no utilization recorded
- Stats only track committed allocations
```

## Configuration

```python
@dataclass
class CongestionConfig:
    """Congestion handling configuration."""
    congestion_check_enabled: bool = True
    max_affected_lps_to_check: int = 10  # Limit for performance
    recheck_all_bands: bool = False  # If True, check all bands not just same
    snr_margin_db: float = 0.0  # Extra margin for recheck
```

## Edge Cases

### Edge Case 1: No Affected LPs

```python
if not affected_ids:
    # No neighbors - allocation is safe
    return CongestionCheckResult(passed=True)
```

### Edge Case 2: Affected LP Already Marginal

```
An existing LP may be close to SNR threshold.
New allocation tips it over.

Handling:
- This is expected behavior - block new allocation
- Log which LP failed and by how much
- Stats track as congestion block
```

### Edge Case 3: Multiple Affected LPs Fail

```python
# Stop at first failure - no need to check all
for lp_id, passed in recheck_results:
    if not passed:
        return CongestionCheckResult(passed=False, failed_lp_id=lp_id)
```

### Edge Case 4: Affected LP Released During Check

```python
lp = network_state.get_lightpath(lp_id)
if lp is None:
    # LP was released - skip it
    continue
```

## Test Cases

```python
class TestCongestionHandling:
    """Tests for congestion handling."""

    def test_finds_adjacent_lightpaths(self):
        """Correctly identifies LPs with adjacent spectrum."""
        pass

    def test_recheck_detects_snr_failure(self):
        """Recheck catches LPs that now fail SNR."""
        pass

    def test_rollback_on_congestion(self):
        """Allocation rolled back when congestion detected."""
        pass

    def test_no_utilization_recorded_on_rollback(self):
        """Rolled-back LP does not appear in utilization stats."""
        pass

    def test_block_reason_is_snr_recheck(self):
        """Block reason set to SNR_RECHECK_FAIL."""
        pass

    def test_next_path_tried_after_congestion(self):
        """Orchestrator tries next path after congestion rollback."""
        pass

    def test_no_affected_lps_passes(self):
        """Allocation passes when no adjacent LPs."""
        pass
```

## Performance Considerations

```
Congestion check can be expensive with many lightpaths:

1. Limit affected LP search to same core/band
2. Use spatial indexing for spectrum proximity
3. Set max_affected_lps_to_check limit
4. Cache affected LP results per link
5. Skip check if network utilization is low

Optimization in find_affected_lightpaths:
- Early exit if no shared links
- Only check LPs on same core/band
- Use link-indexed LP lookup
```

## Verification Checklist

- [ ] CongestionHandler interface implemented
- [ ] find_affected_lightpaths correctly identifies neighbors
- [ ] recheck_affected_snr validates SNR
- [ ] Rollback occurs on SNR recheck failure
- [ ] Utilization NOT recorded for rolled-back LPs
- [ ] Block reason is SNR_RECHECK_FAIL
- [ ] Stats track congestion blocks
- [ ] Next path tried after congestion failure
- [ ] Edge cases handled
- [ ] Unit tests pass
- [ ] Performance acceptable

## Related Documents

- `P3.2.f_grooming_rollback_specification.md` - Rollback patterns
- `P3.2.d_implement_orchestrator.md` - Base orchestrator
- `P3.4.c_implement_stats_integration.md` - Stats integration
