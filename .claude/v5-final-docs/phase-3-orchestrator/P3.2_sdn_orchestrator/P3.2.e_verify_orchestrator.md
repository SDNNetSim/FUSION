# Task ID: P3.2.e - Verify SDNOrchestrator

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** verification-plan

## Purpose

Create unit tests and verification procedures for `SDNOrchestrator` using mock pipelines.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.d_implement_orchestrator.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.shared_context_orchestrator_responsibilities.md`

## Outputs

### 1. Create Test File

```python
# fusion/tests/core/test_orchestrator.py
"""
Unit tests for SDNOrchestrator.

Tests use mock pipelines to verify orchestration logic without
requiring actual pipeline implementations.

Phase: P3.2 - SDN Orchestrator Creation
"""

from __future__ import annotations

from typing import TYPE_CHECKING
from unittest.mock import MagicMock, PropertyMock

import pytest

if TYPE_CHECKING:
    from fusion.core.orchestrator import SDNOrchestrator


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def mock_config() -> MagicMock:
    """Create mock SimulationConfig."""
    config = MagicMock()
    config.grooming_enabled = False
    config.snr_enabled = False
    config.slicing_enabled = False
    config.can_partially_serve = False
    return config


@pytest.fixture
def mock_pipelines() -> MagicMock:
    """Create mock PipelineSet with all pipelines."""
    from fusion.core.pipeline_factory import PipelineSet

    pipelines = MagicMock(spec=PipelineSet)
    pipelines.routing = MagicMock()
    pipelines.spectrum = MagicMock()
    pipelines.grooming = None
    pipelines.snr = None
    pipelines.slicing = None
    return pipelines


@pytest.fixture
def mock_request() -> MagicMock:
    """Create mock Request."""
    request = MagicMock()
    request.request_id = 1
    request.source = "A"
    request.destination = "C"
    request.bandwidth_gbps = 100
    request.lightpath_ids = []
    return request


@pytest.fixture
def mock_network_state() -> MagicMock:
    """Create mock NetworkState."""
    network_state = MagicMock()
    return network_state


@pytest.fixture
def orchestrator(mock_config, mock_pipelines) -> SDNOrchestrator:
    """Create orchestrator with mock dependencies."""
    from fusion.core.orchestrator import SDNOrchestrator

    return SDNOrchestrator(mock_config, mock_pipelines)


# ============================================================================
# Initialization Tests
# ============================================================================


class TestSDNOrchestratorInit:
    """Tests for SDNOrchestrator initialization."""

    def test_init_stores_config(self, mock_config, mock_pipelines) -> None:
        """Orchestrator stores config reference."""
        from fusion.core.orchestrator import SDNOrchestrator

        orchestrator = SDNOrchestrator(mock_config, mock_pipelines)

        assert orchestrator.config is mock_config

    def test_init_extracts_pipelines(self, mock_config, mock_pipelines) -> None:
        """Orchestrator extracts pipelines from PipelineSet."""
        from fusion.core.orchestrator import SDNOrchestrator

        orchestrator = SDNOrchestrator(mock_config, mock_pipelines)

        assert orchestrator.routing is mock_pipelines.routing
        assert orchestrator.spectrum is mock_pipelines.spectrum
        assert orchestrator.grooming is mock_pipelines.grooming
        assert orchestrator.snr is mock_pipelines.snr
        assert orchestrator.slicing is mock_pipelines.slicing

    def test_init_does_not_store_network_state(
        self, mock_config, mock_pipelines
    ) -> None:
        """Orchestrator does not have network_state attribute."""
        from fusion.core.orchestrator import SDNOrchestrator

        orchestrator = SDNOrchestrator(mock_config, mock_pipelines)

        assert not hasattr(orchestrator, "_network_state")
        assert not hasattr(orchestrator, "network_state")


# ============================================================================
# handle_arrival Tests - Basic Path
# ============================================================================


class TestHandleArrivalBasicPath:
    """Tests for handle_arrival basic path (no grooming, no slicing)."""

    def test_returns_success_when_allocation_succeeds(
        self, orchestrator, mock_request, mock_network_state
    ) -> None:
        """handle_arrival returns success when spectrum available."""
        # Setup route result
        route_result = MagicMock()
        route_result.is_empty = False
        route_result.paths = [("A", "B", "C")]
        route_result.modulations = [("QPSK", "8QAM")]
        route_result.weights_km = [100.0]
        orchestrator.routing.find_routes.return_value = route_result

        # Setup spectrum result
        spectrum_result = MagicMock()
        spectrum_result.is_free = True
        spectrum_result.start_slot = 0
        spectrum_result.end_slot = 10
        spectrum_result.core = 0
        spectrum_result.band = "c"
        spectrum_result.modulation = "QPSK"
        orchestrator.spectrum.find_spectrum.return_value = spectrum_result

        # Setup lightpath creation
        mock_lightpath = MagicMock()
        mock_lightpath.lightpath_id = 1
        mock_lightpath.request_allocations = {}
        mock_network_state.create_lightpath.return_value = mock_lightpath

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        assert result.success is True
        orchestrator.routing.find_routes.assert_called_once()
        orchestrator.spectrum.find_spectrum.assert_called_once()

    def test_returns_failure_when_no_routes(
        self, orchestrator, mock_request, mock_network_state
    ) -> None:
        """handle_arrival returns failure when no routes found."""
        route_result = MagicMock()
        route_result.is_empty = True
        orchestrator.routing.find_routes.return_value = route_result

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        assert result.success is False
        # block_reason should be NO_ROUTE
        assert result.block_reason is not None

    def test_returns_failure_when_no_spectrum(
        self, orchestrator, mock_request, mock_network_state
    ) -> None:
        """handle_arrival returns failure when no spectrum on any path."""
        # Setup route result with paths
        route_result = MagicMock()
        route_result.is_empty = False
        route_result.paths = [("A", "B", "C")]
        route_result.modulations = [("QPSK",)]
        route_result.weights_km = [100.0]
        orchestrator.routing.find_routes.return_value = route_result

        # Setup spectrum result - no free spectrum
        spectrum_result = MagicMock()
        spectrum_result.is_free = False
        orchestrator.spectrum.find_spectrum.return_value = spectrum_result

        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        assert result.success is False


# ============================================================================
# handle_arrival Tests - With Grooming
# ============================================================================


class TestHandleArrivalWithGrooming:
    """Tests for handle_arrival with grooming enabled."""

    def test_returns_groomed_when_fully_groomed(
        self, mock_config, mock_pipelines, mock_request, mock_network_state
    ) -> None:
        """handle_arrival returns groomed result when fully groomed."""
        from fusion.core.orchestrator import SDNOrchestrator

        mock_config.grooming_enabled = True
        mock_grooming = MagicMock()
        mock_pipelines.grooming = mock_grooming

        # Setup grooming result - fully groomed
        groom_result = MagicMock()
        groom_result.fully_groomed = True
        groom_result.lightpaths_used = [1, 2]
        mock_grooming.try_groom.return_value = groom_result

        orchestrator = SDNOrchestrator(mock_config, mock_pipelines)
        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        assert result.success is True
        assert result.is_groomed is True
        mock_grooming.try_groom.assert_called_once()
        # Should not call routing if fully groomed
        mock_pipelines.routing.find_routes.assert_not_called()

    def test_continues_to_routing_when_partially_groomed(
        self, mock_config, mock_pipelines, mock_request, mock_network_state
    ) -> None:
        """handle_arrival continues routing when partially groomed."""
        from fusion.core.orchestrator import SDNOrchestrator

        mock_config.grooming_enabled = True
        mock_grooming = MagicMock()
        mock_pipelines.grooming = mock_grooming

        # Setup grooming result - partial
        groom_result = MagicMock()
        groom_result.fully_groomed = False
        groom_result.partially_groomed = True
        groom_result.lightpaths_used = [1]
        groom_result.remaining_bandwidth_gbps = 50
        groom_result.forced_path = ["A", "B", "C"]
        mock_grooming.try_groom.return_value = groom_result

        # Setup route result
        route_result = MagicMock()
        route_result.is_empty = True
        mock_pipelines.routing.find_routes.return_value = route_result

        orchestrator = SDNOrchestrator(mock_config, mock_pipelines)
        orchestrator.handle_arrival(mock_request, mock_network_state)

        # Should call routing after partial grooming
        mock_pipelines.routing.find_routes.assert_called_once()


# ============================================================================
# handle_arrival Tests - With SNR
# ============================================================================


class TestHandleArrivalWithSNR:
    """Tests for handle_arrival with SNR validation enabled."""

    def test_releases_lightpath_when_snr_fails(
        self, mock_config, mock_pipelines, mock_request, mock_network_state
    ) -> None:
        """handle_arrival releases lightpath when SNR validation fails."""
        from fusion.core.orchestrator import SDNOrchestrator

        mock_config.snr_enabled = True
        mock_snr = MagicMock()
        mock_pipelines.snr = mock_snr

        # Setup route result
        route_result = MagicMock()
        route_result.is_empty = False
        route_result.paths = [("A", "B", "C")]
        route_result.modulations = [("QPSK",)]
        route_result.weights_km = [100.0]
        mock_pipelines.routing.find_routes.return_value = route_result

        # Setup spectrum result
        spectrum_result = MagicMock()
        spectrum_result.is_free = True
        spectrum_result.start_slot = 0
        spectrum_result.end_slot = 10
        spectrum_result.core = 0
        spectrum_result.band = "c"
        spectrum_result.modulation = "QPSK"
        mock_pipelines.spectrum.find_spectrum.return_value = spectrum_result

        # Setup lightpath creation
        mock_lightpath = MagicMock()
        mock_lightpath.lightpath_id = 1
        mock_network_state.create_lightpath.return_value = mock_lightpath

        # Setup SNR failure
        snr_result = MagicMock()
        snr_result.passed = False
        mock_snr.validate.return_value = snr_result

        orchestrator = SDNOrchestrator(mock_config, mock_pipelines)
        result = orchestrator.handle_arrival(mock_request, mock_network_state)

        # Should release lightpath after SNR failure
        mock_network_state.release_lightpath.assert_called_with(1)
        assert result.success is False


# ============================================================================
# handle_release Tests
# ============================================================================


class TestHandleRelease:
    """Tests for handle_release."""

    def test_releases_all_lightpaths(
        self, orchestrator, mock_request, mock_network_state
    ) -> None:
        """handle_release releases all request lightpaths."""
        mock_request.lightpath_ids = [1, 2, 3]
        mock_request.request_id = 1

        # Setup lightpaths
        mock_lps = []
        for lp_id in [1, 2, 3]:
            lp = MagicMock()
            lp.lightpath_id = lp_id
            lp.request_allocations = {1: 50}
            lp.remaining_bandwidth_gbps = 50
            mock_lps.append(lp)

        mock_network_state.get_lightpath.side_effect = mock_lps

        orchestrator.handle_release(mock_request, mock_network_state)

        assert mock_network_state.get_lightpath.call_count == 3
        assert mock_request.lightpath_ids == []

    def test_releases_empty_lightpaths(
        self, orchestrator, mock_request, mock_network_state
    ) -> None:
        """handle_release fully releases lightpaths with no allocations."""
        mock_request.lightpath_ids = [1]
        mock_request.request_id = 1

        mock_lp = MagicMock()
        mock_lp.lightpath_id = 1
        mock_lp.request_allocations = {1: 100}  # Only this request
        mock_lp.remaining_bandwidth_gbps = 0
        mock_network_state.get_lightpath.return_value = mock_lp

        orchestrator.handle_release(mock_request, mock_network_state)

        # Should release lightpath since no more allocations
        mock_network_state.release_lightpath.assert_called_with(1)
```

### 2. Verification Commands

```bash
# Run unit tests
pytest fusion/tests/core/test_orchestrator.py -v

# Type checking
mypy fusion/core/orchestrator.py --strict

# Linting
ruff check fusion/core/orchestrator.py

# Line count check
wc -l fusion/core/orchestrator.py
# Should be < 200

# Coverage
pytest fusion/tests/core/test_orchestrator.py \
    --cov=fusion.core.orchestrator \
    --cov-report=term-missing
```

### 3. Manual Verification Checklist

```markdown
## P3.2 Verification Checklist

### Size Constraints
- [ ] File < 200 lines total
- [ ] handle_arrival < 50 lines
- [ ] handle_release < 50 lines
- [ ] _try_allocate_on_path < 50 lines
- [ ] _allocate_and_validate < 50 lines
- [ ] _handle_failure < 50 lines
- [ ] _combine_results < 50 lines

### No Algorithm Logic
- [ ] No K-shortest-path logic
- [ ] No first-fit/best-fit logic
- [ ] No SNR calculation
- [ ] No bandwidth math (except tracking)
- [ ] No direct numpy access

### State Management
- [ ] No network_state stored as attribute
- [ ] Pipelines stored as attributes
- [ ] Config stored as attribute

### Pipeline Delegation
- [ ] Grooming delegated to GroomingPipeline
- [ ] Routing delegated to RoutingPipeline
- [ ] Spectrum delegated to SpectrumPipeline
- [ ] SNR delegated to SNRPipeline
- [ ] Slicing delegated to SlicingPipeline

### Feature Flags
- [ ] grooming_enabled checked before grooming
- [ ] snr_enabled checked before SNR
- [ ] slicing_enabled checked before slicing
- [ ] can_partially_serve checked in failure handler

### Code Quality
- [ ] mypy --strict passes
- [ ] ruff check passes
- [ ] All tests pass
- [ ] Coverage > 90%
```

### 4. Integration Smoke Test

```python
# test_orchestrator_integration.py
"""Integration smoke test for SDNOrchestrator."""


def test_orchestrator_with_mock_pipelines() -> None:
    """Verify orchestrator works with mock pipelines end-to-end."""
    from unittest.mock import MagicMock

    from fusion.core.orchestrator import SDNOrchestrator
    from fusion.core.pipeline_factory import PipelineSet

    # Create mock config
    mock_config = MagicMock()
    mock_config.grooming_enabled = False
    mock_config.snr_enabled = False
    mock_config.slicing_enabled = False

    # Create mock pipelines
    mock_routing = MagicMock()
    mock_spectrum = MagicMock()

    pipelines = PipelineSet(
        routing=mock_routing,
        spectrum=mock_spectrum,
    )

    # Create orchestrator
    orchestrator = SDNOrchestrator(mock_config, pipelines)

    # Setup successful path
    route_result = MagicMock()
    route_result.is_empty = False
    route_result.paths = [("A", "B")]
    route_result.modulations = [("QPSK",)]
    route_result.weights_km = [50.0]
    mock_routing.find_routes.return_value = route_result

    spectrum_result = MagicMock()
    spectrum_result.is_free = True
    spectrum_result.start_slot = 0
    spectrum_result.end_slot = 4
    spectrum_result.core = 0
    spectrum_result.band = "c"
    spectrum_result.modulation = "QPSK"
    mock_spectrum.find_spectrum.return_value = spectrum_result

    # Create mock request and state
    mock_request = MagicMock()
    mock_request.request_id = 1
    mock_request.source = "A"
    mock_request.destination = "B"
    mock_request.bandwidth_gbps = 100
    mock_request.lightpath_ids = []

    mock_state = MagicMock()
    mock_lp = MagicMock()
    mock_lp.lightpath_id = 1
    mock_lp.request_allocations = {}
    mock_state.create_lightpath.return_value = mock_lp

    # Run handle_arrival
    result = orchestrator.handle_arrival(mock_request, mock_state)

    assert result.success is True
    print("Integration test PASSED")


if __name__ == "__main__":
    test_orchestrator_with_mock_pipelines()
```

## Exit Criteria

P3.2 is complete when:

- [ ] `fusion/core/orchestrator.py` exists and imports successfully
- [ ] `SDNOrchestrator` passes all unit tests
- [ ] File < 200 lines
- [ ] All methods < 50 lines
- [ ] No algorithm logic in orchestrator
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes
- [ ] Test coverage > 90%

## Next Sub-phase

After P3.2 verification completes, proceed to [P3.3 Feature Flag & Wiring](../P3.3_feature_flag_and_wiring/P3.3.index.md).
