# P3.2 SDN Orchestrator - Index

## Sub-phase Overview

**Goal**: Create `SDNOrchestrator` as a thin coordination layer that routes requests through pipelines without implementing any algorithm logic.

**Output**: `fusion/core/orchestrator.py`

**Dependencies**:
- P3.1 complete (PipelineFactory, PipelineSet)
- Phase 2 complete (NetworkState, pipeline protocols)
- Phase 1 complete (Request, Lightpath, result objects)

## Objectives

1. Create `SDNOrchestrator` class with `handle_arrival` and `handle_release` methods
2. Implement pipeline coordination flow: grooming -> routing -> spectrum -> SNR -> slicing
3. Ensure orchestrator is stateless (receives NetworkState per call)
4. Enforce size limits (< 200 lines total, < 50 lines per method)

## Constraints

### What Orchestrator MUST Do
- Sequence pipeline calls based on configuration
- Check feature flags (`config.grooming_enabled`, etc.)
- Combine results from multiple stages
- Handle rollback on failure
- Return `AllocationResult` with complete information

### What Orchestrator MUST NOT Do
- Implement algorithm logic (K-shortest-path, first-fit, SNR calculation)
- Access numpy arrays directly
- Store NetworkState as instance attribute
- Contain hardcoded thresholds or magic numbers
- Make decisions based on algorithm-specific data

### Size Limits
- Total file: < 200 lines
- Each method: < 50 lines

## Micro-tasks

Execute in alphabetical order:

| Task ID | File | Type | Description |
|---------|------|------|-------------|
| P3.2.a | `P3.2.a_design_orchestration_flow.md` | design | Design pipeline sequencing flow |
| P3.2.b | `P3.2.b_design_handle_arrival.md` | design | Design handle_arrival method |
| P3.2.c | `P3.2.c_design_helper_methods.md` | design | Design private helper methods |
| P3.2.d | `P3.2.d_implement_orchestrator.md` | refactor-plan | Implement SDNOrchestrator |
| P3.2.e | `P3.2.e_verify_orchestrator.md` | verification-plan | Unit tests with mock pipelines |
| P3.2.f | `P3.2.f_grooming_rollback_specification.md` | design (gap fill) | Grooming rollback semantics |
| P3.2.g | `P3.2.g_protection_pipeline_integration.md` | design (gap fill) | 1+1 protection integration |
| P3.2.h | `P3.2.h_congestion_handling_specification.md` | design (gap fill) | SNR recheck and congestion |

## Shared Context

- `P3.2.shared_context_orchestrator_responsibilities.md` - Clear boundaries for orchestrator

## Orchestrator Overview

```python
class SDNOrchestrator:
    """Thin coordination layer for request handling."""

    def __init__(self, config: SimulationConfig, pipelines: PipelineSet):
        self.config = config
        self.routing = pipelines.routing
        self.spectrum = pipelines.spectrum
        self.grooming = pipelines.grooming
        self.snr = pipelines.snr
        self.slicing = pipelines.slicing
        # NOTE: No self._network_state

    def handle_arrival(
        self,
        request: Request,
        network_state: NetworkState,
        forced_path: list[str] | None = None,
    ) -> AllocationResult:
        """Handle request arrival by coordinating pipelines."""
        ...

    def handle_release(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> None:
        """Handle request release."""
        ...
```

## Orchestration Flow

```
handle_arrival(request, network_state)
    |
    v
[1. Grooming Stage] (if enabled)
    |-- GroomingPipeline.try_groom(request, network_state)
    |-- If fully_groomed: return success
    |-- If partially_groomed: continue with remaining bandwidth
    |
    v
[2. Routing Stage]
    |-- RoutingPipeline.find_routes(src, dst, bw, network_state)
    |-- If no routes: handle_failure
    |
    v
[3. Path Iteration] (for each candidate path)
    |
    +--[3a. Spectrum Stage]
    |   |-- SpectrumPipeline.find_spectrum(path, mods, bw, network_state)
    |   |-- If is_free: continue to allocation
    |
    +--[3b. Allocation + SNR]
    |   |-- NetworkState.create_lightpath(...)
    |   |-- SNRPipeline.validate(lightpath, network_state) (if enabled)
    |   |-- If SNR fails: release_lightpath, continue to next path
    |
    +--[3c. Slicing Fallback] (if spectrum fails)
        |-- SlicingPipeline.try_slice(request, path, ...) (if enabled)
        |
        v
[4. Result Combination]
    |-- Combine groomed lightpaths + newly created
    |-- Return AllocationResult
```

## File Structure

```
fusion/
└── core/
    └── orchestrator.py    # SDNOrchestrator class (< 200 lines)
```

## Exit Criteria

- [ ] `fusion/core/orchestrator.py` created
- [ ] `handle_arrival` correctly sequences all pipeline stages
- [ ] `handle_release` correctly releases resources
- [ ] No algorithm logic in orchestrator
- [ ] No direct numpy access
- [ ] NetworkState not stored as attribute
- [ ] File < 200 lines
- [ ] Each method < 50 lines
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes
- [ ] Unit tests with mock pipelines pass

## Next Sub-phase

After P3.2 completes, proceed to [P3.3 Feature Flag & Wiring](../P3.3_feature_flag_and_wiring/P3.3.index.md).
