# Task ID: P3.2.g - Protection Pipeline Integration

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design
**Priority:** HIGH (Gap Analysis)

## Purpose

Define how the protection pipeline integrates with the SDNOrchestrator for 1+1 disjoint path protection. This specification covers the multi-stage allocation process, atomicity requirements, and rollback semantics for protected lightpaths.

## Context to load before running this task

- `.claude/v4-docs/architecture/protection_pipeline.md`
- `.claude/v4-docs/decisions/0012-protection-pipeline.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.d_implement_orchestrator.md`

## Protection Mode Overview

### 1+1 Disjoint Path Protection

```
Request with protection_required=True:

     Source ----[Working Path]----> Destination
        |                              ^
        +------[Protection Path]-------+

Both paths:
- MUST be link-disjoint (no shared links)
- May be node-disjoint (stronger guarantee)
- Allocated spectrum independently
- Both active simultaneously (1+1 dedicated)
```

## Protection Pipeline Stages

### Stage Flow Diagram

```
protection_enabled=True
         |
         v
[1. FIND_WORKING_PATH]
         |
         v
[2. FIND_PROTECTION_PATH] --disjoint constraint--> uses working path
         |
         v
[3. VALIDATE_DISJOINTNESS]
         |
         v
[4. ALLOCATE_WORKING_SPECTRUM]
         |
         v
[5. ALLOCATE_PROTECTION_SPECTRUM]
         |
         v
[6. VALIDATE_SNR_WORKING]
         |
         v
[7. VALIDATE_SNR_PROTECTION]
         |
         v
[8. COMMIT_BOTH]
         |
         v
AllocationResult(is_protected=True)

FAILURE at any stage --> ROLLBACK all previous allocations
```

### Stage 1: Find Working Path

```python
def _find_working_path(
    self,
    request: Request,
    network_state: NetworkState,
) -> RouteResult:
    """Find primary working path."""
    return self.routing.find_routes(
        request.source,
        request.destination,
        request.bandwidth_gbps,
        network_state,
        mode=RoutingMode.WORKING,
    )
```

### Stage 2: Find Protection Path

```python
def _find_protection_path(
    self,
    request: Request,
    working_path: tuple[str, ...],
    network_state: NetworkState,
) -> RouteResult:
    """Find protection path disjoint from working path."""
    return self.routing.find_routes(
        request.source,
        request.destination,
        request.bandwidth_gbps,
        network_state,
        mode=RoutingMode.PROTECTION,
        exclude_links=self._get_path_links(working_path),
        exclude_nodes=self._get_path_intermediate_nodes(working_path)
            if self.config.node_disjoint_protection else None,
    )
```

### Stage 3: Validate Disjointness

```python
def _validate_disjointness(
    self,
    working_path: tuple[str, ...],
    protection_path: tuple[str, ...],
) -> bool:
    """Validate paths are disjoint per configuration."""
    working_links = set(self._get_path_links(working_path))
    protection_links = set(self._get_path_links(protection_path))

    # Link disjointness required
    if working_links & protection_links:
        return False

    # Node disjointness if configured
    if self.config.node_disjoint_protection:
        working_nodes = set(working_path[1:-1])  # Exclude src/dst
        protection_nodes = set(protection_path[1:-1])
        if working_nodes & protection_nodes:
            return False

    return True
```

### Stages 4-5: Allocate Spectrum

```python
def _allocate_both_spectrums(
    self,
    request: Request,
    working_path: tuple[str, ...],
    protection_path: tuple[str, ...],
    working_mod: str,
    protection_mod: str,
    network_state: NetworkState,
) -> tuple[SpectrumResult | None, SpectrumResult | None]:
    """Allocate spectrum for both paths."""
    # Working path allocation
    working_spectrum = self.spectrum.find_spectrum(
        working_path, (working_mod,), request.bandwidth_gbps, network_state
    )
    if not working_spectrum.is_free:
        return None, None

    # Tentatively allocate working (creates lightpath)
    working_lp = network_state.create_lightpath(
        path=working_path,
        start_slot=working_spectrum.start_slot,
        end_slot=working_spectrum.end_slot,
        core=working_spectrum.core,
        band=working_spectrum.band,
        modulation=working_mod,
        bandwidth_gbps=request.bandwidth_gbps,
        is_working=True,
    )

    # Protection path allocation
    protection_spectrum = self.spectrum.find_spectrum(
        protection_path, (protection_mod,), request.bandwidth_gbps, network_state
    )
    if not protection_spectrum.is_free:
        # ROLLBACK working allocation
        network_state.release_lightpath(working_lp.lightpath_id)
        return None, None

    return working_spectrum, protection_spectrum
```

### Stages 6-7: Validate SNR

```python
def _validate_both_snr(
    self,
    working_lp: Lightpath,
    protection_lp: Lightpath,
    network_state: NetworkState,
) -> tuple[bool, bool]:
    """Validate SNR for both lightpaths."""
    if not self.snr:
        return True, True

    working_snr = self.snr.validate(working_lp, network_state)
    if not working_snr.passed:
        return False, False  # Working failed, don't bother with protection

    protection_snr = self.snr.validate(protection_lp, network_state)
    return working_snr.passed, protection_snr.passed
```

### Stage 8: Commit Both

```python
def _commit_protection(
    self,
    request: Request,
    working_lp: Lightpath,
    protection_lp: Lightpath,
) -> AllocationResult:
    """Commit both lightpaths atomically."""
    # Link working and protection LPs
    working_lp.protection_lp_id = protection_lp.lightpath_id
    protection_lp.working_lp_id = working_lp.lightpath_id

    # Update request
    request.lightpath_ids.append(working_lp.lightpath_id)
    request.lightpath_ids.append(protection_lp.lightpath_id)
    request.is_protected = True

    return AllocationResult(
        success=True,
        lightpaths_created=[working_lp.lightpath_id, protection_lp.lightpath_id],
        is_protected=True,
        working_lp_id=working_lp.lightpath_id,
        protection_lp_id=protection_lp.lightpath_id,
    )
```

## Orchestrator Integration

### Handle Arrival with Protection

```python
def handle_arrival(
    self,
    request: Request,
    network_state: NetworkState,
    forced_path: list[str] | None = None,
) -> AllocationResult:
    """Handle request arrival with protection support."""
    # Check if protection required
    if self.config.protection_enabled and request.protection_required:
        return self._handle_protected_arrival(request, network_state)

    # Standard unprotected flow
    return self._handle_unprotected_arrival(request, network_state, forced_path)


def _handle_protected_arrival(
    self,
    request: Request,
    network_state: NetworkState,
) -> AllocationResult:
    """Handle arrival for protected request."""
    from fusion.domain.results import AllocationResult, BlockReason

    # Stage 1: Find working path
    working_routes = self._find_working_path(request, network_state)
    if working_routes.is_empty:
        return AllocationResult(
            success=False,
            block_reason=BlockReason.NO_ROUTE,
        )

    # Try each working path candidate
    for w_idx, working_path in enumerate(working_routes.paths):
        # Stage 2: Find protection path
        protection_routes = self._find_protection_path(
            request, working_path, network_state
        )
        if protection_routes.is_empty:
            continue  # Try next working path

        for p_idx, protection_path in enumerate(protection_routes.paths):
            # Stage 3: Validate disjointness
            if not self._validate_disjointness(working_path, protection_path):
                continue

            # Stages 4-8: Try allocation
            result = self._try_protected_allocation(
                request,
                working_path,
                protection_path,
                working_routes.modulations[w_idx],
                protection_routes.modulations[p_idx],
                working_routes.weights_km[w_idx],
                protection_routes.weights_km[p_idx],
                network_state,
            )
            if result is not None:
                return result

    # All path combinations failed
    return AllocationResult(
        success=False,
        block_reason=BlockReason.NO_DISJOINT_PATH,
    )
```

## Rollback Semantics for Protection

### Protection Rollback Rules

```python
def _rollback_protection_allocation(
    self,
    working_lp_id: int | None,
    protection_lp_id: int | None,
    network_state: NetworkState,
) -> None:
    """Rollback partial protection allocation."""
    # Rollback in reverse order
    if protection_lp_id is not None:
        network_state.release_lightpath(protection_lp_id)

    if working_lp_id is not None:
        network_state.release_lightpath(working_lp_id)
```

### Failure at Each Stage

| Stage | Failure | Rollback Action |
|-------|---------|-----------------|
| 1. Find Working | No routes | None (nothing allocated) |
| 2. Find Protection | No disjoint routes | None |
| 3. Validate Disjoint | Validation fails | None |
| 4. Allocate Working | No spectrum | None |
| 5. Allocate Protection | No spectrum | Release working LP |
| 6. Validate SNR Working | SNR fails | Release working LP |
| 7. Validate SNR Protection | SNR fails | Release both LPs |
| 8. Commit | Internal error | Release both LPs |

## Block Reasons for Protection

```python
class BlockReason(Enum):
    # Existing reasons
    NO_ROUTE = "no_route"
    NO_SPECTRUM = "no_spectrum"
    SNR_FAILURE = "snr_failure"

    # Protection-specific reasons
    NO_DISJOINT_PATH = "no_disjoint_path"
    NO_PROTECTION_SPECTRUM = "no_protection_spectrum"
    PROTECTION_SNR_FAILURE = "protection_snr_failure"
```

## Stats Integration

### Protection-Specific Metrics

```python
# In StatsCollector
self.protected_requests: int = 0
self.protection_blocks_no_disjoint: int = 0
self.protection_blocks_spectrum: int = 0
self.protection_blocks_snr: int = 0

def _record_successful_allocation_new(self, request, result, network_state):
    # ... existing code ...

    if result.is_protected:
        self.protected_requests += 1
        # Record working and protection path lengths separately
        if result.working_lp_id:
            self._record_path_metrics(result.working_lp_id, "working", network_state)
        if result.protection_lp_id:
            self._record_path_metrics(result.protection_lp_id, "protection", network_state)

def _record_blocked_request_new(self, request, result):
    # ... existing code ...

    if result.block_reason == BlockReason.NO_DISJOINT_PATH:
        self.protection_blocks_no_disjoint += 1
    elif result.block_reason == BlockReason.NO_PROTECTION_SPECTRUM:
        self.protection_blocks_spectrum += 1
    elif result.block_reason == BlockReason.PROTECTION_SNR_FAILURE:
        self.protection_blocks_snr += 1
```

## Handle Release for Protection

```python
def handle_release(
    self,
    request: Request,
    network_state: NetworkState,
) -> None:
    """Handle request release including protection."""
    from fusion.domain.request import RequestStatus

    for lp_id in request.lightpath_ids:
        lp = network_state.get_lightpath(lp_id)
        if lp is None:
            continue

        # Handle bandwidth accounting
        if request.request_id in lp.request_allocations:
            bw = lp.request_allocations.pop(request.request_id)
            lp.remaining_bandwidth_gbps += bw

        # Release if no more allocations
        if not lp.request_allocations:
            # If this is a working LP, release protection too
            if hasattr(lp, 'protection_lp_id') and lp.protection_lp_id:
                network_state.release_lightpath(lp.protection_lp_id)
            # If this is a protection LP, clear link from working
            if hasattr(lp, 'working_lp_id') and lp.working_lp_id:
                working = network_state.get_lightpath(lp.working_lp_id)
                if working:
                    working.protection_lp_id = None

            network_state.release_lightpath(lp_id)

    request.lightpath_ids.clear()
    request.status = RequestStatus.RELEASED
```

## Configuration

```python
@dataclass
class ProtectionConfig:
    """Protection-specific configuration."""
    enabled: bool = False
    node_disjoint: bool = False  # If True, require node disjointness
    max_protection_path_stretch: float = 1.5  # Max length ratio vs working
    shared_risk_link_group_aware: bool = False  # SRLG disjointness
```

## Verification Checklist

- [ ] Protection pipeline stages implemented per specification
- [ ] Disjointness validation working (link and optional node)
- [ ] Atomic allocation with proper rollback
- [ ] Working-protection LP linking
- [ ] Release handles protection correctly
- [ ] Stats track protection metrics
- [ ] Block reasons properly categorized
- [ ] Unit tests for each stage
- [ ] Integration tests for full protection flow

## Related Documents

- `P3.2.d_implement_orchestrator.md` - Base orchestrator
- `P3.2.f_grooming_rollback_specification.md` - Rollback patterns
- `.claude/v4-docs/decisions/0012-protection-pipeline.md` - ADR for protection
