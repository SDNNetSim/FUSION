# Task ID: P3.2.a - Design Orchestration Flow

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design

## Purpose

Design the high-level orchestration flow showing how requests are routed through pipelines.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.shared_context_orchestrator_responsibilities.md`
- `.claude/v4-docs/architecture/orchestration.md`
- `.claude/v4-docs/migration/phase_3_orchestrator.md` (P3.2 section)

## Outputs

### 1. Complete Orchestration Flow Diagram

```
handle_arrival(request, network_state, forced_path?)
    |
    |  Initialize: groomed_lightpaths = [], remaining_bw = request.bandwidth_gbps
    |
    v
+--[STAGE 1: GROOMING]------------------------------------------+
|                                                               |
|  if self.grooming and self.config.grooming_enabled:           |
|      |                                                        |
|      v                                                        |
|  groom_result = self.grooming.try_groom(request, network_state)
|      |                                                        |
|      +-- fully_groomed? --> return AllocationResult(success)  |
|      |                                                        |
|      +-- partially_groomed?                                   |
|          |-- groomed_lightpaths = groom_result.lightpaths     |
|          |-- remaining_bw = groom_result.remaining_bandwidth  |
|          |-- forced_path = groom_result.forced_path           |
|                                                               |
+---------------------------------------------------------------+
    |
    v
+--[STAGE 2: ROUTING]-------------------------------------------+
|                                                               |
|  route_result = self.routing.find_routes(                     |
|      request.source, request.destination,                     |
|      remaining_bw, network_state, forced_path                 |
|  )                                                            |
|      |                                                        |
|      +-- is_empty? --> return _handle_failure(NO_ROUTE)       |
|                                                               |
+---------------------------------------------------------------+
    |
    v
+--[STAGE 3: PATH ITERATION]------------------------------------+
|                                                               |
|  for path_idx, path in enumerate(route_result.paths):         |
|      |                                                        |
|      v                                                        |
|  +--[3a: TRY ALLOCATE ON PATH]-----------------------------+  |
|  |                                                         |  |
|  |  result = _try_allocate_on_path(                        |  |
|  |      request, path,                                     |  |
|  |      route_result.modulations[path_idx],                |  |
|  |      route_result.weights_km[path_idx],                 |  |
|  |      remaining_bw, network_state                        |  |
|  |  )                                                      |  |
|  |      |                                                  |  |
|  |      +-- success? --> return _combine_results(...)      |  |
|  |      |                                                  |  |
|  |      +-- None? --> continue to next path                |  |
|  |                                                         |  |
|  +---------------------------------------------------------+  |
|                                                               |
+---------------------------------------------------------------+
    |
    v
+--[STAGE 4: ALL PATHS FAILED]----------------------------------+
|                                                               |
|  return _handle_failure(request, groomed_lightpaths,          |
|                         BlockReason.NO_SPECTRUM, network_state)|
|                                                               |
+---------------------------------------------------------------+
```

### 2. _try_allocate_on_path Flow

```
_try_allocate_on_path(request, path, mods, weight, bw, network_state)
    |
    v
+--[SPECTRUM STAGE]---------------------------------------------+
|                                                               |
|  spectrum_result = self.spectrum.find_spectrum(               |
|      path, mods, bw, network_state                            |
|  )                                                            |
|      |                                                        |
|      +-- is_free?                                             |
|          |                                                    |
|          v                                                    |
|  +--[ALLOCATION + VALIDATION]------------------------------+  |
|  |                                                         |  |
|  |  alloc_result = _allocate_and_validate(                 |  |
|  |      request, path, spectrum_result,                    |  |
|  |      weight, bw, network_state                          |  |
|  |  )                                                      |  |
|  |      |                                                  |  |
|  |      +-- success? --> return alloc_result               |  |
|  |                                                         |  |
|  +---------------------------------------------------------+  |
|                                                               |
+---------------------------------------------------------------+
    |
    v
+--[SLICING FALLBACK]-------------------------------------------+
|                                                               |
|  if self.slicing and self.config.slicing_enabled:             |
|      |                                                        |
|      v                                                        |
|  return self.slicing.try_slice(                               |
|      request, path, mods, bw, network_state,                  |
|      self.spectrum, self.snr                                  |
|  )                                                            |
|                                                               |
+---------------------------------------------------------------+
    |
    v
return None  (this path failed)
```

### 3. _allocate_and_validate Flow

```
_allocate_and_validate(request, path, spectrum_result, weight, bw, network_state)
    |
    v
+--[CREATE LIGHTPATH]-------------------------------------------+
|                                                               |
|  lightpath = network_state.create_lightpath(                  |
|      path=path,                                               |
|      start_slot=spectrum_result.start_slot,                   |
|      end_slot=spectrum_result.end_slot,                       |
|      core=spectrum_result.core,                               |
|      band=spectrum_result.band,                               |
|      modulation=spectrum_result.modulation,                   |
|      bandwidth_gbps=bw,                                       |
|      path_weight_km=weight,                                   |
|  )                                                            |
|                                                               |
+---------------------------------------------------------------+
    |
    v
+--[SNR VALIDATION]---------------------------------------------+
|                                                               |
|  if self.snr and self.config.snr_enabled:                     |
|      |                                                        |
|      v                                                        |
|  snr_result = self.snr.validate(lightpath, network_state)     |
|      |                                                        |
|      +-- not passed?                                          |
|          |-- network_state.release_lightpath(lightpath.id)    |
|          |-- return None                                      |
|                                                               |
+---------------------------------------------------------------+
    |
    v
+--[FINALIZE]---------------------------------------------------+
|                                                               |
|  lightpath.request_allocations[request.request_id] = bw       |
|  request.lightpath_ids.append(lightpath.lightpath_id)         |
|                                                               |
|  return AllocationResult(                                     |
|      success=True,                                            |
|      lightpaths_created=[lightpath.lightpath_id],             |
|      total_bandwidth_allocated_gbps=bw,                       |
|  )                                                            |
|                                                               |
+---------------------------------------------------------------+
```

### 4. Scenario Matrix

| Scenario | Grooming | Routing | Spectrum | SNR | Slicing | Outcome |
|----------|----------|---------|----------|-----|---------|---------|
| A: Plain KSP | Skip | Finds paths | First path works | Skip | Skip | Success (1 LP) |
| B: Full groom | Fully groomed | Skip | Skip | Skip | Skip | Success (groomed) |
| C: Partial groom | Partially groomed | Finds path | Works | Skip | Skip | Success (mixed) |
| D: No routes | Skip | Empty | - | - | - | Blocked (NO_ROUTE) |
| E: No spectrum | Skip | Finds paths | All fail | Skip | Skip | Blocked (NO_SPECTRUM) |
| F: SNR fail | Skip | Finds paths | Works | Fails | Skip | Blocked or next path |
| G: Slicing | Skip | Finds path | Fails | - | Works | Success (sliced) |

### 5. State Transitions

```
Request State Transitions:
  PENDING --> ROUTED (on success)
  PENDING --> BLOCKED (on failure)

Lightpath State Transitions:
  (created) --> ACTIVE (on allocation)
  ACTIVE --> RELEASED (on SNR failure rollback)
```

## Verification

After design, verify:
- [ ] All pipeline stages covered
- [ ] All decision points documented
- [ ] All scenarios considered
- [ ] No algorithm logic in flow
- [ ] State transitions clear

## Next Task

After completing this design, proceed to `P3.2.b_design_handle_arrival.md`.
