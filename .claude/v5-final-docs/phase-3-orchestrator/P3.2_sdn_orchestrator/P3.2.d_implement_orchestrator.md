# Task ID: P3.2.d - Implement SDNOrchestrator

**Sub-phase:** P3.2
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** refactor-plan

## Purpose

Implement the complete `SDNOrchestrator` class based on the designs from P3.2.a-c.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.b_design_handle_arrival.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.2_sdn_orchestrator/P3.2.c_design_helper_methods.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.1_pipeline_factory/P3.1.b_design_pipeline_set.md`

## Outputs

### 1. Create fusion/core/orchestrator.py

```python
"""
SDN Orchestrator for FUSION simulation.

This module provides SDNOrchestrator, a thin coordination layer
that routes requests through pipelines without implementing
algorithm logic.

RULES:
- No algorithm logic (K-shortest-path, first-fit, SNR calculation)
- No direct numpy access
- No hardcoded slicing/grooming logic
- Receives NetworkState per call, never stores it
- < 200 lines total, < 50 lines per method

Phase: P3.2 - SDN Orchestrator Creation
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.core.pipeline_factory import PipelineSet
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import AllocationResult, BlockReason, SpectrumResult
    from fusion.interfaces.pipelines import (
        GroomingPipeline,
        RoutingPipeline,
        SlicingPipeline,
        SNRPipeline,
        SpectrumPipeline,
    )

logger = logging.getLogger(__name__)


class SDNOrchestrator:
    """
    Thin coordination layer for request handling.

    The orchestrator sequences pipeline calls and combines their
    results. It does NOT implement algorithm logic - all computation
    is delegated to pipelines.

    Attributes:
        config: Simulation configuration
        routing: Pipeline for finding candidate routes
        spectrum: Pipeline for spectrum assignment
        grooming: Pipeline for traffic grooming (optional)
        snr: Pipeline for SNR validation (optional)
        slicing: Pipeline for request slicing (optional)

    Example:
        >>> config = SimulationConfig.from_engine_props(engine_props)
        >>> pipelines = PipelineFactory.create_pipeline_set(config)
        >>> orchestrator = SDNOrchestrator(config, pipelines)
        >>> result = orchestrator.handle_arrival(request, network_state)
    """

    def __init__(
        self,
        config: SimulationConfig,
        pipelines: PipelineSet,
    ) -> None:
        """
        Initialize orchestrator with config and pipelines.

        Args:
            config: Simulation configuration
            pipelines: Container with all pipeline implementations

        Note:
            Does NOT store network_state - receives per call
        """
        self.config = config
        self.routing: RoutingPipeline = pipelines.routing
        self.spectrum: SpectrumPipeline = pipelines.spectrum
        self.grooming: GroomingPipeline | None = pipelines.grooming
        self.snr: SNRPipeline | None = pipelines.snr
        self.slicing: SlicingPipeline | None = pipelines.slicing

    def handle_arrival(
        self,
        request: Request,
        network_state: NetworkState,
        forced_path: list[str] | None = None,
    ) -> AllocationResult:
        """Handle request arrival by coordinating pipelines."""
        from fusion.domain.request import RequestStatus
        from fusion.domain.results import AllocationResult, BlockReason

        groomed_lightpaths: list[int] = []
        remaining_bw = request.bandwidth_gbps

        # Stage 1: Grooming
        if self.grooming and self.config.grooming_enabled:
            groom_result = self.grooming.try_groom(request, network_state)

            if groom_result.fully_groomed:
                request.status = RequestStatus.ROUTED
                return AllocationResult(
                    success=True,
                    is_groomed=True,
                    lightpaths_groomed=groom_result.lightpaths_used,
                    total_bandwidth_allocated_gbps=request.bandwidth_gbps,
                )

            if groom_result.partially_groomed:
                groomed_lightpaths = groom_result.lightpaths_used
                remaining_bw = groom_result.remaining_bandwidth_gbps
                forced_path = groom_result.forced_path

        # Stage 2: Routing
        route_result = self.routing.find_routes(
            request.source, request.destination,
            remaining_bw, network_state, forced_path=forced_path,
        )

        if route_result.is_empty:
            return self._handle_failure(
                request, groomed_lightpaths, BlockReason.NO_ROUTE, network_state
            )

        # Stage 3: Try each path
        for path_idx, path in enumerate(route_result.paths):
            result = self._try_allocate_on_path(
                request, path, route_result.modulations[path_idx],
                route_result.weights_km[path_idx], remaining_bw, network_state,
            )
            if result is not None:
                return self._combine_results(request, groomed_lightpaths, result)

        # Stage 4: All paths failed
        return self._handle_failure(
            request, groomed_lightpaths, BlockReason.NO_SPECTRUM, network_state
        )

    def handle_release(
        self,
        request: Request,
        network_state: NetworkState,
    ) -> None:
        """Handle request release."""
        from fusion.domain.request import RequestStatus

        for lp_id in request.lightpath_ids:
            lp = network_state.get_lightpath(lp_id)
            if lp is None:
                continue

            if request.request_id in lp.request_allocations:
                bw = lp.request_allocations.pop(request.request_id)
                lp.remaining_bandwidth_gbps += bw

            if not lp.request_allocations:
                network_state.release_lightpath(lp_id)

        request.lightpath_ids.clear()
        request.status = RequestStatus.RELEASED

    def _try_allocate_on_path(
        self,
        request: Request,
        path: tuple[str, ...],
        modulations: tuple[str, ...],
        weight_km: float,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> AllocationResult | None:
        """Try to allocate on a single path."""
        spectrum_result = self.spectrum.find_spectrum(
            path, modulations, bandwidth_gbps, network_state
        )

        if spectrum_result.is_free:
            alloc_result = self._allocate_and_validate(
                request, path, spectrum_result, weight_km,
                bandwidth_gbps, network_state,
            )
            if alloc_result is not None:
                return alloc_result

        if self.slicing and self.config.slicing_enabled:
            return self.slicing.try_slice(
                request, path, modulations, bandwidth_gbps,
                network_state, self.spectrum, self.snr,
            )

        return None

    def _allocate_and_validate(
        self,
        request: Request,
        path: tuple[str, ...],
        spectrum_result: SpectrumResult,
        weight_km: float,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> AllocationResult | None:
        """Allocate lightpath and validate SNR."""
        from fusion.domain.results import AllocationResult

        lightpath = network_state.create_lightpath(
            path=path,
            start_slot=spectrum_result.start_slot,
            end_slot=spectrum_result.end_slot,
            core=spectrum_result.core,
            band=spectrum_result.band,
            modulation=spectrum_result.modulation,
            bandwidth_gbps=bandwidth_gbps,
            path_weight_km=weight_km,
        )

        if self.snr and self.config.snr_enabled:
            snr_result = self.snr.validate(lightpath, network_state)
            if not snr_result.passed:
                network_state.release_lightpath(lightpath.lightpath_id)
                return None

        lightpath.request_allocations[request.request_id] = bandwidth_gbps
        request.lightpath_ids.append(lightpath.lightpath_id)

        return AllocationResult(
            success=True,
            lightpaths_created=[lightpath.lightpath_id],
            total_bandwidth_allocated_gbps=bandwidth_gbps,
        )

    def _handle_failure(
        self,
        request: Request,
        groomed_lightpaths: list[int],
        reason: BlockReason,
        network_state: NetworkState,
    ) -> AllocationResult:
        """Handle allocation failure."""
        from fusion.domain.request import RequestStatus
        from fusion.domain.results import AllocationResult

        if groomed_lightpaths and self.config.can_partially_serve:
            request.status = RequestStatus.ROUTED
            return AllocationResult(
                success=True,
                lightpaths_groomed=groomed_lightpaths,
                is_groomed=True,
                is_partially_groomed=True,
            )

        if groomed_lightpaths and self.grooming:
            self.grooming.rollback(request, groomed_lightpaths, network_state)

        request.status = RequestStatus.BLOCKED
        request.block_reason = reason.value

        return AllocationResult(success=False, block_reason=reason)

    def _combine_results(
        self,
        request: Request,
        groomed_lightpaths: list[int],
        alloc_result: AllocationResult,
    ) -> AllocationResult:
        """Combine groomed and allocated results."""
        from fusion.domain.request import RequestStatus
        from fusion.domain.results import AllocationResult

        request.status = RequestStatus.ROUTED

        return AllocationResult(
            success=True,
            lightpaths_created=alloc_result.lightpaths_created,
            lightpaths_groomed=groomed_lightpaths,
            is_groomed=len(groomed_lightpaths) > 0,
            is_partially_groomed=(
                len(groomed_lightpaths) > 0 and
                len(alloc_result.lightpaths_created) > 0
            ),
            is_sliced=alloc_result.is_sliced,
            total_bandwidth_allocated_gbps=alloc_result.total_bandwidth_allocated_gbps,
        )
```

### 2. Line Count Verification

```
Module docstring + imports: ~30 lines
Class docstring + __init__: ~35 lines
handle_arrival: ~45 lines
handle_release: ~18 lines
_try_allocate_on_path: ~22 lines
_allocate_and_validate: ~30 lines
_handle_failure: ~22 lines
_combine_results: ~20 lines
---
Total: ~222 lines
```

**Note**: Slightly over 200 lines. To meet the limit:
- Condense docstrings
- Move imports to top-level with TYPE_CHECKING
- Reduce whitespace

### 3. Verification Commands

```bash
# Type checking
mypy fusion/core/orchestrator.py --strict

# Linting
ruff check fusion/core/orchestrator.py

# Line count
wc -l fusion/core/orchestrator.py

# Smoke test
python -c "
from fusion.core.orchestrator import SDNOrchestrator
print('SDNOrchestrator imported successfully')
"
```

## Important Notes

### Import Strategy

All domain imports are inside methods to avoid circular dependencies:
```python
def handle_arrival(self, ...):
    from fusion.domain.results import AllocationResult, BlockReason
    ...
```

### No State Storage

The orchestrator does not store network_state:
```python
def __init__(self, config, pipelines):
    # NOTE: No self._network_state = ...
```

### Pipeline References

Pipelines are extracted from PipelineSet for direct access:
```python
self.routing = pipelines.routing
self.spectrum = pipelines.spectrum
# etc.
```

## Next Task

After implementing the orchestrator, proceed to `P3.2.e_verify_orchestrator.md`.
