# Task ID: P3.4.a - Extract Current Stats Behavior

**Sub-phase:** P3.4
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** context-extraction

## Purpose

Document the current stats collection behavior to ensure the new path produces equivalent statistics.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.4_stats_integration/P3.4.shared_context_stats_requirements.md`
- `fusion/core/metrics.py` (SimStats class)
- `fusion/core/simulation.py` (update_arrival_params method)

## Outputs

### 1. iter_update Call Site Analysis

```markdown
## Where iter_update is Called

### Location: SimulationEngine.update_arrival_params()
Line: ~XXX

```python
def update_arrival_params(
    self, current_time: tuple[int, float], request_dict: dict
) -> None:
    # Store state for release
    self.reqs_status_dict[current_time] = {
        'was_routed': self.sdn_obj.sdn_props.was_routed,
        # ... more fields
    }

    # Call stats update
    self.stats.iter_update(
        req_data=request_dict,
        sdn_data=self.sdn_obj.sdn_props,
        network_spectrum_dict=self.sdn_obj.sdn_props.network_spectrum_dict,
    )
```

### Parameters Passed

| Parameter | Type | Contents |
|-----------|------|----------|
| `req_data` | dict | Request info: req_id, source, dest, bandwidth, etc. |
| `sdn_data` | SDNProps | Allocation results: was_routed, path_list, etc. |
| `network_spectrum_dict` | dict | Current network state |
```

### 2. iter_update Internal Logic

```markdown
## iter_update Method Breakdown

### Entry Point
```python
def iter_update(self, req_data, sdn_data, network_spectrum_dict):
    self.total_requests += 1
```

### Blocking Check
```python
    if not sdn_data.was_routed:
        self.blocked_requests += 1
        self._update_block_reason(sdn_data)
        self._update_bandwidth_blocking(req_data, blocked=True)
        return
```

### Successful Request Processing
```python
    # Path metrics
    if sdn_data.path_list:
        hops = len(sdn_data.path_list) - 1
        self.stats_props.hops_list.append(hops)

        length = self._calculate_path_length(sdn_data.path_list)
        self.stats_props.lengths_list.append(length)

    # Resource metrics
    self.stats_props.transponders_list.append(
        sdn_data.number_of_transponders or 1
    )

    # Modulation tracking
    for mod in sdn_data.modulation_list:
        self._increment_modulation_count(mod)

    # Quality metrics (if available)
    if sdn_data.snr_list:
        self.stats_props.snr_list.extend(sdn_data.snr_list)
    if sdn_data.crosstalk_list:
        self.stats_props.crosstalk_list.extend(sdn_data.crosstalk_list)

    # Bandwidth tracking
    self._update_bandwidth_blocking(req_data, blocked=False)

    # Route time
    if sdn_data.route_time:
        self.stats_props.route_times_list.append(sdn_data.route_time)
```

### Snapshot Logic
```python
    # Take periodic snapshots
    if self._should_take_snapshot():
        self._take_snapshot(network_spectrum_dict)
```
```

### 3. SDNProps Fields Read by Stats

```markdown
## SDNProps Fields Used by iter_update

| Field | Type | Purpose | Required? |
|-------|------|---------|-----------|
| `was_routed` | bool | Determine success/block | Yes |
| `path_list` | list[str] | Calculate hops/length | If success |
| `modulation_list` | list[str] | Track modulation usage | If success |
| `bandwidth_list` | list[float] | Track bandwidth | If success |
| `snr_list` | list[float] | Track SNR values | Optional |
| `crosstalk_list` | list[float] | Track crosstalk | Optional |
| `number_of_transponders` | int | Track resources | If success |
| `route_time` | float | Track decision time | Optional |
| `was_groomed` | bool | Track grooming | Optional |
| `was_sliced` | bool | Track slicing | Optional |
| `is_protected` | bool | Track protection | Optional |
| `core_list` | list[int] | Track core usage | Optional |
| `band_list` | list[str] | Track band usage | Optional |
| `start_slot_list` | list[int] | Track spectrum | Optional |
| `end_slot_list` | list[int] | Track spectrum | Optional |
```

### 4. Block Reason Mapping

```markdown
## Block Reason Determination

### Current Logic
```python
def _update_block_reason(self, sdn_data):
    # Determine reason from various indicators
    if sdn_data.block_reason == 'distance':
        self.stats_props.block_reasons_dict['distance'] = \
            (self.stats_props.block_reasons_dict.get('distance') or 0) + 1

    elif sdn_data.block_reason == 'congestion':
        self.stats_props.block_reasons_dict['congestion'] = \
            (self.stats_props.block_reasons_dict.get('congestion') or 0) + 1

    elif sdn_data.block_reason == 'xt_threshold':
        self.stats_props.block_reasons_dict['xt_threshold'] = \
            (self.stats_props.block_reasons_dict.get('xt_threshold') or 0) + 1

    elif sdn_data.block_reason == 'failure':
        self.stats_props.block_reasons_dict['failure'] = \
            (self.stats_props.block_reasons_dict.get('failure') or 0) + 1
```

### Mapping to BlockReason Enum
| BlockReason (Phase 1) | block_reasons_dict key |
|-----------------------|------------------------|
| NO_ROUTE | 'distance' |
| NO_SPECTRUM | 'congestion' |
| SNR_FAILURE | 'xt_threshold' |
| FAILURE | 'failure' |
```

### 5. Bandwidth Blocking Calculation

```markdown
## Bandwidth Blocking Logic

```python
def _update_bandwidth_blocking(self, req_data, blocked: bool):
    bandwidth = req_data.get('bandwidth', 0)

    # Track total requested
    self.total_bandwidth_requested += bandwidth

    if blocked:
        # Track blocked bandwidth
        self.total_bandwidth_blocked += bandwidth

        # Track by bandwidth class
        bw_class = self._get_bandwidth_class(bandwidth)
        self.stats_props.bandwidth_blocking_dict[bw_class] = \
            self.stats_props.bandwidth_blocking_dict.get(bw_class, 0) + 1
```

### Bandwidth Classes
| Bandwidth (Gbps) | Class |
|------------------|-------|
| 25 | '25' |
| 50 | '50' |
| 100 | '100' |
| 200 | '200' |
| 400 | '400' |
```

### 6. Utilization Tracking

```markdown
## Lightpath Utilization

### Called from: handle_release
```python
def update_utilization_dict(self, lightpath_status_dict):
    for pair, lightpaths in lightpath_status_dict.items():
        for lp_id, lp_info in lightpaths.items():
            utilization = self._calculate_lp_utilization(lp_info)
            self._record_utilization(pair, lp_id, utilization)
```

### Utilization Calculation
```python
def _calculate_lp_utilization(self, lp_info):
    if lp_info['lightpath_bandwidth'] == 0:
        return 0.0
    used = lp_info['lightpath_bandwidth'] - lp_info['remaining_bandwidth']
    return used / lp_info['lightpath_bandwidth']
```
```

## Verification

After extraction, verify:
- [ ] All iter_update logic documented
- [ ] All SDNProps fields mapped
- [ ] Block reason logic documented
- [ ] Bandwidth blocking logic documented
- [ ] Utilization tracking documented

## Next Task

After completing this extraction, proceed to `P3.4.b_design_stats_api_extension.md`.
