# Task ID: P3.4.c - Implement Stats Integration

**Sub-phase:** P3.4
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** refactor-plan

## Purpose

Implement the stats integration methods designed in P3.4.b.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.4_stats_integration/P3.4.b_design_stats_api_extension.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.4_stats_integration/P3.4.shared_context_stats_requirements.md`

## Outputs

### 1. Add to StatsCollector (or SimStats)

```python
# In fusion/core/metrics.py or fusion/stats/collector.py

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import AllocationResult, BlockReason


@dataclass
class LightpathDetails:
    """Collected lightpath details for stats recording."""
    path: tuple[str, ...] | None = None
    modulation: str | None = None
    snr_db: float | None = None
    crosstalk_db: float | None = None
    core: int | None = None
    band: str | None = None
    start_slot: int | None = None
    end_slot: int | None = None


class SimStats:
    # ... existing code ...

    # ========================================================================
    # New Path Methods (Phase 3)
    # ========================================================================

    def record_arrival(
        self,
        request: Request,
        result: AllocationResult,
        network_state: NetworkState,
    ) -> None:
        """
        Record statistics from orchestrator allocation result.

        Args:
            request: The request that was processed
            result: The allocation result from orchestrator
            network_state: Current network state for spectrum data
        """
        self.total_requests += 1

        if not result.success:
            self._record_blocked_request_new(request, result)
        else:
            self._record_successful_allocation_new(request, result, network_state)

        self._maybe_take_snapshot_new(network_state)

    def _record_blocked_request_new(
        self,
        request: Request,
        result: AllocationResult,
    ) -> None:
        """Record stats for a blocked request (new path)."""
        self.blocked_requests += 1

        # Update block reason
        if result.block_reason:
            reason_key = self._map_block_reason_new(result.block_reason)
            current = self.stats_props.block_reasons_dict.get(reason_key) or 0
            self.stats_props.block_reasons_dict[reason_key] = current + 1

        # Update bandwidth blocking
        self._record_bandwidth_blocking_new(request.bandwidth_gbps, blocked=True)

    def _record_successful_allocation_new(
        self,
        request: Request,
        result: AllocationResult,
        network_state: NetworkState,
    ) -> None:
        """Record stats for a successful allocation (new path)."""
        # Get lightpath details for metrics
        lp_details = self._get_lightpath_details_new(result, network_state)

        # Path metrics
        if lp_details.path:
            hops = len(lp_details.path) - 1
            self.stats_props.hops_list.append(float(hops))

            length = self._calculate_path_length_new(lp_details.path, network_state)
            self.stats_props.lengths_list.append(length)

        # Resource metrics
        transponders = len(result.lightpaths_created) or 1
        self.stats_props.transponders_list.append(transponders)

        # Modulation tracking
        if lp_details.modulation:
            self._increment_modulation_count(lp_details.modulation)

        # Quality metrics
        if lp_details.snr_db is not None:
            self.stats_props.snr_list.append(lp_details.snr_db)
        if lp_details.crosstalk_db is not None:
            self.stats_props.crosstalk_list.append(lp_details.crosstalk_db)

        # Bandwidth tracking
        self._record_bandwidth_blocking_new(request.bandwidth_gbps, blocked=False)

        # Feature tracking
        if result.is_groomed:
            self.groomed_requests = getattr(self, 'groomed_requests', 0) + 1
        if result.is_sliced:
            self.sliced_requests = getattr(self, 'sliced_requests', 0) + 1
        if result.is_protected:
            self.protected_requests = getattr(self, 'protected_requests', 0) + 1

    def _get_lightpath_details_new(
        self,
        result: AllocationResult,
        network_state: NetworkState,
    ) -> LightpathDetails:
        """Extract lightpath details from result and network state."""
        if not result.lightpaths_created:
            return LightpathDetails()

        # Get first created lightpath for primary metrics
        lp_id = result.lightpaths_created[0]
        lp = network_state.get_lightpath(lp_id)

        if lp is None:
            return LightpathDetails()

        return LightpathDetails(
            path=getattr(lp, 'path', None),
            modulation=getattr(lp, 'modulation', None),
            snr_db=getattr(lp, 'snr_db', None),
            crosstalk_db=getattr(lp, 'crosstalk_db', None),
            core=getattr(lp, 'core', None),
            band=getattr(lp, 'band', None),
            start_slot=getattr(lp, 'start_slot', None),
            end_slot=getattr(lp, 'end_slot', None),
        )

    def _map_block_reason_new(self, reason: BlockReason) -> str:
        """Map BlockReason enum to stats dict key."""
        from fusion.domain.results import BlockReason

        mapping = {
            BlockReason.NO_ROUTE: 'distance',
            BlockReason.NO_SPECTRUM: 'congestion',
            BlockReason.SNR_FAILURE: 'xt_threshold',
            BlockReason.DISTANCE: 'distance',
            BlockReason.CONGESTION: 'congestion',
            BlockReason.FAILURE: 'failure',
        }
        return mapping.get(reason, 'congestion')

    def _calculate_path_length_new(
        self,
        path: tuple[str, ...],
        network_state: NetworkState,
    ) -> float:
        """Calculate total path length in km."""
        if len(path) < 2:
            return 0.0

        total_length = 0.0
        topology = network_state.topology

        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            if topology.has_edge(u, v):
                edge_data = topology.edges[u, v]
                total_length += edge_data.get('length', edge_data.get('weight', 0.0))

        return total_length

    def _record_bandwidth_blocking_new(
        self,
        bandwidth_gbps: int,
        blocked: bool,
    ) -> None:
        """Record bandwidth for blocking statistics."""
        # Track total requested
        self.total_bandwidth_requested = (
            getattr(self, 'total_bandwidth_requested', 0) + bandwidth_gbps
        )

        if blocked:
            # Track blocked bandwidth
            self.total_bandwidth_blocked = (
                getattr(self, 'total_bandwidth_blocked', 0) + bandwidth_gbps
            )

            # Track by bandwidth class
            bw_class = str(bandwidth_gbps)
            current = self.stats_props.bandwidth_blocking_dict.get(bw_class, 0)
            self.stats_props.bandwidth_blocking_dict[bw_class] = current + 1

    def _maybe_take_snapshot_new(self, network_state: NetworkState) -> None:
        """Take periodic network snapshot (new path)."""
        # Check if it's time for a snapshot
        snapshot_interval = getattr(self, 'snapshot_interval', 100)
        if self.total_requests % snapshot_interval != 0:
            return

        snapshot = {
            'request_number': self.total_requests,
            'blocked_count': self.blocked_requests,
            'spectrum_utilization': self._calculate_spectrum_utilization_new(
                network_state
            ),
        }

        self.stats_props.snapshots_dict[self.total_requests] = snapshot

    def _calculate_spectrum_utilization_new(
        self,
        network_state: NetworkState,
    ) -> float:
        """Calculate overall spectrum utilization."""
        total_slots = 0
        used_slots = 0

        # Get spectrum utilization from network state
        network_spectrum_dict = network_state.network_spectrum_dict

        for link_key, link_data in network_spectrum_dict.items():
            cores_matrix = link_data.get('cores_matrix', {})
            for band, cores in cores_matrix.items():
                for core_spectrum in cores:
                    if hasattr(core_spectrum, '__len__'):
                        total_slots += len(core_spectrum)
                        used_slots += sum(1 for s in core_spectrum if s != 0)

        if total_slots == 0:
            return 0.0
        return used_slots / total_slots
```

### 2. Add Instance Variables

```python
class SimStats:
    def __init__(self, engine_props: dict, sim_info: str, ...):
        # ... existing initialization ...

        # New path tracking (Phase 3)
        self.groomed_requests: int = 0
        self.sliced_requests: int = 0
        self.protected_requests: int = 0
        self.total_bandwidth_requested: int = 0
        self.total_bandwidth_blocked: int = 0
        self.snapshot_interval: int = engine_props.get('snapshot_interval', 100)
```

### 3. Update SimulationEngine Integration

```python
# In fusion/core/simulation.py

def _update_stats_from_result(
    self,
    request: Request,
    result: AllocationResult,
) -> None:
    """Update stats from orchestrator result."""
    self.stats.record_arrival(request, result, self._network_state)
```

### 4. Ensure Backwards Compatibility

```python
class SimStats:
    def iter_update(
        self,
        req_data: dict,
        sdn_data: Any,
        network_spectrum_dict: dict,
    ) -> None:
        """
        Update stats using legacy format.

        This method is used by the legacy SDNController path.
        For the new orchestrator path, use record_arrival().
        """
        # Existing implementation unchanged
        ...
```

## Verification Commands

```bash
# Type checking
mypy fusion/core/metrics.py --strict

# Linting
ruff check fusion/core/metrics.py

# Run existing stats tests
pytest fusion/tests/core/test_metrics.py -v

# Smoke test new methods
python -c "
from fusion.core.metrics import SimStats, LightpathDetails
print('Stats classes imported successfully')
"
```

## Important Notes

### Method Naming Convention

New methods have `_new` suffix to distinguish from legacy methods:
- `_record_blocked_request_new`
- `_record_successful_allocation_new`
- etc.

This allows both paths to coexist and avoids breaking existing code.

### Attribute Safety

Use `getattr` with defaults for new attributes:
```python
self.groomed_requests = getattr(self, 'groomed_requests', 0) + 1
```

This handles cases where attributes might not be initialized.

### NetworkState Integration

The new methods use `NetworkState` instead of raw dicts:
```python
# Old path
self._take_snapshot(network_spectrum_dict)

# New path
self._maybe_take_snapshot_new(network_state)
```

## Next Task

After implementing the integration, proceed to `P3.4.d_verify_stats_parity.md`.
