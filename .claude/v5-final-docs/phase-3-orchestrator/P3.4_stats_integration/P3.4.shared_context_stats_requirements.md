# P3.4 Shared Context: Stats Requirements

## Purpose

This document summarizes the statistics requirements and current behavior for Phase 3 integration.

## Source Files

- `fusion/core/metrics.py` (SimStats class)
- `fusion/core/properties.py` (StatsProps class)
- `.claude/v5-final-docs/phase-1-core-domain/P1.5_stats_collector/P1.5.index.md`

## Current Stats Collection

### SimStats Class

```python
class SimStats:
    def __init__(self, engine_props: dict, sim_info: str):
        self.stats_props = StatsProps()
        self.blocked_requests = 0
        self.block_mean = None
        self.block_variance = None
        # ... more fields

    def iter_update(
        self,
        req_data: dict,
        sdn_data: Any,
        network_spectrum_dict: dict,
    ) -> None:
        """Update stats after each request."""
        ...

    def calculate_blocking_statistics(self) -> None:
        """Calculate blocking probability and related metrics."""
        ...
```

### Key Metrics Collected

| Category | Metrics | Update Frequency |
|----------|---------|------------------|
| Blocking | blocked_requests, block_mean, block_variance | Per request |
| Bandwidth | bit_rate_blocked, bit_rate_request | Per request |
| Path | hops_list, lengths_list | Per successful request |
| Resource | transponders_list, modulations_used_dict | Per successful request |
| Quality | crosstalk_list, snr_list | Per successful request |
| Utilization | lp_bw_utilization_dict | Per release |
| Blocking Reasons | block_reasons_dict | Per blocked request |

### StatsProps Fields

```python
@dataclass
class StatsProps:
    # Snapshots for time-series analysis
    snapshots_dict: dict[int, dict[str, Any]] = field(default_factory=dict)

    # Resource usage tracking
    cores_dict: dict[int, int] = field(default_factory=dict)
    weights_dict: dict[str, Any] = field(default_factory=dict)
    modulations_used_dict: dict[str, Any] = field(default_factory=dict)
    bandwidth_blocking_dict: dict[str | float, int] = field(default_factory=dict)
    link_usage_dict: dict[str, dict[str, Any]] = field(default_factory=dict)

    # Per-request metrics
    simulation_blocking_list: list[float] = field(default_factory=list)
    transponders_list: list[int | float] = field(default_factory=list)
    hops_list: list[float] = field(default_factory=list)
    lengths_list: list[float] = field(default_factory=list)
    route_times_list: list[float] = field(default_factory=list)
    crosstalk_list: list[float] = field(default_factory=list)
    snr_list: list[float] = field(default_factory=list)

    # Block reasons
    block_reasons_dict: dict[str, int | float | None] = field(
        default_factory=lambda: {
            "distance": None,
            "congestion": None,
            "xt_threshold": None,
            "failure": None,
        }
    )

    # Utilization tracking
    lp_bw_utilization_dict: dict[str, Any] = field(default_factory=dict)
    sim_lp_utilization_list: list[float] = field(default_factory=list)

    # Protection/survivability
    protection_switchovers: int = 0
    protection_failures: int = 0
    failure_induced_blocks: int = 0
```

## iter_update Behavior

```python
def iter_update(
    self,
    req_data: dict,
    sdn_data: Any,
    network_spectrum_dict: dict,
) -> None:
    """
    Update statistics after each request.

    Called by SimulationEngine.update_arrival_params() after
    each arrival event is processed.
    """
    # Check if request was blocked
    if not sdn_data.was_routed:
        self.blocked_requests += 1
        self._update_block_reason(sdn_data)
        return

    # Request was successful - collect metrics
    self._update_successful_metrics(req_data, sdn_data)
    self._update_resource_usage(sdn_data, network_spectrum_dict)
    self._maybe_take_snapshot(network_spectrum_dict)
```

## Mapping AllocationResult to Stats

### Success Case

| AllocationResult Field | Stats Update |
|------------------------|--------------|
| `result.success = True` | No blocked_requests increment |
| `result.total_bandwidth_allocated_gbps` | bandwidth_list entry |
| `result.lightpaths_created` | transponders_list entry |
| `result.is_groomed` | groomed_requests increment |
| `result.is_sliced` | sliced_requests increment |
| `result.is_protected` | protected_requests increment |

### Failure Case

| AllocationResult Field | Stats Update |
|------------------------|--------------|
| `result.success = False` | blocked_requests increment |
| `result.block_reason = NO_ROUTE` | block_reasons_dict['distance'] increment |
| `result.block_reason = NO_SPECTRUM` | block_reasons_dict['congestion'] increment |
| `result.block_reason = SNR_FAILURE` | block_reasons_dict['xt_threshold'] increment |

## record_arrival Requirements

The new `record_arrival` method must:

1. **Track blocking**: Increment `blocked_requests` when `result.success = False`
2. **Track bandwidth**: Update bandwidth statistics
3. **Track resources**: Record transponders, modulations, etc.
4. **Track quality**: Record SNR, crosstalk if available
5. **Track reasons**: Map block_reason to block_reasons_dict
6. **Take snapshots**: Periodically snapshot network state

## Data Availability Comparison

| Data | Legacy Path | New Path |
|------|-------------|----------|
| Request ID | req_data['req_id'] | request.request_id |
| Source/Dest | req_data['source'/'destination'] | request.source/destination |
| Bandwidth | req_data['bandwidth'] | request.bandwidth_gbps |
| Was Routed | sdn_data.was_routed | result.success |
| Lightpath IDs | sdn_data.lightpath_id_list | request.lightpath_ids |
| Path | sdn_data.path_list | (need from result or network_state) |
| Modulation | sdn_data.modulation_list | (need from result) |
| SNR | sdn_data.snr_list | (need from result) |
| Network State | network_spectrum_dict | network_state.network_spectrum_dict |

## Missing Data in AllocationResult

The current `AllocationResult` design may not include all data needed for stats:

```python
# Current AllocationResult (from Phase 1)
@dataclass
class AllocationResult:
    success: bool
    lightpaths_created: list[int] = field(default_factory=list)
    lightpaths_groomed: list[int] = field(default_factory=list)
    is_groomed: bool = False
    is_partially_groomed: bool = False
    is_sliced: bool = False
    is_protected: bool = False
    total_bandwidth_allocated_gbps: int = 0
    block_reason: BlockReason | None = None
```

### Additional Fields Needed

```python
# Extended AllocationResult for stats
@dataclass
class AllocationResult:
    # ... existing fields ...

    # For stats collection
    path: tuple[str, ...] | None = None  # Path used (for hops/length)
    modulation: str | None = None  # Modulation format
    snr_db: float | None = None  # SNR measurement
    crosstalk_db: float | None = None  # Crosstalk measurement
    transponders_used: int = 0  # Number of transponders
    route_time_ms: float = 0.0  # Decision time
```

Or retrieve from NetworkState:

```python
def record_arrival(self, request, result, network_state):
    if result.success and result.lightpaths_created:
        lp = network_state.get_lightpath(result.lightpaths_created[0])
        path = lp.path
        modulation = lp.modulation
        # etc.
```

## Output Format Requirements

Stats output must remain unchanged:

```python
# Example output format
{
    'blocking_probability': 0.05,
    'bit_rate_blocking': 0.03,
    'average_hops': 2.5,
    'average_path_length_km': 450.0,
    'modulation_distribution': {'QPSK': 0.6, '8QAM': 0.3, '16QAM': 0.1},
    'block_reasons': {'distance': 10, 'congestion': 40, 'xt_threshold': 5},
    'utilization': 0.65,
}
```
