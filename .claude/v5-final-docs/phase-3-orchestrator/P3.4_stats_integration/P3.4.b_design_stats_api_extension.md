# Task ID: P3.4.b - Design Stats API Extension

**Sub-phase:** P3.4
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design

## Purpose

Design the new StatsCollector API methods for recording stats from orchestrator results.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.4_stats_integration/P3.4.a_extract_current_stats_behavior.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.4_stats_integration/P3.4.shared_context_stats_requirements.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.e_design_allocation_result.md`

## Outputs

### 1. New Public Method: record_arrival

```python
def record_arrival(
    self,
    request: Request,
    result: AllocationResult,
    network_state: NetworkState,
) -> None:
    """
    Record statistics from orchestrator allocation result.

    This method provides the same functionality as iter_update but
    works with Phase 1 domain objects instead of legacy sdn_props.

    Args:
        request: The request that was processed
        result: The allocation result from orchestrator
        network_state: Current network state for spectrum data

    Side Effects:
        - Updates blocked_requests count
        - Updates bandwidth statistics
        - Updates resource usage metrics
        - Updates quality metrics (if available)
        - Updates block reasons (if blocked)
        - May take network snapshot

    Example:
        >>> result = orchestrator.handle_arrival(request, network_state)
        >>> stats.record_arrival(request, result, network_state)
    """
    self.total_requests += 1

    if not result.success:
        self._record_blocked_request(request, result)
    else:
        self._record_successful_allocation(request, result, network_state)

    self._maybe_take_snapshot(network_state)
```

### 2. Private Helper: _record_blocked_request

```python
def _record_blocked_request(
    self,
    request: Request,
    result: AllocationResult,
) -> None:
    """Record stats for a blocked request."""
    self.blocked_requests += 1

    # Update block reason
    if result.block_reason:
        reason_key = self._map_block_reason(result.block_reason)
        current = self.stats_props.block_reasons_dict.get(reason_key) or 0
        self.stats_props.block_reasons_dict[reason_key] = current + 1

    # Update bandwidth blocking
    self._record_bandwidth_blocking(request.bandwidth_gbps, blocked=True)
```

### 3. Private Helper: _record_successful_allocation

```python
def _record_successful_allocation(
    self,
    request: Request,
    result: AllocationResult,
    network_state: NetworkState,
) -> None:
    """Record stats for a successful allocation."""
    # Get lightpath details for metrics
    lp_details = self._get_lightpath_details(result, network_state)

    # Path metrics
    if lp_details.path:
        hops = len(lp_details.path) - 1
        self.stats_props.hops_list.append(hops)

        length = self._calculate_path_length(lp_details.path, network_state)
        self.stats_props.lengths_list.append(length)

    # Resource metrics
    transponders = len(result.lightpaths_created) or 1
    self.stats_props.transponders_list.append(transponders)

    # Modulation tracking
    if lp_details.modulation:
        self._increment_modulation_count(lp_details.modulation)

    # Quality metrics
    if lp_details.snr_db is not None:
        self.stats_props.snr_list.append(lp_details.snr_db)
    if lp_details.crosstalk_db is not None:
        self.stats_props.crosstalk_list.append(lp_details.crosstalk_db)

    # Bandwidth tracking
    self._record_bandwidth_blocking(request.bandwidth_gbps, blocked=False)

    # Feature tracking
    if result.is_groomed:
        self.groomed_requests += 1
    if result.is_sliced:
        self.sliced_requests += 1
    if result.is_protected:
        self.protected_requests += 1
```

### 4. Helper Data Class: LightpathDetails

```python
@dataclass
class LightpathDetails:
    """Collected lightpath details for stats."""
    path: tuple[str, ...] | None = None
    modulation: str | None = None
    snr_db: float | None = None
    crosstalk_db: float | None = None
    core: int | None = None
    band: str | None = None
    start_slot: int | None = None
    end_slot: int | None = None


def _get_lightpath_details(
    self,
    result: AllocationResult,
    network_state: NetworkState,
) -> LightpathDetails:
    """Extract lightpath details from result and network state."""
    if not result.lightpaths_created:
        return LightpathDetails()

    # Get first created lightpath for primary metrics
    lp_id = result.lightpaths_created[0]
    lp = network_state.get_lightpath(lp_id)

    if lp is None:
        return LightpathDetails()

    return LightpathDetails(
        path=lp.path,
        modulation=lp.modulation,
        snr_db=getattr(lp, 'snr_db', None),
        crosstalk_db=getattr(lp, 'crosstalk_db', None),
        core=lp.core,
        band=lp.band,
        start_slot=lp.start_slot,
        end_slot=lp.end_slot,
    )
```

### 5. Block Reason Mapping

```python
def _map_block_reason(self, reason: BlockReason) -> str:
    """Map BlockReason enum to stats dict key."""
    mapping = {
        BlockReason.NO_ROUTE: 'distance',
        BlockReason.NO_SPECTRUM: 'congestion',
        BlockReason.SNR_FAILURE: 'xt_threshold',
        BlockReason.DISTANCE: 'distance',
        BlockReason.CONGESTION: 'congestion',
        BlockReason.FAILURE: 'failure',
    }
    return mapping.get(reason, 'congestion')  # Default to congestion
```

### 6. Path Length Calculation

```python
def _calculate_path_length(
    self,
    path: tuple[str, ...],
    network_state: NetworkState,
) -> float:
    """Calculate total path length in km."""
    if len(path) < 2:
        return 0.0

    total_length = 0.0
    topology = network_state.topology

    for i in range(len(path) - 1):
        u, v = path[i], path[i + 1]
        if topology.has_edge(u, v):
            edge_data = topology.edges[u, v]
            total_length += edge_data.get('length', edge_data.get('weight', 0.0))

    return total_length
```

### 7. Snapshot Integration

```python
def _maybe_take_snapshot(self, network_state: NetworkState) -> None:
    """Take periodic network snapshot."""
    if not self._should_take_snapshot():
        return

    snapshot = {
        'request_number': self.total_requests,
        'blocked_count': self.blocked_requests,
        'spectrum_utilization': self._calculate_spectrum_utilization(network_state),
        'active_lightpaths': len(network_state.get_all_lightpaths()),
    }

    self.stats_props.snapshots_dict[self.total_requests] = snapshot

def _calculate_spectrum_utilization(self, network_state: NetworkState) -> float:
    """Calculate overall spectrum utilization."""
    total_slots = 0
    used_slots = 0

    for link_spectrum in network_state.get_all_link_spectrums():
        spectrum = link_spectrum.get_spectrum_array()
        total_slots += len(spectrum)
        used_slots += sum(1 for s in spectrum if s != 0)

    if total_slots == 0:
        return 0.0
    return used_slots / total_slots
```

### 8. Updated StatsCollector Class Signature

```python
class StatsCollector:
    """
    Statistics collector for FUSION simulation.

    Supports both legacy iter_update path and new record_arrival path.
    """

    def __init__(self, config: SimulationConfig) -> None:
        ...

    # Legacy path (existing)
    def iter_update(
        self,
        req_data: dict,
        sdn_data: Any,
        network_spectrum_dict: dict,
    ) -> None:
        """Update stats using legacy sdn_props format."""
        ...

    # New path (Phase 3)
    def record_arrival(
        self,
        request: Request,
        result: AllocationResult,
        network_state: NetworkState,
    ) -> None:
        """Update stats using Phase 1 domain objects."""
        ...

    # Shared methods (used by both paths)
    def record_release(self, request: Request) -> None:
        """Record release event."""
        ...

    def update_utilization_dict(self, lightpath_status_dict: dict) -> None:
        """Update utilization tracking."""
        ...

    def calculate_blocking_statistics(self) -> None:
        """Calculate final blocking statistics."""
        ...
```

## Verification

After design, verify:
- [ ] record_arrival signature defined
- [ ] All helper methods designed
- [ ] Block reason mapping complete
- [ ] Path metrics calculation defined
- [ ] Snapshot integration defined

## Next Task

After completing this design, proceed to `P3.4.c_implement_stats_integration.md`.
