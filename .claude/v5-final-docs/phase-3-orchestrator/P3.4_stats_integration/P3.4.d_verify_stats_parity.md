# Task ID: P3.4.d - Verify Stats Parity

**Sub-phase:** P3.4
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** verification-plan

## Purpose

Create tests and verification procedures to ensure both paths produce equivalent statistics.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.4_stats_integration/P3.4.c_implement_stats_integration.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.4_stats_integration/P3.4.shared_context_stats_requirements.md`

## Outputs

### 1. Unit Tests for record_arrival

```python
# fusion/tests/core/test_stats_new_path.py
"""Tests for stats collection via new orchestrator path."""

from __future__ import annotations

from unittest.mock import MagicMock

import pytest


class TestRecordArrivalBlocked:
    """Tests for record_arrival with blocked requests."""

    def test_increments_blocked_count(self) -> None:
        """record_arrival increments blocked_requests on failure."""
        from fusion.core.metrics import SimStats

        stats = SimStats({'topology': 'test'}, 'test_sim')
        initial_blocked = stats.blocked_requests

        mock_request = MagicMock()
        mock_request.bandwidth_gbps = 100

        mock_result = MagicMock()
        mock_result.success = False
        mock_result.block_reason = MagicMock()
        mock_result.block_reason.value = 'no_route'

        mock_state = MagicMock()

        stats.record_arrival(mock_request, mock_result, mock_state)

        assert stats.blocked_requests == initial_blocked + 1

    def test_updates_block_reason_dict(self) -> None:
        """record_arrival updates block_reasons_dict."""
        from fusion.core.metrics import SimStats
        from fusion.domain.results import BlockReason

        stats = SimStats({'topology': 'test'}, 'test_sim')

        mock_request = MagicMock()
        mock_request.bandwidth_gbps = 100

        mock_result = MagicMock()
        mock_result.success = False
        mock_result.block_reason = BlockReason.NO_ROUTE

        mock_state = MagicMock()

        stats.record_arrival(mock_request, mock_result, mock_state)

        assert stats.stats_props.block_reasons_dict.get('distance', 0) >= 1


class TestRecordArrivalSuccess:
    """Tests for record_arrival with successful requests."""

    def test_does_not_increment_blocked(self) -> None:
        """record_arrival does not increment blocked on success."""
        from fusion.core.metrics import SimStats

        stats = SimStats({'topology': 'test'}, 'test_sim')
        initial_blocked = stats.blocked_requests

        mock_request = MagicMock()
        mock_request.bandwidth_gbps = 100

        mock_result = MagicMock()
        mock_result.success = True
        mock_result.lightpaths_created = []
        mock_result.is_groomed = False
        mock_result.is_sliced = False
        mock_result.is_protected = False

        mock_state = MagicMock()
        mock_state.get_lightpath.return_value = None
        mock_state.network_spectrum_dict = {}

        stats.record_arrival(mock_request, mock_result, mock_state)

        assert stats.blocked_requests == initial_blocked

    def test_tracks_groomed_requests(self) -> None:
        """record_arrival increments groomed_requests when groomed."""
        from fusion.core.metrics import SimStats

        stats = SimStats({'topology': 'test'}, 'test_sim')

        mock_request = MagicMock()
        mock_request.bandwidth_gbps = 100

        mock_result = MagicMock()
        mock_result.success = True
        mock_result.lightpaths_created = []
        mock_result.is_groomed = True
        mock_result.is_sliced = False
        mock_result.is_protected = False

        mock_state = MagicMock()
        mock_state.get_lightpath.return_value = None
        mock_state.network_spectrum_dict = {}

        stats.record_arrival(mock_request, mock_result, mock_state)

        assert stats.groomed_requests >= 1

    def test_records_path_metrics(self) -> None:
        """record_arrival records hops and length."""
        from fusion.core.metrics import SimStats

        stats = SimStats({'topology': 'test'}, 'test_sim')

        mock_request = MagicMock()
        mock_request.bandwidth_gbps = 100

        mock_result = MagicMock()
        mock_result.success = True
        mock_result.lightpaths_created = [1]
        mock_result.is_groomed = False
        mock_result.is_sliced = False
        mock_result.is_protected = False

        mock_lp = MagicMock()
        mock_lp.path = ('A', 'B', 'C')
        mock_lp.modulation = 'QPSK'

        mock_state = MagicMock()
        mock_state.get_lightpath.return_value = mock_lp
        mock_state.topology.has_edge.return_value = True
        mock_state.topology.edges = {
            ('A', 'B'): {'length': 100},
            ('B', 'C'): {'length': 150},
        }
        mock_state.network_spectrum_dict = {}

        stats.record_arrival(mock_request, mock_result, mock_state)

        assert len(stats.stats_props.hops_list) > 0
        assert stats.stats_props.hops_list[-1] == 2  # A-B-C = 2 hops
```

### 2. Parity Tests

```python
# fusion/tests/core/test_stats_parity.py
"""Tests comparing legacy and new stats paths."""

from __future__ import annotations

from unittest.mock import MagicMock

import pytest


class TestStatsParity:
    """Tests ensuring both paths produce equivalent stats."""

    def test_blocked_count_equivalent(self) -> None:
        """Both paths count blocked requests the same."""
        from fusion.core.metrics import SimStats

        stats = SimStats({'topology': 'test'}, 'test_sim')

        # Simulate legacy path blocked request
        legacy_req_data = {'req_id': 1, 'bandwidth': 100}
        legacy_sdn_data = MagicMock()
        legacy_sdn_data.was_routed = False
        legacy_sdn_data.block_reason = 'congestion'

        stats.iter_update(legacy_req_data, legacy_sdn_data, {})
        blocked_after_legacy = stats.blocked_requests

        # Simulate new path blocked request
        from fusion.domain.results import BlockReason

        mock_request = MagicMock()
        mock_request.bandwidth_gbps = 100

        mock_result = MagicMock()
        mock_result.success = False
        mock_result.block_reason = BlockReason.NO_SPECTRUM

        mock_state = MagicMock()
        mock_state.network_spectrum_dict = {}

        stats.record_arrival(mock_request, mock_result, mock_state)
        blocked_after_new = stats.blocked_requests

        # Both should have incremented by 1
        assert blocked_after_new == blocked_after_legacy + 1

    def test_bandwidth_blocking_equivalent(self) -> None:
        """Both paths track bandwidth blocking the same."""
        from fusion.core.metrics import SimStats

        stats = SimStats({'topology': 'test'}, 'test_sim')

        # Process blocked requests via both paths
        # ... (similar to above)

        # Check bandwidth blocking dict has same structure
        assert 'bandwidth_blocking_dict' in dir(stats.stats_props)
```

### 3. Integration Comparison Test

```python
# fusion/tests/integration/test_stats_comparison.py
"""Integration tests comparing stats from both simulation paths."""

from __future__ import annotations

import pytest


@pytest.mark.integration
@pytest.mark.skip(reason="Requires full orchestrator implementation")
class TestStatsComparisonIntegration:
    """Compare stats output from both paths."""

    def test_blocking_probability_within_tolerance(self) -> None:
        """Both paths produce blocking probability within 2% tolerance."""
        from fusion.core.simulation import SimulationEngine

        config = {
            'topology': 'NSFNet',
            'num_requests': 1000,
            'max_iterations': 3,
            'seed': 42,
        }

        # Run legacy path
        config['use_orchestrator'] = False
        legacy_engine = SimulationEngine(config)
        legacy_engine.run(seed=42)
        legacy_bp = legacy_engine.stats.block_mean

        # Run new path
        config['use_orchestrator'] = True
        new_engine = SimulationEngine(config)
        new_engine.run(seed=42)
        new_bp = new_engine.stats.block_mean

        # Should be within 2% absolute difference
        assert abs(legacy_bp - new_bp) < 0.02, (
            f"Blocking probability mismatch: legacy={legacy_bp}, new={new_bp}"
        )

    def test_block_reasons_match(self) -> None:
        """Both paths produce same block reason distribution."""
        # Similar setup as above
        # Compare stats_props.block_reasons_dict
        pass

    def test_modulation_distribution_matches(self) -> None:
        """Both paths produce same modulation usage distribution."""
        # Similar setup
        # Compare stats_props.modulations_used_dict
        pass
```

### 4. Verification Script

```python
#!/usr/bin/env python
"""
Stats parity verification script.

Runs simulation with both paths and compares output.

Usage:
    python scripts/verify_stats_parity.py --config myconfig.ini --seed 42
"""

from __future__ import annotations

import argparse
import json
import sys


def run_comparison(config_file: str, seed: int) -> dict:
    """Run comparison between paths and return metrics."""
    from fusion.core.simulation import SimulationEngine

    config = load_config(config_file)
    config['max_iterations'] = 1
    config['num_requests'] = 1000

    results = {}

    # Legacy path
    config['use_orchestrator'] = False
    legacy_engine = SimulationEngine(config)
    legacy_engine.run(seed=seed)
    results['legacy'] = extract_metrics(legacy_engine.stats)

    # New path
    config['use_orchestrator'] = True
    new_engine = SimulationEngine(config)
    new_engine.run(seed=seed)
    results['new'] = extract_metrics(new_engine.stats)

    return results


def extract_metrics(stats) -> dict:
    """Extract key metrics from stats object."""
    return {
        'blocking_probability': stats.block_mean,
        'blocked_requests': stats.blocked_requests,
        'total_requests': stats.total_requests,
        'block_reasons': dict(stats.stats_props.block_reasons_dict),
    }


def compare_metrics(results: dict) -> bool:
    """Compare metrics and return pass/fail."""
    legacy = results['legacy']
    new = results['new']

    print("=== Stats Parity Verification ===")
    print(f"Legacy blocking: {legacy['blocking_probability']:.4f}")
    print(f"New blocking: {new['blocking_probability']:.4f}")

    bp_diff = abs(legacy['blocking_probability'] - new['blocking_probability'])
    print(f"Difference: {bp_diff:.4f}")

    if bp_diff < 0.02:
        print("PASS: Within 2% tolerance")
        return True
    else:
        print("FAIL: Exceeds 2% tolerance")
        return False


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('--config', required=True)
    parser.add_argument('--seed', type=int, default=42)
    args = parser.parse_args()

    results = run_comparison(args.config, args.seed)
    passed = compare_metrics(results)

    return 0 if passed else 1


if __name__ == '__main__':
    sys.exit(main())
```

### 5. Verification Checklist

```markdown
## P3.4 Verification Checklist

### record_arrival Method
- [ ] Increments total_requests
- [ ] Increments blocked_requests on failure
- [ ] Updates block_reasons_dict correctly
- [ ] Records path metrics (hops, length)
- [ ] Records resource metrics (transponders)
- [ ] Records modulation usage
- [ ] Records quality metrics (if available)
- [ ] Tracks groomed/sliced/protected counts

### Stats Parity
- [ ] Blocking probability within 2%
- [ ] Block reasons distribution matches
- [ ] Bandwidth blocking matches
- [ ] Modulation distribution matches
- [ ] Path length statistics match

### Code Quality
- [ ] mypy --strict passes
- [ ] ruff check passes
- [ ] All unit tests pass
- [ ] Parity tests pass
```

## Exit Criteria

P3.4 is complete when:

- [ ] `record_arrival` method implemented
- [ ] All helper methods implemented
- [ ] Unit tests pass
- [ ] Parity tests show < 2% deviation
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes

## Next Sub-phase

After P3.4 verification completes, proceed to [P3.5 Run Comparison & Rollback](../P3.5_run_comparison_and_rollback/P3.5.index.md).
