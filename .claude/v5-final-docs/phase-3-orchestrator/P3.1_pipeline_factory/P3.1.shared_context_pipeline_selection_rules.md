# P3.1 Shared Context: Pipeline Selection Rules

## Purpose

This document summarizes the rules for selecting between legacy adapters and new pipeline implementations, extracted from v4 architecture docs.

## Source Documents

- `.claude/v4-docs/migration/phase_3_orchestrator.md` (P3.1 section)
- `.claude/v4-docs/architecture/pipelines.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.4_legacy_adapters/P2.4.index.md`

## Selection Logic Overview

The factory uses `SimulationConfig` to determine which pipeline implementation to use:

```python
# Pseudocode for factory selection logic
if config.feature_x_enabled and new_implementation_exists:
    return NewImplementation(config)
else:
    return LegacyAdapter(config)
```

## Routing Pipeline Selection

| Config Value | Implementation | Notes |
|--------------|----------------|-------|
| `route_method == "k_shortest_path"` | `RoutingAdapter` | Wraps legacy `Routing` class |
| `route_method == "congestion_aware"` | `RoutingAdapter` | Uses legacy congestion scoring |
| `route_method == "1plus1_protection"` | `ProtectedRoutingPipeline` | New implementation (Phase 3) |
| Any other | `RoutingAdapter` | Default to legacy |

**Key Config Fields**:
- `config.route_method: str`
- `config.k_paths: int` (number of candidate paths)

## Spectrum Pipeline Selection

| Config Value | Implementation | Notes |
|--------------|----------------|-------|
| `allocation_method == "first_fit"` | `SpectrumAdapter` | Wraps legacy `SpectrumAssignment` |
| `allocation_method == "best_fit"` | `BestFitSpectrumPipeline` | New implementation if exists |
| Any other | `SpectrumAdapter` | Default to legacy |

**Key Config Fields**:
- `config.allocation_method: str`
- `config.num_cores: int`
- `config.bands_enabled: list[str]`

## Grooming Pipeline Selection

| Config Value | Implementation | Notes |
|--------------|----------------|-------|
| `grooming_enabled == False` | `None` | Pipeline not created |
| `grooming_enabled == True` | `GroomingAdapter` | Wraps legacy `Grooming` class |

**Key Config Fields**:
- `config.grooming_enabled: bool`
- `config.grooming_type: str` (e.g., "end_to_end")

## SNR Pipeline Selection

| Config Value | Implementation | Notes |
|--------------|----------------|-------|
| `snr_enabled == False` | `None` | Pipeline not created |
| `snr_enabled == True` | `SNRAdapter` | Wraps legacy `SnrMeasurements` |

**Key Config Fields**:
- `config.snr_enabled: bool`
- `config.snr_type: str`
- `config.xt_threshold: float | None`

## Slicing Pipeline Selection

| Config Value | Implementation | Notes |
|--------------|----------------|-------|
| `slicing_enabled == False` | `None` | Pipeline not created |
| `slicing_enabled == True` | `StandardSlicingPipeline` | New implementation (Phase 3) |

**Key Config Fields**:
- `config.slicing_enabled: bool`
- `config.max_slices: int`

## Legacy Adapter Locations

From Phase 2:

| Adapter | File | Wraps |
|---------|------|-------|
| `RoutingAdapter` | `fusion/core/adapters/routing_adapter.py` | `Routing` |
| `SpectrumAdapter` | `fusion/core/adapters/spectrum_adapter.py` | `SpectrumAssignment` |
| `GroomingAdapter` | `fusion/core/adapters/grooming_adapter.py` | `Grooming` |
| `SNRAdapter` | `fusion/core/adapters/snr_adapter.py` | `SnrMeasurements` |

## New Pipeline Locations (Phase 3)

To be created in Phase 3 or later:

| Pipeline | File | Status |
|----------|------|--------|
| `ProtectedRoutingPipeline` | `fusion/pipelines/routing_pipeline.py` | Phase 3 |
| `BestFitSpectrumPipeline` | `fusion/pipelines/spectrum_pipeline.py` | Optional |
| `StandardSlicingPipeline` | `fusion/pipelines/slicing_pipeline.py` | Phase 3 |

## Factory Method Template

```python
@staticmethod
def create_<pipeline>(config: SimulationConfig) -> <Pipeline> | None:
    """Create <pipeline> based on config."""
    # 1. Check if feature is enabled
    if not config.<feature>_enabled:
        return None

    # 2. Check for new implementation condition
    if config.<setting> == "<new_impl_trigger>":
        from fusion.pipelines.<module> import <NewPipeline>
        return <NewPipeline>(config)

    # 3. Default to legacy adapter
    from fusion.core.adapters.<adapter>_adapter import <Adapter>
    return <Adapter>(config)
```

## Import Strategy

Use lazy imports inside factory methods to avoid circular dependencies:

```python
@staticmethod
def create_routing(config: SimulationConfig) -> RoutingPipeline:
    if config.route_method == "1plus1_protection":
        from fusion.pipelines.routing_pipeline import ProtectedRoutingPipeline
        return ProtectedRoutingPipeline(config)
    else:
        from fusion.core.adapters.routing_adapter import RoutingAdapter
        return RoutingAdapter(config)
```

## Testing Considerations

For each pipeline type, test:
1. Correct implementation selected for each config combination
2. `None` returned when feature disabled
3. Type checking confirms protocol compliance
4. Factory methods are truly stateless
