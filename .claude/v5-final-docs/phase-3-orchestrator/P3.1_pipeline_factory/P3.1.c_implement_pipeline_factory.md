# Task ID: P3.1.c - Implement PipelineFactory

**Sub-phase:** P3.1
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** refactor-plan

## Purpose

Implement `PipelineFactory` with static methods that create pipelines based on `SimulationConfig`.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.1_pipeline_factory/P3.1.b_design_pipeline_set.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.1_pipeline_factory/P3.1.shared_context_pipeline_selection_rules.md`
- `.claude/v4-docs/migration/phase_3_orchestrator.md` (P3.1 section)

## Outputs

### 1. Create fusion/pipelines/__init__.py

```python
"""
Pipeline implementations for FUSION simulation.

This package contains pipeline implementations that can be selected
by PipelineFactory based on SimulationConfig.

Current implementations:
- ProtectedRoutingPipeline: 1+1 protection routing
- StandardSlicingPipeline: Request slicing across multiple lightpaths

Phase: P3.1 - Pipeline Factory Scaffolding
"""

# Pipelines will be imported here as they are implemented
# For now, the package serves as a placeholder

__all__: list[str] = []
```

### 2. Create fusion/core/pipeline_factory.py

```python
"""
Pipeline factory for FUSION simulation.

This module provides PipelineFactory for creating pipelines based on
SimulationConfig, and PipelineSet for holding pipeline references.

Phase: P3.1 - Pipeline Factory Scaffolding
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.interfaces.pipelines import (
        GroomingPipeline,
        RoutingPipeline,
        SlicingPipeline,
        SNRPipeline,
        SpectrumPipeline,
    )

logger = logging.getLogger(__name__)


@dataclass(frozen=False, slots=True)
class PipelineSet:
    """
    Container for all pipelines used by SDNOrchestrator.

    Required pipelines:
    - routing: Finds candidate paths
    - spectrum: Finds available spectrum slots

    Optional pipelines (may be None if feature disabled):
    - grooming: Grooms requests onto existing lightpaths
    - snr: Validates signal quality
    - slicing: Slices large requests across multiple lightpaths

    Phase: P3.1 - Pipeline Factory Scaffolding
    """

    routing: RoutingPipeline
    spectrum: SpectrumPipeline
    grooming: GroomingPipeline | None = None
    snr: SNRPipeline | None = None
    slicing: SlicingPipeline | None = None

    def __post_init__(self) -> None:
        """Validate required pipelines are present."""
        if self.routing is None:
            raise ValueError("PipelineSet requires a routing pipeline")
        if self.spectrum is None:
            raise ValueError("PipelineSet requires a spectrum pipeline")

    @property
    def has_grooming(self) -> bool:
        """Check if grooming is available."""
        return self.grooming is not None

    @property
    def has_snr(self) -> bool:
        """Check if SNR validation is available."""
        return self.snr is not None

    @property
    def has_slicing(self) -> bool:
        """Check if slicing is available."""
        return self.slicing is not None


class PipelineFactory:
    """
    Factory for creating pipelines based on SimulationConfig.

    This factory uses lazy imports to avoid circular dependencies and
    selects between legacy adapters and new pipeline implementations
    based on configuration values.

    Selection Rules:
    - Routing: ProtectedRoutingPipeline for 1+1, else RoutingAdapter
    - Spectrum: SpectrumAdapter (default)
    - Grooming: GroomingAdapter if enabled, else None
    - SNR: SNRAdapter if enabled, else None
    - Slicing: StandardSlicingPipeline if enabled, else None

    Example:
        >>> config = SimulationConfig.from_engine_props(engine_props)
        >>> pipelines = PipelineFactory.create_pipeline_set(config)
        >>> orchestrator = PipelineFactory.create_orchestrator(config)

    Phase: P3.1 - Pipeline Factory Scaffolding
    """

    @staticmethod
    def create_routing(config: SimulationConfig) -> RoutingPipeline:
        """
        Create routing pipeline based on config.

        Args:
            config: Simulation configuration

        Returns:
            RoutingPipeline implementation
        """
        route_method = getattr(config, "route_method", "k_shortest_path")

        if route_method == "1plus1_protection":
            logger.debug("Creating ProtectedRoutingPipeline")
            from fusion.pipelines.routing_pipeline import ProtectedRoutingPipeline

            return ProtectedRoutingPipeline(config)
        else:
            logger.debug(f"Creating RoutingAdapter for method: {route_method}")
            from fusion.core.adapters.routing_adapter import RoutingAdapter

            return RoutingAdapter(config)

    @staticmethod
    def create_spectrum(config: SimulationConfig) -> SpectrumPipeline:
        """
        Create spectrum pipeline based on config.

        Args:
            config: Simulation configuration

        Returns:
            SpectrumPipeline implementation
        """
        allocation_method = getattr(config, "allocation_method", "first_fit")

        # For now, always use adapter
        # Can add BestFitSpectrumPipeline later
        logger.debug(f"Creating SpectrumAdapter for method: {allocation_method}")
        from fusion.core.adapters.spectrum_adapter import SpectrumAdapter

        return SpectrumAdapter(config)

    @staticmethod
    def create_grooming(config: SimulationConfig) -> GroomingPipeline | None:
        """
        Create grooming pipeline if enabled.

        Args:
            config: Simulation configuration

        Returns:
            GroomingPipeline if enabled, None otherwise
        """
        grooming_enabled = getattr(config, "grooming_enabled", False)

        if not grooming_enabled:
            logger.debug("Grooming disabled, returning None")
            return None

        logger.debug("Creating GroomingAdapter")
        from fusion.core.adapters.grooming_adapter import GroomingAdapter

        return GroomingAdapter(config)

    @staticmethod
    def create_snr(config: SimulationConfig) -> SNRPipeline | None:
        """
        Create SNR pipeline if enabled.

        Args:
            config: Simulation configuration

        Returns:
            SNRPipeline if enabled, None otherwise
        """
        snr_enabled = getattr(config, "snr_enabled", False)

        if not snr_enabled:
            logger.debug("SNR validation disabled, returning None")
            return None

        logger.debug("Creating SNRAdapter")
        from fusion.core.adapters.snr_adapter import SNRAdapter

        return SNRAdapter(config)

    @staticmethod
    def create_slicing(config: SimulationConfig) -> SlicingPipeline | None:
        """
        Create slicing pipeline if enabled.

        Args:
            config: Simulation configuration

        Returns:
            SlicingPipeline if enabled, None otherwise
        """
        slicing_enabled = getattr(config, "slicing_enabled", False)

        if not slicing_enabled:
            logger.debug("Slicing disabled, returning None")
            return None

        logger.debug("Creating StandardSlicingPipeline")
        from fusion.pipelines.slicing_pipeline import StandardSlicingPipeline

        return StandardSlicingPipeline(config)

    @classmethod
    def create_pipeline_set(cls, config: SimulationConfig) -> PipelineSet:
        """
        Create complete pipeline set from configuration.

        Args:
            config: Simulation configuration

        Returns:
            PipelineSet with all pipelines configured
        """
        logger.info("Creating pipeline set from configuration")

        return PipelineSet(
            routing=cls.create_routing(config),
            spectrum=cls.create_spectrum(config),
            grooming=cls.create_grooming(config),
            snr=cls.create_snr(config),
            slicing=cls.create_slicing(config),
        )

    @classmethod
    def create_orchestrator(cls, config: SimulationConfig) -> "SDNOrchestrator":
        """
        Create orchestrator with configured pipelines.

        Convenience method that creates both pipeline set and orchestrator.

        Args:
            config: Simulation configuration

        Returns:
            SDNOrchestrator instance
        """
        from fusion.core.orchestrator import SDNOrchestrator

        pipelines = cls.create_pipeline_set(config)
        return SDNOrchestrator(config, pipelines)
```

### 3. File Structure After Implementation

```
fusion/
├── core/
│   ├── adapters/
│   │   ├── __init__.py
│   │   ├── routing_adapter.py      # From P2.4
│   │   ├── spectrum_adapter.py     # From P2.4
│   │   ├── grooming_adapter.py     # From P2.4
│   │   └── snr_adapter.py          # From P2.4
│   └── pipeline_factory.py         # NEW: PipelineFactory, PipelineSet
└── pipelines/
    └── __init__.py                  # NEW: Package init
```

### 4. Import Dependencies

```python
# Required imports (all from Phase 1-2)
from fusion.domain.config import SimulationConfig  # Phase 1
from fusion.interfaces.pipelines import (          # Phase 2
    RoutingPipeline,
    SpectrumPipeline,
    GroomingPipeline,
    SNRPipeline,
    SlicingPipeline,
)
from fusion.core.adapters import (                 # Phase 2
    RoutingAdapter,
    SpectrumAdapter,
    GroomingAdapter,
    SNRAdapter,
)
```

### 5. Stub Files for New Pipelines

Create stub files for pipelines that will be implemented later:

```python
# fusion/pipelines/routing_pipeline.py
"""Protected routing pipeline implementation."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.results import RouteResult


class ProtectedRoutingPipeline:
    """
    Routing pipeline with 1+1 protection support.

    TODO: Implement in Phase 3 or later.
    """

    def __init__(self, config: SimulationConfig) -> None:
        self._config = config
        raise NotImplementedError("ProtectedRoutingPipeline not yet implemented")

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        *,
        forced_path: list[str] | None = None,
    ) -> RouteResult:
        raise NotImplementedError
```

```python
# fusion/pipelines/slicing_pipeline.py
"""Standard slicing pipeline implementation."""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.domain.config import SimulationConfig
    from fusion.domain.network_state import NetworkState
    from fusion.domain.request import Request
    from fusion.domain.results import SlicingResult


class StandardSlicingPipeline:
    """
    Standard request slicing pipeline.

    Slices large requests across multiple lightpaths when
    single allocation fails.

    TODO: Implement in Phase 3.
    """

    def __init__(self, config: SimulationConfig) -> None:
        self._config = config
        raise NotImplementedError("StandardSlicingPipeline not yet implemented")

    def try_slice(
        self,
        request: Request,
        path: list[str],
        modulation: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
    ) -> SlicingResult:
        raise NotImplementedError
```

## Verification Commands

```bash
# Create package structure
mkdir -p fusion/pipelines
touch fusion/pipelines/__init__.py

# Type checking
mypy fusion/core/pipeline_factory.py --strict

# Linting
ruff check fusion/core/pipeline_factory.py

# Smoke test
python -c "
from fusion.core.pipeline_factory import PipelineFactory, PipelineSet
print('PipelineFactory imported successfully')
print('PipelineSet imported successfully')
"
```

## Important Notes

### Lazy Imports

All pipeline implementations are imported inside factory methods:
- Avoids circular imports
- Allows factory to be imported without loading all pipelines
- Enables testing with stubs

### Error Handling

Factory methods do not catch exceptions:
- Let errors propagate for debugging
- Configuration errors surface at startup
- Missing implementations are obvious

### Logging

Debug logging helps trace pipeline selection:
```python
logger.debug(f"Creating RoutingAdapter for method: {route_method}")
```

## Next Task

After implementing the factory, proceed to `P3.1.d_verify_factory.md`.
