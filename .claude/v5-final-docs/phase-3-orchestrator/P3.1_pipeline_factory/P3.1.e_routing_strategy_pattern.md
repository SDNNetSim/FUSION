# Task ID: P3.1.e - Routing Strategy Pattern

**Sub-phase:** P3.1
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design
**Priority:** MEDIUM (Gap Analysis)

## Purpose

Define how the Routing Strategy pattern integrates with the RoutingPipeline and PipelineFactory. This specification covers the strategy interface, concrete implementations, and selection mechanism.

## Context to load before running this task

- `.claude/v4-docs/decisions/0008-routing-strategy-pattern.md`
- `.claude/v5-final-docs/phase-3-orchestrator/P3.1_pipeline_factory/P3.1.b_design_pipeline_set.md`

## Strategy Pattern Overview

### Why Strategy Pattern

```
Different routing scenarios require different algorithms:
- Basic: K-shortest paths
- Load-balanced: Consider link utilization
- Protection: Find disjoint paths
- Constrained: Respect bandwidth/modulation limits

Strategy pattern allows:
- Pluggable routing algorithms
- Runtime strategy selection
- Same interface for orchestrator
- Easy testing with mock strategies
```

### Class Hierarchy

```
RoutingStrategy (Protocol)
    |
    +-- KShortestPathStrategy
    |
    +-- LoadBalancedStrategy
    |
    +-- ConstrainedRoutingStrategy
    |
    +-- ProtectionAwareStrategy
    |
    +-- MLRoutingStrategy (for RL integration)
```

## Strategy Interface

### AbstractRoutingStrategy

```python
from typing import Protocol
from dataclasses import dataclass


@dataclass
class RouteConstraints:
    """Constraints for route selection."""
    max_hops: int | None = None
    max_length_km: float | None = None
    min_bandwidth_gbps: int | None = None
    exclude_links: set[tuple[str, str]] | None = None
    exclude_nodes: set[str] | None = None
    required_modulation: str | None = None
    protection_mode: bool = False


@dataclass
class RouteCandidate:
    """A candidate route returned by strategy."""
    path: tuple[str, ...]
    modulation: str
    weight_km: float
    available_bandwidth_gbps: int
    score: float = 0.0  # Strategy-specific ranking


@dataclass
class RouteResult:
    """Result of route selection."""
    candidates: list[RouteCandidate]

    @property
    def is_empty(self) -> bool:
        return len(self.candidates) == 0

    @property
    def paths(self) -> list[tuple[str, ...]]:
        return [c.path for c in self.candidates]

    @property
    def modulations(self) -> list[tuple[str, ...]]:
        return [(c.modulation,) for c in self.candidates]

    @property
    def weights_km(self) -> list[float]:
        return [c.weight_km for c in self.candidates]


class RoutingStrategy(Protocol):
    """Protocol for routing strategies."""

    def select_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        constraints: RouteConstraints | None = None,
    ) -> RouteResult:
        """
        Select candidate routes for the request.

        Args:
            source: Source node ID
            destination: Destination node ID
            bandwidth_gbps: Required bandwidth
            network_state: Current network state
            constraints: Optional routing constraints

        Returns:
            RouteResult with ordered candidate routes
        """
        ...

    @property
    def name(self) -> str:
        """Strategy name for logging and config."""
        ...
```

## Concrete Strategies

### KShortestPathStrategy

```python
class KShortestPathStrategy:
    """K-shortest paths routing strategy."""

    def __init__(self, k: int = 3):
        self.k = k
        self._name = f"k_shortest_{k}"

    @property
    def name(self) -> str:
        return self._name

    def select_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        constraints: RouteConstraints | None = None,
    ) -> RouteResult:
        """Select k-shortest paths."""
        import networkx as nx

        topology = network_state.topology

        # Apply link exclusions if any
        if constraints and constraints.exclude_links:
            topology = self._filter_topology(topology, constraints)

        # Find k-shortest paths
        try:
            paths = list(nx.shortest_simple_paths(
                topology, source, destination, weight='weight'
            ))[:self.k]
        except nx.NetworkXNoPath:
            return RouteResult(candidates=[])

        # Convert to candidates with modulation
        candidates = []
        for path in paths:
            path_tuple = tuple(path)
            weight_km = self._calculate_path_weight(path_tuple, topology)
            modulation = self._select_modulation(weight_km, bandwidth_gbps)

            if modulation is None:
                continue  # Path too long for any modulation

            candidates.append(RouteCandidate(
                path=path_tuple,
                modulation=modulation,
                weight_km=weight_km,
                available_bandwidth_gbps=self._get_available_bandwidth(
                    path_tuple, network_state
                ),
            ))

        return RouteResult(candidates=candidates)
```

### LoadBalancedStrategy

```python
class LoadBalancedStrategy:
    """Load-balanced routing considering link utilization."""

    def __init__(self, k: int = 3, utilization_weight: float = 0.5):
        self.k = k
        self.utilization_weight = utilization_weight
        self._name = "load_balanced"

    def select_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        constraints: RouteConstraints | None = None,
    ) -> RouteResult:
        """Select routes considering link utilization."""
        # Get k-shortest paths
        base_paths = self._get_k_shortest(source, destination, network_state)

        # Score each path by utilization
        candidates = []
        for path in base_paths:
            utilization = self._calculate_path_utilization(path, network_state)
            weight_km = self._calculate_path_weight(path, network_state.topology)

            # Combined score: shorter and less utilized is better
            score = (1 - self.utilization_weight) * (1 / weight_km) + \
                    self.utilization_weight * (1 - utilization)

            modulation = self._select_modulation(weight_km, bandwidth_gbps)
            if modulation is None:
                continue

            candidates.append(RouteCandidate(
                path=path,
                modulation=modulation,
                weight_km=weight_km,
                available_bandwidth_gbps=self._get_available_bandwidth(
                    path, network_state
                ),
                score=score,
            ))

        # Sort by score (higher is better)
        candidates.sort(key=lambda c: c.score, reverse=True)
        return RouteResult(candidates=candidates)
```

### ProtectionAwareStrategy

```python
class ProtectionAwareStrategy:
    """Strategy for finding disjoint working/protection paths."""

    def __init__(self, node_disjoint: bool = False):
        self.node_disjoint = node_disjoint
        self._name = "protection_aware"

    def select_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        constraints: RouteConstraints | None = None,
    ) -> RouteResult:
        """Select disjoint path pairs for protection."""
        if constraints and constraints.protection_mode:
            return self._select_protection_path(
                source, destination, bandwidth_gbps,
                network_state, constraints
            )
        else:
            return self._select_working_path(
                source, destination, bandwidth_gbps, network_state
            )

    def _select_protection_path(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        constraints: RouteConstraints,
    ) -> RouteResult:
        """Find protection path disjoint from working path."""
        # Working path links/nodes to exclude
        exclude_links = constraints.exclude_links or set()
        exclude_nodes = constraints.exclude_nodes if self.node_disjoint else None

        # Build filtered topology
        filtered = self._filter_topology(
            network_state.topology,
            exclude_links,
            exclude_nodes,
        )

        # Find paths in filtered graph
        return self._find_paths_in_topology(
            filtered, source, destination, bandwidth_gbps
        )
```

## RoutingPipeline Integration

### RoutingPipeline with Strategy

```python
class RoutingPipeline:
    """Pipeline for route selection using pluggable strategies."""

    def __init__(
        self,
        strategy: RoutingStrategy,
        modulation_selector: ModulationSelector,
    ):
        self.strategy = strategy
        self.modulation_selector = modulation_selector

    def find_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        forced_path: list[str] | None = None,
        mode: RoutingMode = RoutingMode.WORKING,
        exclude_links: set[tuple[str, str]] | None = None,
        exclude_nodes: set[str] | None = None,
    ) -> RouteResult:
        """
        Find candidate routes using configured strategy.

        Args:
            source: Source node
            destination: Destination node
            bandwidth_gbps: Required bandwidth
            network_state: Current network state
            forced_path: Optional forced path (from grooming)
            mode: WORKING or PROTECTION
            exclude_links: Links to avoid (for protection)
            exclude_nodes: Nodes to avoid (for protection)

        Returns:
            RouteResult with candidate routes
        """
        # Handle forced path (from partial grooming)
        if forced_path:
            return self._handle_forced_path(
                forced_path, bandwidth_gbps, network_state
            )

        # Build constraints
        constraints = RouteConstraints(
            exclude_links=exclude_links,
            exclude_nodes=exclude_nodes,
            protection_mode=(mode == RoutingMode.PROTECTION),
        )

        # Delegate to strategy
        return self.strategy.select_routes(
            source, destination, bandwidth_gbps, network_state, constraints
        )
```

## PipelineFactory Strategy Selection

### Strategy Selection Logic

```python
class PipelineFactory:
    """Factory for creating pipelines with appropriate strategies."""

    @staticmethod
    def _create_routing_strategy(config: SimulationConfig) -> RoutingStrategy:
        """Create routing strategy based on config."""
        strategy_name = config.routing_strategy

        if strategy_name == "k_shortest":
            return KShortestPathStrategy(k=config.k_paths)

        elif strategy_name == "load_balanced":
            return LoadBalancedStrategy(
                k=config.k_paths,
                utilization_weight=config.load_balance_weight,
            )

        elif strategy_name == "protection_aware":
            return ProtectionAwareStrategy(
                node_disjoint=config.node_disjoint_protection,
            )

        elif strategy_name == "ml_routing":
            return MLRoutingStrategy(
                model_path=config.ml_model_path,
                fallback=KShortestPathStrategy(k=config.k_paths),
            )

        else:
            # Default to k-shortest
            logger.warning(
                f"Unknown routing strategy '{strategy_name}', using k_shortest"
            )
            return KShortestPathStrategy(k=config.k_paths)

    @staticmethod
    def create_pipeline_set(config: SimulationConfig) -> PipelineSet:
        """Create complete pipeline set."""
        # Create routing strategy
        strategy = PipelineFactory._create_routing_strategy(config)

        # Create routing pipeline with strategy
        routing = RoutingPipeline(
            strategy=strategy,
            modulation_selector=ModulationSelector(config),
        )

        # Create other pipelines...
        return PipelineSet(
            routing=routing,
            spectrum=...,
            grooming=...,
            snr=...,
            slicing=...,
        )
```

## Configuration

```ini
# config.ini
[routing]
strategy = k_shortest  # k_shortest | load_balanced | protection_aware | ml_routing
k_paths = 3
load_balance_weight = 0.5  # For load_balanced strategy
node_disjoint = false  # For protection_aware strategy
```

```python
@dataclass
class RoutingConfig:
    """Routing configuration."""
    strategy: str = "k_shortest"
    k_paths: int = 3
    load_balance_weight: float = 0.5
    node_disjoint_protection: bool = False
    ml_model_path: str | None = None
```

## ML/RL Strategy Interface

### MLRoutingStrategy (Future)

```python
class MLRoutingStrategy:
    """ML-based routing strategy for RL integration."""

    def __init__(
        self,
        model_path: str | None,
        fallback: RoutingStrategy,
    ):
        self.model = self._load_model(model_path)
        self.fallback = fallback
        self._name = "ml_routing"

    def select_routes(
        self,
        source: str,
        destination: str,
        bandwidth_gbps: int,
        network_state: NetworkState,
        constraints: RouteConstraints | None = None,
    ) -> RouteResult:
        """Select routes using ML model."""
        if self.model is None:
            return self.fallback.select_routes(
                source, destination, bandwidth_gbps,
                network_state, constraints
            )

        # Extract observation for model
        obs = self._extract_observation(
            source, destination, bandwidth_gbps, network_state
        )

        # Get model prediction (route ranking)
        ranking = self.model.predict(obs)

        # Get candidate paths and rank by model
        candidates = self._get_candidates_with_ranking(
            source, destination, bandwidth_gbps,
            network_state, ranking
        )

        return RouteResult(candidates=candidates)

    def _extract_observation(self, ...):
        """Extract observation vector for ML model."""
        # Network state features
        # Request features
        # Historical features
        pass
```

## Verification Checklist

- [ ] RoutingStrategy protocol defined
- [ ] KShortestPathStrategy implemented
- [ ] LoadBalancedStrategy implemented
- [ ] ProtectionAwareStrategy implemented
- [ ] PipelineFactory selects strategy from config
- [ ] RoutingPipeline delegates to strategy
- [ ] Constraints properly passed
- [ ] Unit tests for each strategy
- [ ] Integration tests with orchestrator

## Related Documents

- `.claude/v4-docs/decisions/0008-routing-strategy-pattern.md` - ADR
- `P3.1.b_design_pipeline_set.md` - Pipeline set design
- `P3.2.g_protection_pipeline_integration.md` - Protection integration
