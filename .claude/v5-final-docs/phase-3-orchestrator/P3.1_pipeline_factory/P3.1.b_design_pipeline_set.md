# Task ID: P3.1.b - Design PipelineSet Dataclass

**Sub-phase:** P3.1
**Scope:** Phase 3 - Orchestrator & Pipelines only
**Task type:** design

## Purpose

Design the `PipelineSet` dataclass that holds references to all pipelines used by the orchestrator.

## Context to load before running this task

- `.claude/v5-final-docs/phase-3-orchestrator/P3.1_pipeline_factory/P3.1.shared_context_pipeline_selection_rules.md`
- `.claude/v5-final-docs/phase-2-state-management/P2.3_pipeline_protocols/P2.3.index.md`
- `.claude/v4-docs/migration/phase_3_orchestrator.md` (P3.1 section)

## Outputs

### 1. PipelineSet Dataclass Design

```python
# fusion/core/pipeline_factory.py (partial)

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from fusion.interfaces.pipelines import (
        GroomingPipeline,
        RoutingPipeline,
        SlicingPipeline,
        SNRPipeline,
        SpectrumPipeline,
    )


@dataclass(frozen=False, slots=True)
class PipelineSet:
    """
    Container for all pipelines used by SDNOrchestrator.

    This dataclass holds references to pipeline implementations that
    will be called by the orchestrator during request handling.

    Required pipelines (always present):
    - routing: Finds candidate paths
    - spectrum: Finds available spectrum slots

    Optional pipelines (may be None if feature disabled):
    - grooming: Grooms requests onto existing lightpaths
    - snr: Validates signal quality
    - slicing: Slices large requests across multiple lightpaths

    Example:
        >>> config = SimulationConfig.from_engine_props(engine_props)
        >>> pipelines = PipelineFactory.create_pipeline_set(config)
        >>> print(pipelines.routing)
        <RoutingAdapter>
        >>> print(pipelines.grooming)
        None  # if grooming_enabled=False

    Phase: P3.1 - Pipeline Factory Scaffolding
    """

    # Required pipelines
    routing: RoutingPipeline
    spectrum: SpectrumPipeline

    # Optional pipelines (None if feature disabled)
    grooming: GroomingPipeline | None = None
    snr: SNRPipeline | None = None
    slicing: SlicingPipeline | None = None

    def __post_init__(self) -> None:
        """Validate required pipelines are present."""
        if self.routing is None:
            raise ValueError("PipelineSet requires a routing pipeline")
        if self.spectrum is None:
            raise ValueError("PipelineSet requires a spectrum pipeline")

    @property
    def has_grooming(self) -> bool:
        """Check if grooming is available."""
        return self.grooming is not None

    @property
    def has_snr(self) -> bool:
        """Check if SNR validation is available."""
        return self.snr is not None

    @property
    def has_slicing(self) -> bool:
        """Check if slicing is available."""
        return self.slicing is not None

    def __repr__(self) -> str:
        """Readable representation showing pipeline types."""
        parts = [
            f"routing={type(self.routing).__name__}",
            f"spectrum={type(self.spectrum).__name__}",
        ]
        if self.grooming:
            parts.append(f"grooming={type(self.grooming).__name__}")
        if self.snr:
            parts.append(f"snr={type(self.snr).__name__}")
        if self.slicing:
            parts.append(f"slicing={type(self.slicing).__name__}")
        return f"PipelineSet({', '.join(parts)})"
```

### 2. Design Decisions

| Decision | Rationale |
|----------|-----------|
| `frozen=False` | Allows replacing pipelines for testing |
| `slots=True` | Memory efficient, faster attribute access |
| Required vs Optional | Routing and spectrum always needed; others feature-gated |
| Type hints with `TYPE_CHECKING` | Avoids circular imports |
| Helper properties | `has_grooming`, etc. for cleaner orchestrator code |

### 3. Usage Patterns

#### Creating PipelineSet via Factory

```python
# Standard creation
config = SimulationConfig.from_engine_props(engine_props)
pipelines = PipelineFactory.create_pipeline_set(config)

# Pipelines are then passed to orchestrator
orchestrator = SDNOrchestrator(config, pipelines)
```

#### Checking Optional Pipelines

```python
# In orchestrator
if pipelines.has_grooming:
    groom_result = pipelines.grooming.try_groom(request, network_state)
```

#### Testing with Mock Pipelines

```python
# Create mock pipelines for testing
mock_routing = MockRoutingPipeline()
mock_spectrum = MockSpectrumPipeline()

test_pipelines = PipelineSet(
    routing=mock_routing,
    spectrum=mock_spectrum,
    grooming=None,
    snr=None,
    slicing=None,
)
```

### 4. Type Safety Considerations

The design ensures type safety:

```python
# This would fail type checking (routing is required)
bad_pipelines = PipelineSet(
    routing=None,  # Error: expected RoutingPipeline, got None
    spectrum=mock_spectrum,
)

# This is valid (optional pipelines can be None)
good_pipelines = PipelineSet(
    routing=mock_routing,
    spectrum=mock_spectrum,
    grooming=None,  # OK: Optional field
)
```

### 5. Integration with Orchestrator

The orchestrator receives PipelineSet in constructor:

```python
class SDNOrchestrator:
    def __init__(self, config: SimulationConfig, pipelines: PipelineSet):
        self.config = config
        # Extract pipelines for direct access
        self.routing = pipelines.routing
        self.spectrum = pipelines.spectrum
        self.grooming = pipelines.grooming
        self.snr = pipelines.snr
        self.slicing = pipelines.slicing
```

## Verification

After implementation, verify:
- [ ] `PipelineSet` is a dataclass with correct fields
- [ ] Required fields cannot be `None` (post_init validation)
- [ ] Optional fields default to `None`
- [ ] Helper properties work correctly
- [ ] `mypy --strict` passes

## Next Task

After completing this design, proceed to `P3.1.c_implement_pipeline_factory.md`.
