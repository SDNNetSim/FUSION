# Task ID: P1.5.c - Implement Recording Methods

**Sub-phase**: P1.5 Stats Collector
**Scope**: Phase 1 - Core Domain Model only
**Task type**: refactor-plan

---

## Purpose

Implement the `record_arrival()`, `record_snr()`, and `record_release()` methods.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.5_stats_collector/P1.5.b_implement_stats_collector.md`
- `fusion/domain/request.py` (Request, BlockReason)
- `fusion/domain/results.py` (AllocationResult)

---

## Outputs

### Replace method stubs in `fusion/stats/collector.py`

```python
    def record_arrival(
        self,
        request: "Request",
        result: "AllocationResult",
    ) -> None:
        """
        Record the outcome of a request arrival.

        This is the primary recording method, called by SimulationEngine
        after each arrival is processed. Updates all relevant counters
        based on the allocation result.

        Args:
            request: The request that was processed
            result: The allocation result (success or blocked)

        Example:
            >>> stats.record_arrival(request, result)
            >>> stats.total_requests
            1
        """
        # Update request counter
        self.total_requests += 1
        self.total_bandwidth_requested_gbps += request.bandwidth_gbps

        if result.success:
            self._record_success(request, result)
        else:
            self._record_block(result)

    def _record_success(
        self,
        request: "Request",
        result: "AllocationResult",
    ) -> None:
        """
        Record a successful allocation.

        Args:
            request: The routed request
            result: The successful allocation result
        """
        self.successful_requests += 1
        self.total_bandwidth_allocated_gbps += result.total_bandwidth_allocated_gbps

        # Feature tracking
        if result.is_groomed:
            self.groomed_requests += 1
        if result.is_partially_groomed:
            self.partially_groomed_requests += 1
        if result.is_sliced:
            self.sliced_requests += 1
        if result.is_protected:
            self.protected_requests += 1

        # Modulation tracking
        if result.spectrum_result and result.spectrum_result.modulation:
            modulation = result.spectrum_result.modulation
            self.modulations_used[modulation] += 1

        # SNR tracking from result
        if result.snr_result and result.snr_result.passed:
            self.snr_values.append(result.snr_result.snr_db)

    def _record_block(self, result: "AllocationResult") -> None:
        """
        Record a blocked request.

        Args:
            result: The failed allocation result
        """
        self.blocked_requests += 1

        if result.block_reason is not None:
            reason_str = result.block_reason.value
            self.block_reasons[reason_str] += 1

    def record_snr(self, snr_db: float) -> None:
        """
        Record an SNR measurement.

        Called during SNR validation to track signal quality.
        Can be called multiple times per request (e.g., per link).

        Args:
            snr_db: SNR value in dB

        Example:
            >>> stats.record_snr(18.5)
            >>> stats.record_snr(15.2)
            >>> stats.average_snr
            16.85
        """
        self.snr_values.append(snr_db)

    def record_release(self, request: "Request") -> None:
        """
        Record a request release.

        Called when a request departs and resources are freed.
        In Phase 1, this is a placeholder for future utilization tracking.

        Args:
            request: The request being released

        Note:
            Currently a no-op in Phase 1. Future phases may track:
            - Active request count over time
            - Resource utilization during request lifetime
            - Departure rate metrics
        """
        # Phase 1: No-op (placeholder for future utilization tracking)
        pass
```

---

## Recording Flow

### Success Flow

```
record_arrival(request, result)
    │
    ├── total_requests += 1
    ├── total_bandwidth_requested_gbps += request.bandwidth_gbps
    │
    └── _record_success(request, result)
            │
            ├── successful_requests += 1
            ├── total_bandwidth_allocated_gbps += result.total_bandwidth_allocated_gbps
            │
            ├── if result.is_groomed:
            │       groomed_requests += 1
            │
            ├── if result.is_sliced:
            │       sliced_requests += 1
            │
            ├── if result.is_protected:
            │       protected_requests += 1
            │
            ├── if result.spectrum_result.modulation:
            │       modulations_used[mod] += 1
            │
            └── if result.snr_result.passed:
                    snr_values.append(snr_db)
```

### Block Flow

```
record_arrival(request, result)
    │
    ├── total_requests += 1
    ├── total_bandwidth_requested_gbps += request.bandwidth_gbps
    │
    └── _record_block(result)
            │
            ├── blocked_requests += 1
            │
            └── if result.block_reason:
                    block_reasons[reason.value] += 1
```

---

## Edge Cases

### 1. No Modulation in Result

```python
# Groomed request may not have spectrum_result
if result.spectrum_result and result.spectrum_result.modulation:
    self.modulations_used[modulation] += 1
```

### 2. No SNR in Result

```python
# SNR disabled or not applicable
if result.snr_result and result.snr_result.passed:
    self.snr_values.append(result.snr_result.snr_db)
```

### 3. Partially Groomed Counts Both

```python
# Partially groomed increments its own counter, not groomed
if result.is_groomed:
    self.groomed_requests += 1
if result.is_partially_groomed:
    self.partially_groomed_requests += 1
```

---

## Verification

```python
def test_record_arrival_success():
    config = SimulationConfig(...)
    stats = StatsCollector(config)

    request = Request(request_id=1, bandwidth_gbps=100, ...)
    result = AllocationResult.success_new_lightpath(
        lightpath_id=42,
        bandwidth_gbps=100,
    )

    stats.record_arrival(request, result)

    assert stats.total_requests == 1
    assert stats.successful_requests == 1
    assert stats.blocked_requests == 0
    assert stats.blocking_probability == 0.0

def test_record_arrival_blocked():
    config = SimulationConfig(...)
    stats = StatsCollector(config)

    request = Request(request_id=1, bandwidth_gbps=100, ...)
    result = AllocationResult.blocked(BlockReason.NO_ROUTE)

    stats.record_arrival(request, result)

    assert stats.total_requests == 1
    assert stats.successful_requests == 0
    assert stats.blocked_requests == 1
    assert stats.blocking_probability == 1.0
    assert stats.block_reasons["no_route"] == 1

def test_record_snr():
    config = SimulationConfig(...)
    stats = StatsCollector(config)

    stats.record_snr(18.5)
    stats.record_snr(15.5)

    assert len(stats.snr_values) == 2
    assert stats.average_snr == 17.0
```

---

## Next Task

Proceed to [P1.5.d_implement_export_methods.md](P1.5.d_implement_export_methods.md).
