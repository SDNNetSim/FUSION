# Task ID: P1.5.d - Implement Export Methods

**Sub-phase**: P1.5 Stats Collector
**Scope**: Phase 1 - Core Domain Model only
**Task type**: refactor-plan

---

## Purpose

Implement `to_comparison_format()` and `reset()` methods for StatsCollector.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.5_stats_collector/P1.5.shared_context_stats_props.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.5_stats_collector/P1.5.c_implement_recording_methods.md`

---

## Outputs

### Replace method stubs in `fusion/stats/collector.py`

```python
    def to_comparison_format(self) -> dict[str, Any]:
        """
        Export statistics in run_comparison.py format.

        This method produces a dictionary compatible with the existing
        comparison scripts and result analysis tools.

        Returns:
            Dictionary with the following keys:
                - blocking_probability: float (0.0 to 1.0)
                - success_rate: float (0.0 to 1.0)
                - total_requests: int
                - successful_requests: int
                - blocked_requests: int
                - block_reasons: dict[str, int]
                - grooming_ratio: float
                - slicing_ratio: float
                - protection_ratio: float
                - groomed_requests: int
                - sliced_requests: int
                - protected_requests: int
                - modulations_used: dict[str, int]
                - average_snr: float
                - snr_values: list[float]
                - bandwidth_utilization: float
                - total_bandwidth_requested_gbps: int
                - total_bandwidth_allocated_gbps: int

        Example:
            >>> results = stats.to_comparison_format()
            >>> results["blocking_probability"]
            0.15
        """
        return {
            # Primary metrics
            "blocking_probability": self.blocking_probability,
            "success_rate": self.success_rate,

            # Request counts
            "total_requests": self.total_requests,
            "successful_requests": self.successful_requests,
            "blocked_requests": self.blocked_requests,

            # Block reasons (convert defaultdict to regular dict)
            "block_reasons": dict(self.block_reasons),

            # Feature ratios
            "grooming_ratio": self.grooming_ratio,
            "slicing_ratio": self.slicing_ratio,
            "protection_ratio": self.protection_ratio,

            # Feature counts
            "groomed_requests": self.groomed_requests,
            "partially_groomed_requests": self.partially_groomed_requests,
            "sliced_requests": self.sliced_requests,
            "protected_requests": self.protected_requests,

            # Modulation usage (convert defaultdict to regular dict)
            "modulations_used": dict(self.modulations_used),

            # SNR metrics
            "average_snr": self.average_snr,
            "snr_values": self.snr_values.copy(),  # Copy to prevent mutation

            # Bandwidth metrics
            "bandwidth_utilization": self.bandwidth_utilization,
            "total_bandwidth_requested_gbps": self.total_bandwidth_requested_gbps,
            "total_bandwidth_allocated_gbps": self.total_bandwidth_allocated_gbps,

            # Configuration context
            "config": {
                "network_name": self.config.network_name,
                "erlang": self.config.erlang,
                "num_requests": self.config.num_requests,
                "k_paths": self.config.k_paths,
                "route_method": self.config.route_method,
                "grooming_enabled": self.config.grooming_enabled,
                "slicing_enabled": self.config.slicing_enabled,
                "snr_enabled": self.config.snr_enabled,
            },
        }

    def to_legacy_stats_dict(self) -> dict[str, Any]:
        """
        Export in legacy StatsProps-compatible format.

        This method produces output matching the legacy StatsProps
        structure for gradual migration of existing code.

        Returns:
            Dictionary matching legacy stats structure
        """
        return {
            # Match legacy key names
            "simulation_blocking_list": [self.blocking_probability],
            "block_reasons_dict": dict(self.block_reasons),
            "modulations_used_dict": dict(self.modulations_used),
            "snr_list": self.snr_values.copy(),
        }

    def reset(self) -> None:
        """
        Reset all counters and lists to initial state.

        Called between simulation iterations or when starting
        a new simulation run.

        Example:
            >>> stats.record_arrival(request, result)
            >>> stats.total_requests
            1
            >>> stats.reset()
            >>> stats.total_requests
            0
        """
        # Request counters
        self.total_requests = 0
        self.successful_requests = 0
        self.blocked_requests = 0

        # Block reasons (clear and reset to defaultdict)
        self.block_reasons.clear()

        # Feature tracking
        self.groomed_requests = 0
        self.partially_groomed_requests = 0
        self.sliced_requests = 0
        self.protected_requests = 0

        # Modulation tracking
        self.modulations_used.clear()

        # SNR tracking
        self.snr_values.clear()

        # Bandwidth tracking
        self.total_bandwidth_requested_gbps = 0
        self.total_bandwidth_allocated_gbps = 0

    def __str__(self) -> str:
        """Human-readable summary of statistics."""
        return (
            f"StatsCollector("
            f"total={self.total_requests}, "
            f"success={self.successful_requests}, "
            f"blocked={self.blocked_requests}, "
            f"BP={self.blocking_probability:.2%})"
        )

    def __repr__(self) -> str:
        """Detailed representation for debugging."""
        return (
            f"StatsCollector("
            f"config={self.config.network_name!r}, "
            f"total_requests={self.total_requests}, "
            f"successful_requests={self.successful_requests}, "
            f"blocked_requests={self.blocked_requests}, "
            f"block_reasons={dict(self.block_reasons)}, "
            f"modulations_used={dict(self.modulations_used)})"
        )
```

---

## Export Format Details

### to_comparison_format()

Primary export method for new code:

```python
{
    # Metrics
    "blocking_probability": 0.15,
    "success_rate": 0.85,

    # Counts
    "total_requests": 1000,
    "successful_requests": 850,
    "blocked_requests": 150,

    # Block reasons
    "block_reasons": {
        "no_route": 50,
        "no_spectrum": 80,
        "snr_failure": 20,
    },

    # Feature usage
    "grooming_ratio": 0.3,
    "slicing_ratio": 0.1,
    "protection_ratio": 0.5,

    # Modulation
    "modulations_used": {
        "QPSK": 400,
        "16-QAM": 350,
        "8-QAM": 100,
    },

    # SNR
    "average_snr": 17.5,
    "snr_values": [18.5, 16.2, 17.8, ...],

    # Config context
    "config": {
        "network_name": "NSFNET",
        "erlang": 50.0,
        ...
    },
}
```

### to_legacy_stats_dict()

For compatibility with existing analysis code:

```python
{
    "simulation_blocking_list": [0.15],  # Single value in list
    "block_reasons_dict": {...},
    "modulations_used_dict": {...},
    "snr_list": [...],
}
```

---

## Verification

```python
def test_to_comparison_format():
    config = SimulationConfig(...)
    stats = StatsCollector(config)

    # Record some data
    for i in range(10):
        if i < 8:
            result = AllocationResult.success_new_lightpath(i, 100)
        else:
            result = AllocationResult.blocked(BlockReason.NO_ROUTE)
        request = Request(request_id=i, bandwidth_gbps=100, ...)
        stats.record_arrival(request, result)

    output = stats.to_comparison_format()

    assert output["blocking_probability"] == 0.2
    assert output["total_requests"] == 10
    assert output["successful_requests"] == 8
    assert output["blocked_requests"] == 2
    assert "no_route" in output["block_reasons"]
    assert output["config"]["network_name"] == config.network_name

def test_reset():
    config = SimulationConfig(...)
    stats = StatsCollector(config)

    # Record some data
    stats.record_arrival(request, result)
    assert stats.total_requests == 1

    # Reset
    stats.reset()

    assert stats.total_requests == 0
    assert stats.blocking_probability == 0.0
    assert len(stats.snr_values) == 0
    assert len(stats.block_reasons) == 0

def test_to_legacy_stats_dict():
    config = SimulationConfig(...)
    stats = StatsCollector(config)
    stats.blocked_requests = 2
    stats.total_requests = 10

    legacy = stats.to_legacy_stats_dict()

    assert "simulation_blocking_list" in legacy
    assert legacy["simulation_blocking_list"] == [0.2]
```

---

## Next Task

Proceed to [P1.5.e_verify_stats_collector.md](P1.5.e_verify_stats_collector.md).
