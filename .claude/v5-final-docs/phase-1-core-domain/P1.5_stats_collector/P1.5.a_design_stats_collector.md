# Task ID: P1.5.a - Design StatsCollector

**Sub-phase**: P1.5 Stats Collector
**Scope**: Phase 1 - Core Domain Model only
**Task type**: design

---

## Purpose

Design the `StatsCollector` class API for Phase 1.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.5_stats_collector/P1.5.shared_context_stats_props.md`
- `.claude/v4-docs/architecture/stats_and_metrics.md`
- `.claude/v4-docs/migration/phase_1_core_model.md` (StatsCollector section)

---

## Outputs

### StatsCollector Specification

```python
@dataclass
class StatsCollector:
    """
    Centralized statistics collection for simulation runs.

    StatsCollector aggregates metrics from request processing,
    consuming domain objects (Request, AllocationResult) and
    producing statistics compatible with run_comparison.py.

    Owned by SimulationEngine, receives recording calls after
    each request is processed.

    Attributes:
        config: Simulation configuration (for context)

        Counters:
            total_requests: Total arrivals processed
            successful_requests: Requests that were routed
            blocked_requests: Requests that were blocked

        Block reasons:
            block_reasons: Maps BlockReason -> count

        Feature tracking:
            groomed_requests: Requests using existing capacity
            partially_groomed_requests: Mix of existing and new
            sliced_requests: Requests split across lightpaths
            protected_requests: Requests with 1+1 protection

        Modulation tracking:
            modulations_used: Maps format name -> count

        SNR tracking:
            snr_values: List of SNR measurements

        Bandwidth tracking:
            total_bandwidth_requested_gbps: Sum of all request bandwidths
            total_bandwidth_allocated_gbps: Sum of allocated bandwidths

    Example:
        >>> collector = StatsCollector(config)
        >>> collector.record_arrival(request, result)
        >>> print(collector.blocking_probability)
        0.15
    """

    config: SimulationConfig

    # Request counters
    total_requests: int = 0
    successful_requests: int = 0
    blocked_requests: int = 0

    # Block reasons (uses string keys for compatibility)
    block_reasons: dict[str, int] = field(
        default_factory=lambda: defaultdict(int)
    )

    # Feature tracking
    groomed_requests: int = 0
    partially_groomed_requests: int = 0
    sliced_requests: int = 0
    protected_requests: int = 0

    # Modulation tracking
    modulations_used: dict[str, int] = field(
        default_factory=lambda: defaultdict(int)
    )

    # SNR tracking
    snr_values: list[float] = field(default_factory=list)

    # Bandwidth tracking
    total_bandwidth_requested_gbps: int = 0
    total_bandwidth_allocated_gbps: int = 0
```

---

## API Methods

### Recording Methods

```python
def record_arrival(
    self,
    request: Request,
    result: AllocationResult,
) -> None:
    """
    Record the outcome of a request arrival.

    Called by SimulationEngine after each arrival is processed.
    Updates all relevant counters based on the allocation result.

    Args:
        request: The request that was processed
        result: The allocation result (success or blocked)
    """

def record_snr(self, snr_db: float) -> None:
    """
    Record an SNR measurement.

    Called during SNR validation to track signal quality.

    Args:
        snr_db: SNR value in dB
    """

def record_release(self, request: Request) -> None:
    """
    Record a request release (optional in Phase 1).

    Called when a request departs and resources are freed.
    May be used for utilization tracking in future phases.

    Args:
        request: The request being released
    """
```

### Computed Properties

```python
@property
def blocking_probability(self) -> float:
    """
    Calculate blocking probability.

    Returns:
        Ratio of blocked to total requests (0.0 to 1.0)
    """
    if self.total_requests == 0:
        return 0.0
    return self.blocked_requests / self.total_requests

@property
def success_rate(self) -> float:
    """
    Calculate success rate.

    Returns:
        Ratio of successful to total requests (0.0 to 1.0)
    """
    return 1.0 - self.blocking_probability

@property
def average_snr(self) -> float:
    """
    Calculate average SNR.

    Returns:
        Mean of all recorded SNR values, or 0.0 if none
    """
    if not self.snr_values:
        return 0.0
    return sum(self.snr_values) / len(self.snr_values)

@property
def grooming_ratio(self) -> float:
    """
    Ratio of groomed requests to successful requests.
    """
    if self.successful_requests == 0:
        return 0.0
    return self.groomed_requests / self.successful_requests

@property
def slicing_ratio(self) -> float:
    """
    Ratio of sliced requests to successful requests.
    """
    if self.successful_requests == 0:
        return 0.0
    return self.sliced_requests / self.successful_requests

@property
def protection_ratio(self) -> float:
    """
    Ratio of protected requests to successful requests.
    """
    if self.successful_requests == 0:
        return 0.0
    return self.protected_requests / self.successful_requests

@property
def bandwidth_utilization(self) -> float:
    """
    Ratio of allocated to requested bandwidth.
    """
    if self.total_bandwidth_requested_gbps == 0:
        return 0.0
    return self.total_bandwidth_allocated_gbps / self.total_bandwidth_requested_gbps
```

### Export Methods

```python
def to_comparison_format(self) -> dict[str, Any]:
    """
    Export statistics in run_comparison.py format.

    Returns:
        Dictionary compatible with comparison scripts
    """

def reset(self) -> None:
    """
    Reset all counters and lists.

    Used between simulation iterations.
    """
```

---

## Design Decisions

### 1. Mutable Dataclass (not frozen)

StatsCollector must be mutable to accumulate statistics:
```python
@dataclass  # Not frozen
class StatsCollector:
    total_requests: int = 0
```

### 2. Single Entry Point

All recording goes through `record_arrival()`:
```python
# SimulationEngine calls this once per request
stats.record_arrival(request, result)
```

### 3. BlockReason String Keys

Use string keys for compatibility with legacy code:
```python
block_reasons: dict[str, int]  # "no_route" -> 5

# Recording converts enum to string
self.block_reasons[result.block_reason.value] += 1
```

### 4. Separate SNR Recording

SNR values may be recorded multiple times per request (per link):
```python
for link_snr in snr_result.link_snr_values.values():
    stats.record_snr(link_snr)
```

---

## Usage Pattern

```python
# Initialization (in SimulationEngine)
stats = StatsCollector(config)

# Per request (in simulation loop)
result = orchestrator.handle_arrival(request, network_state)
stats.record_arrival(request, result)

if result.snr_result:
    stats.record_snr(result.snr_result.snr_db)

# Final export
results = stats.to_comparison_format()
```

---

## Next Task

Proceed to [P1.5.b_implement_stats_collector.md](P1.5.b_implement_stats_collector.md).
