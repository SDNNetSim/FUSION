# Task ID: P1.5.e - Verify StatsCollector

**Sub-phase**: P1.5 Stats Collector
**Scope**: Phase 1 - Core Domain Model only
**Task type**: verification-plan

---

## Purpose

Create comprehensive tests for `StatsCollector` achieving 90% code coverage.

---

## Context to load before running this task

- `fusion/stats/collector.py` (complete implementation)
- `.claude/v4-docs/testing/phase_1_testing.md`

---

## Outputs

### Create `fusion/tests/stats/test_collector.py`

```python
"""Tests for StatsCollector."""

from __future__ import annotations

import pytest

from fusion.domain.config import SimulationConfig
from fusion.domain.request import BlockReason, Request, RequestStatus
from fusion.domain.results import (
    AllocationResult,
    GroomingResult,
    SNRResult,
    SpectrumResult,
)
from fusion.stats.collector import StatsCollector


@pytest.fixture
def config() -> SimulationConfig:
    """Create a standard config for testing."""
    return SimulationConfig(
        network_name="NSFNET",
        cores_per_link=1,
        band_list=("c",),
        band_slots={"c": 320},
        guard_slots=1,
        num_requests=1000,
        erlang=50.0,
        holding_time=5.0,
        route_method="k_shortest_path",
        k_paths=3,
        allocation_method="first_fit",
        grooming_enabled=True,
        slicing_enabled=True,
        snr_enabled=True,
    )


@pytest.fixture
def collector(config: SimulationConfig) -> StatsCollector:
    """Create a fresh StatsCollector for each test."""
    return StatsCollector(config)


@pytest.fixture
def sample_request() -> Request:
    """Create a sample request for testing."""
    return Request(
        request_id=1,
        source="0",
        destination="5",
        bandwidth_gbps=100,
        arrive_time=0.0,
        depart_time=5.0,
    )


class TestStatsCollectorCreation:
    """Test StatsCollector initialization."""

    def test_create_collector(self, config: SimulationConfig) -> None:
        """Test basic collector creation."""
        collector = StatsCollector(config)

        assert collector.config is config
        assert collector.total_requests == 0
        assert collector.successful_requests == 0
        assert collector.blocked_requests == 0

    def test_initial_ratios_are_zero(self, collector: StatsCollector) -> None:
        """Test that initial ratios are zero (no division by zero)."""
        assert collector.blocking_probability == 0.0
        assert collector.success_rate == 1.0
        assert collector.average_snr == 0.0
        assert collector.grooming_ratio == 0.0


class TestRecordArrival:
    """Test record_arrival method."""

    def test_record_success(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test recording successful allocation."""
        result = AllocationResult.success_new_lightpath(
            lightpath_id=42,
            bandwidth_gbps=100,
        )

        collector.record_arrival(sample_request, result)

        assert collector.total_requests == 1
        assert collector.successful_requests == 1
        assert collector.blocked_requests == 0
        assert collector.blocking_probability == 0.0

    def test_record_blocked(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test recording blocked request."""
        result = AllocationResult.blocked(BlockReason.NO_ROUTE)

        collector.record_arrival(sample_request, result)

        assert collector.total_requests == 1
        assert collector.successful_requests == 0
        assert collector.blocked_requests == 1
        assert collector.blocking_probability == 1.0
        assert collector.block_reasons["no_route"] == 1

    def test_record_multiple_arrivals(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test recording multiple arrivals."""
        success = AllocationResult.success_new_lightpath(1, 100)
        blocked = AllocationResult.blocked(BlockReason.NO_SPECTRUM)

        for i in range(8):
            collector.record_arrival(sample_request, success)
        for i in range(2):
            collector.record_arrival(sample_request, blocked)

        assert collector.total_requests == 10
        assert collector.successful_requests == 8
        assert collector.blocked_requests == 2
        assert collector.blocking_probability == 0.2

    def test_record_groomed_request(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test recording groomed request."""
        result = AllocationResult.success_groomed(
            lightpath_ids=[10],
            bandwidth_gbps=100,
        )

        collector.record_arrival(sample_request, result)

        assert collector.groomed_requests == 1
        assert collector.grooming_ratio == 1.0

    def test_record_partially_groomed_request(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test recording partially groomed request."""
        result = AllocationResult.success_partial_groom(
            groomed_ids=[10],
            new_lightpath_id=20,
            total_bandwidth=100,
        )

        collector.record_arrival(sample_request, result)

        assert collector.partially_groomed_requests == 1
        assert collector.grooming_ratio == 1.0  # Includes partial

    def test_record_sliced_request(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test recording sliced request."""
        result = AllocationResult.success_sliced(
            lightpath_ids=[1, 2, 3, 4],
            bandwidth_gbps=100,
        )

        collector.record_arrival(sample_request, result)

        assert collector.sliced_requests == 1
        assert collector.slicing_ratio == 1.0

    def test_record_protected_request(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test recording protected request."""
        result = AllocationResult.success_new_lightpath(
            lightpath_id=42,
            bandwidth_gbps=100,
            is_protected=True,
        )

        collector.record_arrival(sample_request, result)

        assert collector.protected_requests == 1
        assert collector.protection_ratio == 1.0

    def test_record_modulation_usage(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test modulation tracking."""
        spectrum = SpectrumResult(
            is_free=True,
            start_slot=0,
            end_slot=8,
            modulation="QPSK",
            slots_needed=8,
        )
        result = AllocationResult.success_new_lightpath(
            lightpath_id=42,
            bandwidth_gbps=100,
            spectrum_result=spectrum,
        )

        collector.record_arrival(sample_request, result)

        assert collector.modulations_used["QPSK"] == 1

    def test_record_snr_from_result(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test SNR tracking from result."""
        snr = SNRResult.success(snr_db=18.5, required_snr_db=15.0)
        result = AllocationResult.success_new_lightpath(
            lightpath_id=42,
            bandwidth_gbps=100,
            snr_result=snr,
        )

        collector.record_arrival(sample_request, result)

        assert len(collector.snr_values) == 1
        assert collector.snr_values[0] == 18.5

    def test_record_bandwidth_tracking(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test bandwidth tracking."""
        result = AllocationResult.success_new_lightpath(
            lightpath_id=42,
            bandwidth_gbps=100,
        )

        collector.record_arrival(sample_request, result)

        assert collector.total_bandwidth_requested_gbps == 100
        assert collector.total_bandwidth_allocated_gbps == 100
        assert collector.bandwidth_utilization == 1.0

    def test_record_blocked_tracks_bandwidth(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test that blocked requests still track requested bandwidth."""
        result = AllocationResult.blocked(BlockReason.NO_ROUTE)

        collector.record_arrival(sample_request, result)

        assert collector.total_bandwidth_requested_gbps == 100
        assert collector.total_bandwidth_allocated_gbps == 0
        assert collector.bandwidth_utilization == 0.0


class TestRecordSNR:
    """Test record_snr method."""

    def test_record_single_snr(self, collector: StatsCollector) -> None:
        """Test recording single SNR value."""
        collector.record_snr(18.5)

        assert len(collector.snr_values) == 1
        assert collector.average_snr == 18.5

    def test_record_multiple_snr(self, collector: StatsCollector) -> None:
        """Test recording multiple SNR values."""
        collector.record_snr(18.0)
        collector.record_snr(16.0)
        collector.record_snr(20.0)

        assert len(collector.snr_values) == 3
        assert collector.average_snr == 18.0  # Mean


class TestRecordRelease:
    """Test record_release method."""

    def test_record_release_noop(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test that record_release is a no-op in Phase 1."""
        # Should not raise
        collector.record_release(sample_request)

        # No state changes
        assert collector.total_requests == 0


class TestComputedProperties:
    """Test computed properties."""

    def test_blocking_probability(self, collector: StatsCollector) -> None:
        """Test blocking probability calculation."""
        collector.total_requests = 100
        collector.blocked_requests = 15

        assert collector.blocking_probability == 0.15

    def test_success_rate(self, collector: StatsCollector) -> None:
        """Test success rate calculation."""
        collector.total_requests = 100
        collector.blocked_requests = 15

        assert collector.success_rate == 0.85

    def test_average_snr_empty(self, collector: StatsCollector) -> None:
        """Test average SNR with no values."""
        assert collector.average_snr == 0.0

    def test_grooming_ratio_includes_partial(
        self, collector: StatsCollector
    ) -> None:
        """Test that grooming ratio includes partially groomed."""
        collector.successful_requests = 100
        collector.groomed_requests = 20
        collector.partially_groomed_requests = 10

        assert collector.grooming_ratio == 0.3


class TestToComparisonFormat:
    """Test to_comparison_format method."""

    def test_basic_export(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test basic export format."""
        result = AllocationResult.success_new_lightpath(42, 100)
        collector.record_arrival(sample_request, result)

        output = collector.to_comparison_format()

        assert "blocking_probability" in output
        assert "total_requests" in output
        assert "successful_requests" in output
        assert "block_reasons" in output
        assert "modulations_used" in output
        assert "config" in output

    def test_export_contains_config(self, collector: StatsCollector) -> None:
        """Test that export contains config context."""
        output = collector.to_comparison_format()

        assert output["config"]["network_name"] == "NSFNET"
        assert output["config"]["erlang"] == 50.0
        assert output["config"]["grooming_enabled"] is True

    def test_export_block_reasons_is_regular_dict(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test that block_reasons is exported as regular dict."""
        result = AllocationResult.blocked(BlockReason.NO_ROUTE)
        collector.record_arrival(sample_request, result)

        output = collector.to_comparison_format()

        # Should be regular dict, not defaultdict
        assert type(output["block_reasons"]) is dict

    def test_export_snr_values_is_copy(
        self, collector: StatsCollector
    ) -> None:
        """Test that snr_values is a copy."""
        collector.record_snr(18.5)
        output = collector.to_comparison_format()

        # Modify the output
        output["snr_values"].append(999.0)

        # Original should not be affected
        assert len(collector.snr_values) == 1


class TestToLegacyStatsDict:
    """Test to_legacy_stats_dict method."""

    def test_legacy_format(self, collector: StatsCollector) -> None:
        """Test legacy export format."""
        collector.total_requests = 100
        collector.blocked_requests = 20

        legacy = collector.to_legacy_stats_dict()

        assert "simulation_blocking_list" in legacy
        assert legacy["simulation_blocking_list"] == [0.2]
        assert "block_reasons_dict" in legacy
        assert "modulations_used_dict" in legacy
        assert "snr_list" in legacy


class TestReset:
    """Test reset method."""

    def test_reset_counters(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test that reset clears counters."""
        result = AllocationResult.success_new_lightpath(42, 100)
        collector.record_arrival(sample_request, result)
        collector.record_snr(18.5)

        collector.reset()

        assert collector.total_requests == 0
        assert collector.successful_requests == 0
        assert collector.blocked_requests == 0
        assert len(collector.snr_values) == 0
        assert len(collector.block_reasons) == 0
        assert len(collector.modulations_used) == 0

    def test_reset_preserves_config(
        self, collector: StatsCollector, config: SimulationConfig
    ) -> None:
        """Test that reset preserves config."""
        collector.reset()

        assert collector.config is config


class TestStringRepresentation:
    """Test __str__ and __repr__ methods."""

    def test_str(self, collector: StatsCollector) -> None:
        """Test string representation."""
        collector.total_requests = 100
        collector.successful_requests = 85
        collector.blocked_requests = 15

        s = str(collector)

        assert "100" in s
        assert "85" in s
        assert "15" in s
        assert "15.00%" in s

    def test_repr(self, collector: StatsCollector) -> None:
        """Test detailed representation."""
        r = repr(collector)

        assert "StatsCollector" in r
        assert "NSFNET" in r


class TestIntegration:
    """Integration tests for StatsCollector."""

    def test_full_simulation_flow(
        self, collector: StatsCollector, sample_request: Request
    ) -> None:
        """Test full simulation recording flow."""
        # Simulate mixed results
        spectrum = SpectrumResult(
            is_free=True, start_slot=0, end_slot=8, modulation="QPSK", slots_needed=8
        )
        snr = SNRResult.success(18.0, 15.0)

        for i in range(100):
            if i < 70:
                # Success
                result = AllocationResult.success_new_lightpath(
                    i, 100, spectrum_result=spectrum, snr_result=snr
                )
            elif i < 85:
                # Blocked - no spectrum
                result = AllocationResult.blocked(BlockReason.NO_SPECTRUM)
            elif i < 95:
                # Blocked - SNR failure
                result = AllocationResult.blocked(BlockReason.SNR_FAILURE)
            else:
                # Blocked - no route
                result = AllocationResult.blocked(BlockReason.NO_ROUTE)

            collector.record_arrival(sample_request, result)

        # Verify final statistics
        assert collector.total_requests == 100
        assert collector.successful_requests == 70
        assert collector.blocked_requests == 30
        assert collector.blocking_probability == 0.3

        assert collector.block_reasons["no_spectrum"] == 15
        assert collector.block_reasons["snr_failure"] == 10
        assert collector.block_reasons["no_route"] == 5

        assert collector.modulations_used["QPSK"] == 70
        assert len(collector.snr_values) == 70

        # Export and verify
        output = collector.to_comparison_format()
        assert output["blocking_probability"] == 0.3
        assert output["block_reasons"]["no_spectrum"] == 15
```

---

## Verification Commands

```bash
# Run tests with verbose output
pytest fusion/tests/stats/test_collector.py -v

# Check coverage
pytest fusion/tests/stats/test_collector.py --cov=fusion/stats/collector --cov-report=term-missing

# Verify at least 90% coverage
pytest fusion/tests/stats/test_collector.py --cov=fusion/stats/collector --cov-fail-under=90

# Type check
mypy fusion/stats/collector.py fusion/tests/stats/test_collector.py

# Lint
ruff check fusion/stats/ fusion/tests/stats/
ruff format --check fusion/stats/ fusion/tests/stats/

# Ensure existing tests still pass
pytest tests/ -v --ignore=fusion/tests/
```

---

## Coverage Target: 90%

The test suite covers:
- All creation paths
- All recording methods and edge cases
- All computed properties
- All export methods
- Reset functionality
- String representations
- Integration flow

---

## Phase 1 Complete

After P1.5.e is verified, Phase 1 Core Domain Model is complete.

**Summary of Phase 1 outputs**:
- `fusion/domain/config.py` - SimulationConfig
- `fusion/domain/request.py` - Request, RequestStatus, BlockReason
- `fusion/domain/lightpath.py` - Lightpath
- `fusion/domain/results.py` - All result dataclasses
- `fusion/stats/collector.py` - StatsCollector

All with 90-95% test coverage.
