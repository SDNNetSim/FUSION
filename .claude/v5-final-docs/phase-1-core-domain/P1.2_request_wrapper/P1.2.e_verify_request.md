# Task ID: P1.2.e - Verify Request

**Sub-phase**: P1.2 Request Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: verification-plan

---

## Purpose

Create comprehensive tests for `Request`, `RequestStatus`, and `BlockReason` achieving 95% code coverage.

---

## Context to load before running this task

- `fusion/domain/request.py` (complete implementation from P1.2.b-d)
- `.claude/v4-docs/testing/phase_1_testing.md`

---

## Outputs

### Create `fusion/tests/domain/test_request.py`

```python
"""Tests for Request, RequestStatus, and BlockReason."""

from __future__ import annotations

import pytest

from fusion.domain.request import BlockReason, Request, RequestStatus


class TestRequestStatus:
    """Test RequestStatus enum."""

    def test_all_statuses_exist(self) -> None:
        """Verify all expected statuses are defined."""
        assert RequestStatus.PENDING
        assert RequestStatus.ROUTED
        assert RequestStatus.BLOCKED
        assert RequestStatus.RELEASED

    def test_is_terminal(self) -> None:
        """Test terminal state detection."""
        assert not RequestStatus.PENDING.is_terminal()
        assert not RequestStatus.ROUTED.is_terminal()
        assert RequestStatus.BLOCKED.is_terminal()
        assert RequestStatus.RELEASED.is_terminal()

    def test_valid_transitions_from_pending(self) -> None:
        """Test valid transitions from PENDING."""
        assert RequestStatus.PENDING.can_transition_to(RequestStatus.ROUTED)
        assert RequestStatus.PENDING.can_transition_to(RequestStatus.BLOCKED)
        assert not RequestStatus.PENDING.can_transition_to(RequestStatus.RELEASED)
        assert not RequestStatus.PENDING.can_transition_to(RequestStatus.PENDING)

    def test_valid_transitions_from_routed(self) -> None:
        """Test valid transitions from ROUTED."""
        assert RequestStatus.ROUTED.can_transition_to(RequestStatus.RELEASED)
        assert not RequestStatus.ROUTED.can_transition_to(RequestStatus.PENDING)
        assert not RequestStatus.ROUTED.can_transition_to(RequestStatus.BLOCKED)

    def test_no_transitions_from_terminal(self) -> None:
        """Test no transitions from terminal states."""
        for target in RequestStatus:
            assert not RequestStatus.BLOCKED.can_transition_to(target)
            assert not RequestStatus.RELEASED.can_transition_to(target)


class TestBlockReason:
    """Test BlockReason enum."""

    def test_all_reasons_exist(self) -> None:
        """Verify all expected block reasons are defined."""
        assert BlockReason.NO_ROUTE
        assert BlockReason.NO_SPECTRUM
        assert BlockReason.CONGESTION
        assert BlockReason.SNR_FAILURE
        assert BlockReason.XT_FAILURE
        assert BlockReason.NO_MODULATION
        assert BlockReason.PROTECTION_UNAVAILABLE
        assert BlockReason.GROOMING_FAILED
        assert BlockReason.SLICING_FAILED
        assert BlockReason.NETWORK_FAILURE

    def test_from_legacy_string_standard(self) -> None:
        """Test conversion from standard legacy strings."""
        assert BlockReason.from_legacy_string("no_route") == BlockReason.NO_ROUTE
        assert BlockReason.from_legacy_string("congestion") == BlockReason.CONGESTION
        assert BlockReason.from_legacy_string("snr_failure") == BlockReason.SNR_FAILURE

    def test_from_legacy_string_mapped(self) -> None:
        """Test conversion from mapped legacy strings."""
        assert BlockReason.from_legacy_string("distance") == BlockReason.NO_MODULATION
        assert BlockReason.from_legacy_string("xt_threshold") == BlockReason.XT_FAILURE
        assert BlockReason.from_legacy_string("failure") == BlockReason.NETWORK_FAILURE

    def test_from_legacy_string_none(self) -> None:
        """Test conversion from None or empty string."""
        assert BlockReason.from_legacy_string(None) is None
        assert BlockReason.from_legacy_string("") is None

    def test_from_legacy_string_unknown(self) -> None:
        """Test unknown legacy string raises ValueError."""
        with pytest.raises(ValueError, match="Unknown block reason"):
            BlockReason.from_legacy_string("unknown_reason")

    def test_to_legacy_string(self) -> None:
        """Test conversion to legacy string."""
        assert BlockReason.NO_ROUTE.to_legacy_string() == "no_route"
        assert BlockReason.CONGESTION.to_legacy_string() == "congestion"
        assert BlockReason.SNR_FAILURE.to_legacy_string() == "snr_failure"


class TestRequestCreation:
    """Test Request instantiation."""

    def test_create_minimal_request(self) -> None:
        """Test creating request with required fields only."""
        request = Request(
            request_id=1,
            source="0",
            destination="5",
            bandwidth_gbps=100,
            arrive_time=0.0,
            depart_time=5.0,
        )

        assert request.request_id == 1
        assert request.source == "0"
        assert request.destination == "5"
        assert request.bandwidth_gbps == 100
        assert request.status == RequestStatus.PENDING
        assert request.lightpath_ids == []
        assert request.block_reason is None

    def test_create_full_request(self) -> None:
        """Test creating request with all fields."""
        request = Request(
            request_id=42,
            source="NYC",
            destination="LAX",
            bandwidth_gbps=400,
            arrive_time=10.5,
            depart_time=20.5,
            modulation_formats={"QPSK": {"slots": 4}},
            is_protected=True,
        )

        assert request.modulation_formats == {"QPSK": {"slots": 4}}
        assert request.is_protected is True
        assert request.is_groomed is False

    def test_default_feature_flags(self) -> None:
        """Test default values for feature flags."""
        request = Request(
            request_id=1,
            source="0",
            destination="1",
            bandwidth_gbps=50,
            arrive_time=0.0,
            depart_time=1.0,
        )

        assert request.is_groomed is False
        assert request.is_partially_groomed is False
        assert request.is_sliced is False
        assert request.is_protected is False


class TestRequestValidation:
    """Test Request validation in __post_init__."""

    def test_same_source_destination(self) -> None:
        """Test that same source and destination raises ValueError."""
        with pytest.raises(ValueError, match="source and destination cannot be the same"):
            Request(
                request_id=1,
                source="0",
                destination="0",
                bandwidth_gbps=100,
                arrive_time=0.0,
                depart_time=5.0,
            )

    def test_zero_bandwidth(self) -> None:
        """Test that zero bandwidth raises ValueError."""
        with pytest.raises(ValueError, match="bandwidth_gbps must be > 0"):
            Request(
                request_id=1,
                source="0",
                destination="1",
                bandwidth_gbps=0,
                arrive_time=0.0,
                depart_time=5.0,
            )

    def test_negative_bandwidth(self) -> None:
        """Test that negative bandwidth raises ValueError."""
        with pytest.raises(ValueError, match="bandwidth_gbps must be > 0"):
            Request(
                request_id=1,
                source="0",
                destination="1",
                bandwidth_gbps=-100,
                arrive_time=0.0,
                depart_time=5.0,
            )

    def test_depart_before_arrive(self) -> None:
        """Test that depart_time <= arrive_time raises ValueError."""
        with pytest.raises(ValueError, match="depart_time must be > arrive_time"):
            Request(
                request_id=1,
                source="0",
                destination="1",
                bandwidth_gbps=100,
                arrive_time=10.0,
                depart_time=5.0,
            )

    def test_depart_equals_arrive(self) -> None:
        """Test that depart_time == arrive_time raises ValueError."""
        with pytest.raises(ValueError, match="depart_time must be > arrive_time"):
            Request(
                request_id=1,
                source="0",
                destination="1",
                bandwidth_gbps=100,
                arrive_time=5.0,
                depart_time=5.0,
            )


class TestRequestComputedProperties:
    """Test Request computed properties."""

    @pytest.fixture
    def request(self) -> Request:
        """Create a standard request for testing."""
        return Request(
            request_id=42,
            source="A",
            destination="B",
            bandwidth_gbps=100,
            arrive_time=10.0,
            depart_time=25.0,
        )

    def test_is_arrival(self, request: Request) -> None:
        """Test is_arrival property."""
        assert request.is_arrival is True
        request.mark_routed([1])
        assert request.is_arrival is False

    def test_is_successful(self, request: Request) -> None:
        """Test is_successful property."""
        assert request.is_successful is False
        request.mark_routed([1])
        assert request.is_successful is True

    def test_is_blocked(self, request: Request) -> None:
        """Test is_blocked property."""
        assert request.is_blocked is False
        request.mark_blocked(BlockReason.NO_ROUTE)
        assert request.is_blocked is True

    def test_is_released(self, request: Request) -> None:
        """Test is_released property."""
        assert request.is_released is False
        request.mark_routed([1])
        request.mark_released()
        assert request.is_released is True

    def test_is_terminal(self, request: Request) -> None:
        """Test is_terminal property."""
        assert request.is_terminal is False
        request.mark_blocked(BlockReason.CONGESTION)
        assert request.is_terminal is True

    def test_endpoint_key(self, request: Request) -> None:
        """Test endpoint_key is sorted."""
        assert request.endpoint_key == ("A", "B")

        # Verify reverse direction produces same key
        reverse = Request(
            request_id=43,
            source="B",
            destination="A",
            bandwidth_gbps=100,
            arrive_time=0.0,
            depart_time=1.0,
        )
        assert reverse.endpoint_key == ("A", "B")

    def test_holding_time(self, request: Request) -> None:
        """Test holding_time calculation."""
        assert request.holding_time == 15.0  # 25.0 - 10.0

    def test_num_lightpaths(self, request: Request) -> None:
        """Test num_lightpaths property."""
        assert request.num_lightpaths == 0
        request.mark_routed([1, 2, 3])
        assert request.num_lightpaths == 3


class TestRequestStateTransitions:
    """Test Request state transition methods."""

    @pytest.fixture
    def request(self) -> Request:
        """Create a fresh request for each test."""
        return Request(
            request_id=1,
            source="0",
            destination="1",
            bandwidth_gbps=100,
            arrive_time=0.0,
            depart_time=5.0,
        )

    def test_mark_routed(self, request: Request) -> None:
        """Test successful routing transition."""
        request.mark_routed([10, 20])

        assert request.status == RequestStatus.ROUTED
        assert request.lightpath_ids == [10, 20]
        assert request.block_reason is None

    def test_mark_routed_clears_block_reason(self, request: Request) -> None:
        """Test that mark_routed clears any block_reason."""
        # Simulate some intermediate state with block_reason
        request.block_reason = BlockReason.CONGESTION
        request.mark_routed([1])
        assert request.block_reason is None

    def test_mark_routed_copies_list(self, request: Request) -> None:
        """Test that lightpath_ids is copied, not aliased."""
        ids = [1, 2, 3]
        request.mark_routed(ids)
        ids.append(4)
        assert request.lightpath_ids == [1, 2, 3]  # Not affected

    def test_mark_routed_empty_ids_raises(self, request: Request) -> None:
        """Test that empty lightpath_ids raises ValueError."""
        with pytest.raises(ValueError, match="Must provide at least one lightpath_id"):
            request.mark_routed([])

    def test_mark_routed_from_invalid_state(self, request: Request) -> None:
        """Test invalid transition to ROUTED."""
        request.mark_blocked(BlockReason.NO_ROUTE)
        with pytest.raises(ValueError, match="Cannot transition from"):
            request.mark_routed([1])

    def test_mark_blocked(self, request: Request) -> None:
        """Test blocking transition."""
        request.mark_blocked(BlockReason.SNR_FAILURE)

        assert request.status == RequestStatus.BLOCKED
        assert request.block_reason == BlockReason.SNR_FAILURE

    def test_mark_blocked_from_invalid_state(self, request: Request) -> None:
        """Test invalid transition to BLOCKED."""
        request.mark_routed([1])
        with pytest.raises(ValueError, match="Cannot transition from"):
            request.mark_blocked(BlockReason.CONGESTION)

    def test_mark_released(self, request: Request) -> None:
        """Test release transition."""
        request.mark_routed([1])
        request.mark_released()

        assert request.status == RequestStatus.RELEASED

    def test_mark_released_from_pending(self, request: Request) -> None:
        """Test invalid release from PENDING."""
        with pytest.raises(ValueError, match="Cannot transition from"):
            request.mark_released()

    def test_full_lifecycle(self, request: Request) -> None:
        """Test complete request lifecycle."""
        assert request.status == RequestStatus.PENDING
        request.mark_routed([1, 2])
        assert request.status == RequestStatus.ROUTED
        request.mark_released()
        assert request.status == RequestStatus.RELEASED


class TestRequestLegacyConversion:
    """Test Request legacy adapter methods."""

    def test_from_legacy_dict_basic(self) -> None:
        """Test basic conversion from legacy dict."""
        legacy = {
            "req_id": 42,
            "source": "0",
            "destination": "5",
            "arrive": 12.345,
            "depart": 17.890,
            "bandwidth": "100Gbps",
        }
        request = Request.from_legacy_dict((42, 12.345), legacy)

        assert request.request_id == 42
        assert request.source == "0"
        assert request.destination == "5"
        assert request.bandwidth_gbps == 100
        assert request.arrive_time == 12.345
        assert request.depart_time == 17.890
        assert request.status == RequestStatus.PENDING

    def test_from_legacy_dict_with_modformats(self) -> None:
        """Test conversion with modulation formats."""
        legacy = {
            "req_id": 1,
            "source": "A",
            "destination": "B",
            "arrive": 0.0,
            "depart": 5.0,
            "bandwidth": "50Gbps",
            "mod_formats": {"QPSK": {"slots": 4, "reach": 2000}},
        }
        request = Request.from_legacy_dict((1, 0.0), legacy)

        assert request.modulation_formats == {"QPSK": {"slots": 4, "reach": 2000}}

    def test_from_legacy_dict_bandwidth_formats(self) -> None:
        """Test various bandwidth string formats."""
        base = {
            "req_id": 1,
            "source": "0",
            "destination": "1",
            "arrive": 0.0,
            "depart": 1.0,
        }

        # "100Gbps"
        base["bandwidth"] = "100Gbps"
        assert Request.from_legacy_dict((1, 0.0), base).bandwidth_gbps == 100

        # "100 Gbps" (with space)
        base["bandwidth"] = "100 Gbps"
        assert Request.from_legacy_dict((1, 0.0), base).bandwidth_gbps == 100

        # "100gbps" (lowercase)
        base["bandwidth"] = "100gbps"
        assert Request.from_legacy_dict((1, 0.0), base).bandwidth_gbps == 100

        # Integer passthrough
        base["bandwidth"] = 100
        assert Request.from_legacy_dict((1, 0.0), base).bandwidth_gbps == 100

    def test_from_legacy_dict_numeric_nodes(self) -> None:
        """Test that numeric node IDs are converted to strings."""
        legacy = {
            "req_id": 1,
            "source": 0,
            "destination": 5,
            "arrive": 0.0,
            "depart": 1.0,
            "bandwidth": "100Gbps",
        }
        request = Request.from_legacy_dict((1, 0.0), legacy)

        assert request.source == "0"
        assert request.destination == "5"

    def test_from_legacy_dict_request_id_priority(self) -> None:
        """Test request_id parameter takes priority."""
        legacy = {
            "req_id": 42,
            "source": "0",
            "destination": "1",
            "arrive": 0.0,
            "depart": 1.0,
            "bandwidth": "100Gbps",
        }
        # Override with parameter
        request = Request.from_legacy_dict((42, 0.0), legacy, request_id=99)
        assert request.request_id == 99

    def test_to_legacy_dict_basic(self) -> None:
        """Test basic conversion to legacy dict."""
        request = Request(
            request_id=42,
            source="0",
            destination="5",
            bandwidth_gbps=100,
            arrive_time=12.345,
            depart_time=17.890,
        )
        legacy = request.to_legacy_dict()

        assert legacy["req_id"] == 42
        assert legacy["source"] == "0"
        assert legacy["destination"] == "5"
        assert legacy["arrive"] == 12.345
        assert legacy["depart"] == 17.890
        assert legacy["bandwidth"] == "100Gbps"
        assert legacy["request_type"] == "arrival"

    def test_to_legacy_dict_released(self) -> None:
        """Test request_type is 'release' for RELEASED status."""
        request = Request(
            request_id=1,
            source="0",
            destination="1",
            bandwidth_gbps=100,
            arrive_time=0.0,
            depart_time=5.0,
        )
        request.mark_routed([1])
        request.mark_released()
        legacy = request.to_legacy_dict()

        assert legacy["request_type"] == "release"

    def test_to_legacy_time_key(self) -> None:
        """Test legacy time key generation."""
        request = Request(
            request_id=42,
            source="0",
            destination="1",
            bandwidth_gbps=100,
            arrive_time=10.0,
            depart_time=20.0,
        )

        # Pending -> use arrive_time
        assert request.to_legacy_time_key() == (42, 10.0)

        # Released -> use depart_time
        request.mark_routed([1])
        request.mark_released()
        assert request.to_legacy_time_key() == (42, 20.0)


class TestRequestRoundtrip:
    """Test roundtrip conversion preserves data."""

    def test_roundtrip_basic(self) -> None:
        """Test basic roundtrip conversion."""
        original = {
            "req_id": 42,
            "source": "0",
            "destination": "5",
            "arrive": 12.345,
            "depart": 17.890,
            "bandwidth": "100Gbps",
            "mod_formats": {},
        }
        request = Request.from_legacy_dict((42, 12.345), original)
        roundtrip = request.to_legacy_dict()

        assert roundtrip["req_id"] == original["req_id"]
        assert roundtrip["source"] == original["source"]
        assert roundtrip["destination"] == original["destination"]
        assert roundtrip["arrive"] == original["arrive"]
        assert roundtrip["depart"] == original["depart"]
        assert roundtrip["bandwidth"] == original["bandwidth"]

    def test_roundtrip_with_modformats(self) -> None:
        """Test roundtrip with modulation formats."""
        original = {
            "req_id": 1,
            "source": "A",
            "destination": "B",
            "arrive": 0.0,
            "depart": 5.0,
            "bandwidth": "50Gbps",
            "mod_formats": {"QPSK": {"slots": 4}},
        }
        request = Request.from_legacy_dict((1, 0.0), original)
        roundtrip = request.to_legacy_dict()

        assert roundtrip["mod_formats"] == original["mod_formats"]
```

---

## Verification Commands

```bash
# Run tests with verbose output
pytest fusion/tests/domain/test_request.py -v

# Check coverage
pytest fusion/tests/domain/test_request.py --cov=fusion/domain/request --cov-report=term-missing

# Verify at least 95% coverage
pytest fusion/tests/domain/test_request.py --cov=fusion/domain/request --cov-fail-under=95

# Type check
mypy fusion/domain/request.py fusion/tests/domain/test_request.py

# Lint
ruff check fusion/domain/ fusion/tests/domain/
ruff format --check fusion/domain/ fusion/tests/domain/

# Ensure existing tests still pass
pytest tests/ -v --ignore=fusion/tests/
```

---

## Coverage Target: 95%

The test suite covers:
- All enum values and methods
- All Request creation paths
- All validation cases
- All computed properties
- All state transitions (valid and invalid)
- All legacy adapter methods
- Roundtrip conversion

---

## Sub-phase Complete

After P1.2.e is verified, P1.2 Request Wrapper is complete.
Proceed to [P1.3 Lightpath Wrapper](../P1.3_lightpath_wrapper/P1.3.index.md).
