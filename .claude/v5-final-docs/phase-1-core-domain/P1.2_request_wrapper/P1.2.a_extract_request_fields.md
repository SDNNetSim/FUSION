# Task ID: P1.2.a - Extract Request Fields

**Sub-phase**: P1.2 Request Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: context-extraction

---

## Purpose

Extract and document all request-related fields from the current codebase to inform the `Request` dataclass design.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.2_request_wrapper/P1.2.shared_context_request_legacy.md`
- `fusion/core/request.py` (lines 100-160, request generation)
- `fusion/core/properties.py` (lines 321-424, SDNProps)

---

## Outputs

### 1. Request Identity Fields (Immutable)

These fields are set at request creation and never change:

```python
request_id: int      # Unique identifier (from "req_id")
source: str          # Source node ID
destination: str     # Destination node ID
bandwidth_gbps: int  # Requested bandwidth in Gbps (parsed from "50Gbps")
arrive_time: float   # Arrival time (from "arrive")
depart_time: float   # Departure time (from "depart")
```

### 2. Modulation Configuration (Immutable)

```python
modulation_formats: dict[str, dict[str, Any]]
# Maps modulation name -> configuration
# Example: {"QPSK": {"slots": 4, "reach_km": 2000}}
```

### 3. Lifecycle State Fields (Mutable)

These fields change during request processing:

```python
status: RequestStatus       # PENDING -> ROUTED or BLOCKED -> RELEASED
block_reason: BlockReason | None  # Set when status == BLOCKED
lightpath_ids: list[int]   # IDs of lightpaths serving this request
```

### 4. Feature Flags (Mutable)

Set after allocation:

```python
is_groomed: bool = False           # Fully served by existing lightpath
is_partially_groomed: bool = False # Partially served by existing lightpath
is_sliced: bool = False            # Split across multiple lightpaths
is_protected: bool = False         # Has 1+1 protection
```

---

## Field Sources in Current Codebase

| New Field | Source Location | Current Key/Attr |
|-----------|-----------------|------------------|
| `request_id` | request dict | `"req_id"` |
| `source` | request dict | `"source"` |
| `destination` | request dict | `"destination"` |
| `bandwidth_gbps` | request dict | `"bandwidth"` (parse) |
| `arrive_time` | request dict | `"arrive"` |
| `depart_time` | request dict | `"depart"` |
| `modulation_formats` | request dict | `"mod_formats"` |
| `status` | NEW | (derived from processing) |
| `block_reason` | SDNProps | `block_reason` |
| `lightpath_ids` | SDNProps | `lightpath_id_list` |
| `is_groomed` | NEW | (set by grooming logic) |
| `is_partially_groomed` | NEW | (set by grooming logic) |
| `is_sliced` | NEW | (set by slicing logic) |
| `is_protected` | NEW | (set by protection logic) |

---

## Block Reasons Inventory

From codebase analysis, these block reasons are used:

| Current String | Proposed Enum Value | Description |
|----------------|---------------------|-------------|
| `"distance"` | `NO_MODULATION` | No modulation works for distance |
| `"congestion"` | `CONGESTION` | Network congested |
| `"xt_threshold"` | `XT_FAILURE` | Crosstalk exceeded |
| `"failure"` | `NETWORK_FAILURE` | Network failure |
| `"no_route"` | `NO_ROUTE` | No path exists |
| `"snr_failure"` | `SNR_FAILURE` | SNR below threshold |
| (new) | `NO_SPECTRUM` | No contiguous spectrum |
| (new) | `PROTECTION_UNAVAILABLE` | No disjoint backup path |
| (new) | `GROOMING_FAILED` | Grooming not possible |
| (new) | `SLICING_FAILED` | Slicing not possible |

---

## Computed Properties

Properties derived from stored fields:

```python
@property
def is_arrival(self) -> bool:
    """True if request is pending processing."""
    return self.status == RequestStatus.PENDING

@property
def is_successful(self) -> bool:
    """True if request was successfully routed."""
    return self.status == RequestStatus.ROUTED

@property
def is_blocked(self) -> bool:
    """True if request was blocked."""
    return self.status == RequestStatus.BLOCKED

@property
def endpoint_key(self) -> tuple[str, str]:
    """Canonical endpoint pair for lightpath matching."""
    return tuple(sorted([self.source, self.destination]))

@property
def holding_time(self) -> float:
    """Duration of the request."""
    return self.depart_time - self.arrive_time
```

---

## Validation Rules

From `validation_rules.md`:

1. `source != destination` - Cannot route to self
2. `bandwidth_gbps > 0` - Must request positive bandwidth
3. `depart_time > arrive_time` - Departure after arrival
4. Status transitions are valid (see lifecycle diagram)
5. If `status == BLOCKED`, then `block_reason is not None`
6. If `status == ROUTED`, then `len(lightpath_ids) > 0`

---

## Next Task

Proceed to [P1.2.b_design_request_enums.md](P1.2.b_design_request_enums.md) to define the RequestStatus and BlockReason enums.
