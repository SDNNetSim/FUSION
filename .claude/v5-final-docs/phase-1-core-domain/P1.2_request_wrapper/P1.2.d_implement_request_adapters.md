# Task ID: P1.2.d - Implement Request Adapters

**Sub-phase**: P1.2 Request Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: refactor-plan

---

## Purpose

Implement `from_legacy_dict()` and `to_legacy_dict()` methods for bidirectional conversion between `Request` and legacy request dictionaries.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.2_request_wrapper/P1.2.shared_context_request_legacy.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.2_request_wrapper/P1.2.c_implement_request_class.md`
- `fusion/core/request.py` (lines 110-154, legacy request format)

---

## Outputs

### Replace adapter stubs in `fusion/domain/request.py`

```python
    @classmethod
    def from_legacy_dict(
        cls,
        time_key: tuple[int, float],
        request_dict: dict[str, Any],
        request_id: int | None = None,
    ) -> Request:
        """
        Create Request from legacy request dictionary.

        The legacy format stores requests in a dict indexed by (request_id, time).
        Each entry contains fields like "req_id", "source", "bandwidth", etc.

        Args:
            time_key: Tuple of (request_id, time) used as dict key
            request_dict: Legacy request dictionary with fields:
                - "req_id": int - Request identifier
                - "source": str - Source node ID
                - "destination": str - Destination node ID
                - "arrive": float - Arrival time
                - "depart": float - Departure time
                - "bandwidth": str - Bandwidth like "50Gbps" or "100Gbps"
                - "mod_formats": dict - Modulation formats (optional)
                - "request_type": str - "arrival" or "release" (optional)
            request_id: Override request_id (default: from time_key[0] or req_id)

        Returns:
            New Request instance in PENDING state

        Example:
            >>> legacy = {
            ...     "req_id": 42,
            ...     "source": "0",
            ...     "destination": "5",
            ...     "arrive": 12.345,
            ...     "depart": 17.890,
            ...     "bandwidth": "100Gbps",
            ... }
            >>> request = Request.from_legacy_dict((42, 12.345), legacy)
            >>> request.request_id
            42
            >>> request.bandwidth_gbps
            100
        """
        # Determine request_id (priority: parameter > dict > time_key)
        if request_id is None:
            request_id = request_dict.get("req_id", time_key[0])

        # Parse bandwidth string to integer
        bandwidth_str = request_dict.get("bandwidth", "0Gbps")
        if isinstance(bandwidth_str, str):
            # Handle formats like "100Gbps", "50 Gbps", "100"
            bandwidth_gbps = int(
                bandwidth_str.lower()
                .replace("gbps", "")
                .replace(" ", "")
            )
        else:
            bandwidth_gbps = int(bandwidth_str)

        return cls(
            request_id=request_id,
            source=str(request_dict["source"]),
            destination=str(request_dict["destination"]),
            bandwidth_gbps=bandwidth_gbps,
            arrive_time=float(request_dict.get("arrive", time_key[1])),
            depart_time=float(request_dict["depart"]),
            modulation_formats=request_dict.get("mod_formats", {}),
            # State fields start at defaults
            status=RequestStatus.PENDING,
            lightpath_ids=[],
            block_reason=None,
            is_groomed=False,
            is_partially_groomed=False,
            is_sliced=False,
            is_protected=False,
        )

    def to_legacy_dict(self) -> dict[str, Any]:
        """
        Convert to legacy request dictionary format.

        This enables interoperability with legacy code that expects
        request dictionaries during the migration period.

        Returns:
            Dictionary compatible with legacy request consumers:
                - "req_id": int - Request identifier
                - "source": str - Source node ID
                - "destination": str - Destination node ID
                - "arrive": float - Arrival time
                - "depart": float - Departure time
                - "bandwidth": str - Bandwidth as string (e.g., "100Gbps")
                - "mod_formats": dict - Modulation formats
                - "request_type": str - "arrival" or "release"

        Example:
            >>> request = Request(
            ...     request_id=42,
            ...     source="0",
            ...     destination="5",
            ...     bandwidth_gbps=100,
            ...     arrive_time=12.345,
            ...     depart_time=17.890,
            ... )
            >>> legacy = request.to_legacy_dict()
            >>> legacy["bandwidth"]
            '100Gbps'
        """
        # Determine request_type based on status
        if self.status == RequestStatus.PENDING:
            request_type = "arrival"
        elif self.status == RequestStatus.RELEASED:
            request_type = "release"
        else:
            # ROUTED or BLOCKED are intermediate states
            request_type = "arrival"

        return {
            "req_id": self.request_id,
            "source": self.source,
            "destination": self.destination,
            "arrive": self.arrive_time,
            "depart": self.depart_time,
            "bandwidth": f"{self.bandwidth_gbps}Gbps",
            "mod_formats": self.modulation_formats,
            "request_type": request_type,
        }

    def to_legacy_time_key(self) -> tuple[int, float]:
        """
        Generate legacy dictionary key for this request.

        Returns:
            Tuple of (request_id, time) where time depends on status:
            - PENDING: arrive_time
            - RELEASED: depart_time
            - Others: arrive_time
        """
        if self.status == RequestStatus.RELEASED:
            return (self.request_id, self.depart_time)
        return (self.request_id, self.arrive_time)
```

---

## Bandwidth Parsing Details

The legacy format uses strings like `"100Gbps"`. Handle variations:

```python
# All these should parse to 100
"100Gbps"   -> 100
"100 Gbps"  -> 100
"100gbps"   -> 100
"100"       -> 100
100         -> 100 (integer passthrough)
```

---

## Roundtrip Invariant

```python
original = {
    "req_id": 42,
    "source": "0",
    "destination": "5",
    "arrive": 12.345,
    "depart": 17.890,
    "bandwidth": "100Gbps",
    "mod_formats": {"QPSK": {"slots": 4}},
}

request = Request.from_legacy_dict((42, 12.345), original)
roundtrip = request.to_legacy_dict()

# Core fields preserved
assert roundtrip["req_id"] == original["req_id"]
assert roundtrip["source"] == original["source"]
assert roundtrip["destination"] == original["destination"]
assert roundtrip["bandwidth"] == original["bandwidth"]
assert roundtrip["arrive"] == original["arrive"]
assert roundtrip["depart"] == original["depart"]
```

---

## Edge Cases

### 1. Missing Optional Fields

```python
# Minimal valid legacy dict
minimal = {
    "source": "0",
    "destination": "5",
    "depart": 10.0,
}
# Should use defaults
request = Request.from_legacy_dict((1, 0.0), minimal)
assert request.arrive_time == 0.0  # From time_key
```

### 2. Numeric Node IDs

```python
# Source/destination might be integers in some topologies
legacy = {"source": 0, "destination": 5, ...}
request = Request.from_legacy_dict(...)
assert request.source == "0"  # Always string
```

### 3. Empty Modulation Formats

```python
legacy = {..., "mod_formats": None}  # or missing
request = Request.from_legacy_dict(...)
assert request.modulation_formats == {}
```

---

## Verification

```python
def test_from_legacy_basic():
    legacy = {
        "req_id": 42,
        "source": "0",
        "destination": "5",
        "arrive": 12.345,
        "depart": 17.890,
        "bandwidth": "100Gbps",
    }
    request = Request.from_legacy_dict((42, 12.345), legacy)

    assert request.request_id == 42
    assert request.source == "0"
    assert request.destination == "5"
    assert request.bandwidth_gbps == 100
    assert request.status == RequestStatus.PENDING

def test_to_legacy_basic():
    request = Request(
        request_id=42,
        source="0",
        destination="5",
        bandwidth_gbps=100,
        arrive_time=12.345,
        depart_time=17.890,
    )
    legacy = request.to_legacy_dict()

    assert legacy["req_id"] == 42
    assert legacy["bandwidth"] == "100Gbps"
    assert legacy["request_type"] == "arrival"

def test_roundtrip():
    original = {
        "req_id": 42,
        "source": "0",
        "destination": "5",
        "arrive": 12.345,
        "depart": 17.890,
        "bandwidth": "100Gbps",
        "mod_formats": {"QPSK": {"slots": 4}},
    }
    request = Request.from_legacy_dict((42, 12.345), original)
    roundtrip = request.to_legacy_dict()

    assert roundtrip["req_id"] == original["req_id"]
    assert roundtrip["source"] == original["source"]
    assert roundtrip["bandwidth"] == original["bandwidth"]
```

---

## Next Task

Proceed to [P1.2.e_verify_request.md](P1.2.e_verify_request.md) to create comprehensive tests.
