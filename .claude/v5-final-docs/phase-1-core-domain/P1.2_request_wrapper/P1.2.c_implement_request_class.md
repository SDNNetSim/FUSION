# Task ID: P1.2.c - Implement Request Class

**Sub-phase**: P1.2 Request Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: refactor-plan

---

## Purpose

Implement the `Request` mutable dataclass with all fields, computed properties, and validation.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.2_request_wrapper/P1.2.b_design_request_enums.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.2_request_wrapper/P1.2.a_extract_request_fields.md`
- `.claude/v4-docs/migration/phase_1_core_model.md` (Request section)

---

## Outputs

### Add `Request` class to `fusion/domain/request.py`

After the enum definitions, add:

```python
@dataclass
class Request:
    """
    Network service request with lifecycle tracking.

    A Request represents a bandwidth demand between two network nodes.
    It tracks the full lifecycle from arrival through allocation to release.

    Attributes:
        Identity (immutable after creation):
            request_id: Unique identifier
            source: Source node ID
            destination: Destination node ID
            bandwidth_gbps: Requested bandwidth in Gbps
            arrive_time: Simulation time of arrival
            depart_time: Simulation time of departure
            modulation_formats: Available modulation formats for this request

        State (mutable during processing):
            status: Current lifecycle state (PENDING -> ROUTED/BLOCKED -> RELEASED)
            lightpath_ids: IDs of lightpaths serving this request
            block_reason: Reason for blocking (if status == BLOCKED)

        Feature flags (mutable):
            is_groomed: Fully served by existing lightpath capacity
            is_partially_groomed: Partially served by existing lightpath
            is_sliced: Split across multiple lightpaths
            is_protected: Has 1+1 path protection

    Example:
        >>> request = Request(
        ...     request_id=42,
        ...     source="0",
        ...     destination="5",
        ...     bandwidth_gbps=100,
        ...     arrive_time=12.345,
        ...     depart_time=17.890,
        ... )
        >>> request.status
        <RequestStatus.PENDING: 1>
        >>> request.is_arrival
        True
    """

    # =========================================================================
    # Identity Fields (effectively immutable after creation)
    # =========================================================================
    request_id: int
    source: str
    destination: str
    bandwidth_gbps: int
    arrive_time: float
    depart_time: float
    modulation_formats: dict[str, dict[str, Any]] = field(default_factory=dict)

    # =========================================================================
    # Lifecycle State (mutable)
    # =========================================================================
    status: RequestStatus = RequestStatus.PENDING
    lightpath_ids: list[int] = field(default_factory=list)
    block_reason: BlockReason | None = None

    # =========================================================================
    # Feature Flags (mutable)
    # =========================================================================
    is_groomed: bool = False
    is_partially_groomed: bool = False
    is_sliced: bool = False
    is_protected: bool = False

    # =========================================================================
    # Validation
    # =========================================================================
    def __post_init__(self) -> None:
        """Validate request after creation."""
        if self.source == self.destination:
            raise ValueError("source and destination cannot be the same")
        if self.bandwidth_gbps <= 0:
            raise ValueError("bandwidth_gbps must be > 0")
        if self.depart_time <= self.arrive_time:
            raise ValueError("depart_time must be > arrive_time")

    # =========================================================================
    # Computed Properties
    # =========================================================================
    @property
    def is_arrival(self) -> bool:
        """True if request is pending processing (arrival event)."""
        return self.status == RequestStatus.PENDING

    @property
    def is_successful(self) -> bool:
        """True if request was successfully routed."""
        return self.status == RequestStatus.ROUTED

    @property
    def is_blocked(self) -> bool:
        """True if request was blocked."""
        return self.status == RequestStatus.BLOCKED

    @property
    def is_released(self) -> bool:
        """True if request has been released."""
        return self.status == RequestStatus.RELEASED

    @property
    def is_terminal(self) -> bool:
        """True if request is in a terminal state."""
        return self.status.is_terminal()

    @property
    def endpoint_key(self) -> tuple[str, str]:
        """
        Canonical endpoint pair for lightpath matching.

        Returns sorted tuple to ensure (A, B) == (B, A) for endpoint matching.
        """
        return tuple(sorted([self.source, self.destination]))  # type: ignore[return-value]

    @property
    def holding_time(self) -> float:
        """Duration of the request in simulation time units."""
        return self.depart_time - self.arrive_time

    @property
    def num_lightpaths(self) -> int:
        """Number of lightpaths serving this request."""
        return len(self.lightpath_ids)

    # =========================================================================
    # State Transition Methods
    # =========================================================================
    def mark_routed(self, lightpath_ids: list[int]) -> None:
        """
        Mark request as successfully routed.

        Args:
            lightpath_ids: IDs of lightpaths allocated for this request

        Raises:
            ValueError: If transition is invalid or no lightpaths provided
        """
        if not self.status.can_transition_to(RequestStatus.ROUTED):
            raise ValueError(f"Cannot transition from {self.status} to ROUTED")
        if not lightpath_ids:
            raise ValueError("Must provide at least one lightpath_id")

        self.status = RequestStatus.ROUTED
        self.lightpath_ids = list(lightpath_ids)  # Copy to avoid aliasing
        self.block_reason = None

    def mark_blocked(self, reason: BlockReason) -> None:
        """
        Mark request as blocked.

        Args:
            reason: Reason for blocking

        Raises:
            ValueError: If transition is invalid
        """
        if not self.status.can_transition_to(RequestStatus.BLOCKED):
            raise ValueError(f"Cannot transition from {self.status} to BLOCKED")

        self.status = RequestStatus.BLOCKED
        self.block_reason = reason

    def mark_released(self) -> None:
        """
        Mark request as released (resources freed).

        Raises:
            ValueError: If transition is invalid
        """
        if not self.status.can_transition_to(RequestStatus.RELEASED):
            raise ValueError(f"Cannot transition from {self.status} to RELEASED")

        self.status = RequestStatus.RELEASED

    # =========================================================================
    # Legacy Adapters (stubs - implemented in P1.2.d)
    # =========================================================================
    @classmethod
    def from_legacy_dict(
        cls,
        time_key: tuple[int, float],
        request_dict: dict[str, Any],
        request_id: int | None = None,
    ) -> Request:
        """
        Create Request from legacy request dictionary.

        Args:
            time_key: Tuple of (request_id, time) used as dict key
            request_dict: Legacy request dictionary
            request_id: Override request_id (default: from time_key)

        Returns:
            New Request instance
        """
        raise NotImplementedError("Implement in P1.2.d")

    def to_legacy_dict(self) -> dict[str, Any]:
        """
        Convert to legacy request dictionary format.

        Returns:
            Dictionary compatible with legacy code
        """
        raise NotImplementedError("Implement in P1.2.d")
```

---

## Design Decisions

### 1. Mutable Dataclass (not frozen)

`Request` is mutable because:
- Status changes during lifecycle (PENDING -> ROUTED -> RELEASED)
- Feature flags are set after allocation
- Lightpath IDs are added during routing

### 2. Explicit Transition Methods

Instead of allowing direct status assignment:
```python
# Discouraged
request.status = RequestStatus.ROUTED

# Preferred - validates transition
request.mark_routed(lightpath_ids=[1, 2])
```

### 3. Defensive Copying

`mark_routed()` copies the lightpath_ids list to prevent aliasing:
```python
self.lightpath_ids = list(lightpath_ids)  # Copy
```

### 4. endpoint_key for Lightpath Matching

Sorted tuple ensures bidirectional matching:
```python
req1 = Request(source="A", destination="B", ...)
req2 = Request(source="B", destination="A", ...)
assert req1.endpoint_key == req2.endpoint_key  # ("A", "B")
```

---

## Update `fusion/domain/__init__.py`

```python
"""FUSION Domain Model Package."""

from fusion.domain.config import SimulationConfig
from fusion.domain.request import BlockReason, Request, RequestStatus

__all__ = [
    "SimulationConfig",
    "Request",
    "RequestStatus",
    "BlockReason",
]
```

---

## Verification

```python
# Test basic creation
def test_create_request():
    req = Request(
        request_id=1,
        source="0",
        destination="5",
        bandwidth_gbps=100,
        arrive_time=0.0,
        depart_time=5.0,
    )
    assert req.status == RequestStatus.PENDING
    assert req.is_arrival

# Test state transitions
def test_state_transitions():
    req = Request(...)
    req.mark_routed([1, 2])
    assert req.status == RequestStatus.ROUTED
    req.mark_released()
    assert req.status == RequestStatus.RELEASED

# Test invalid transition
def test_invalid_transition():
    req = Request(...)
    req.mark_blocked(BlockReason.NO_ROUTE)
    with pytest.raises(ValueError):
        req.mark_routed([1])  # Can't route blocked request
```

---

## Next Task

Proceed to [P1.2.d_implement_request_adapters.md](P1.2.d_implement_request_adapters.md) to implement legacy adapters.
