# Task ID: P1.2.b - Design Request Enums

**Sub-phase**: P1.2 Request Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: design

---

## Purpose

Define the `RequestStatus` and `BlockReason` enums used by the `Request` dataclass.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.2_request_wrapper/P1.2.a_extract_request_fields.md`
- `.claude/v4-docs/migration/phase_1_core_model.md` (Request section)

---

## Outputs

### Add to `fusion/domain/request.py`

```python
"""
Request domain model with lifecycle tracking.

This module defines:
- RequestStatus: Enum for request lifecycle states
- BlockReason: Enum for allocation failure reasons
- Request: Mutable dataclass for network service requests
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any


class RequestStatus(Enum):
    """
    Request lifecycle status.

    State Machine:
        PENDING ──success──> ROUTED ──release──> RELEASED
            │
            └──failure──> BLOCKED (terminal)

    Notes:
        - PENDING: Initial state, awaiting processing
        - ROUTED: Successfully allocated resources
        - BLOCKED: Failed allocation (terminal state)
        - RELEASED: Resources freed after holding time (terminal state)
    """

    PENDING = auto()   # Created, not yet processed
    ROUTED = auto()    # Successfully allocated
    BLOCKED = auto()   # Failed allocation (terminal)
    RELEASED = auto()  # Departed, resources freed (terminal)

    def is_terminal(self) -> bool:
        """Check if this is a terminal state."""
        return self in (RequestStatus.BLOCKED, RequestStatus.RELEASED)

    def can_transition_to(self, target: RequestStatus) -> bool:
        """Check if transition to target state is valid."""
        valid_transitions = {
            RequestStatus.PENDING: {RequestStatus.ROUTED, RequestStatus.BLOCKED},
            RequestStatus.ROUTED: {RequestStatus.RELEASED},
            RequestStatus.BLOCKED: set(),  # Terminal
            RequestStatus.RELEASED: set(),  # Terminal
        }
        return target in valid_transitions[self]


class BlockReason(Enum):
    """
    Reasons for request blocking.

    Categories:
        Routing: NO_ROUTE
        Spectrum: NO_SPECTRUM, CONGESTION
        Quality: SNR_FAILURE, XT_FAILURE, NO_MODULATION
        Features: PROTECTION_UNAVAILABLE, GROOMING_FAILED, SLICING_FAILED
        Network: NETWORK_FAILURE
    """

    # Routing failures
    NO_ROUTE = "no_route"
    """No path exists between source and destination."""

    # Spectrum failures
    NO_SPECTRUM = "no_spectrum"
    """No contiguous spectrum available on any path."""

    CONGESTION = "congestion"
    """Network congested, insufficient resources."""

    # Quality failures
    SNR_FAILURE = "snr_failure"
    """Signal-to-noise ratio below threshold."""

    XT_FAILURE = "xt_failure"
    """Crosstalk exceeds acceptable threshold."""

    NO_MODULATION = "no_modulation"
    """No modulation format works for path distance."""

    # Feature-specific failures
    PROTECTION_UNAVAILABLE = "protection_unavailable"
    """No disjoint backup path available for protection."""

    GROOMING_FAILED = "grooming_failed"
    """Traffic grooming not possible."""

    SLICING_FAILED = "slicing_failed"
    """Request slicing failed."""

    # Network failures
    NETWORK_FAILURE = "network_failure"
    """Network failure during processing."""

    @classmethod
    def from_legacy_string(cls, reason: str | None) -> BlockReason | None:
        """
        Convert legacy block reason string to enum.

        Args:
            reason: Legacy string like "distance", "congestion", etc.

        Returns:
            Corresponding BlockReason or None if reason is None/empty.

        Raises:
            ValueError: If reason string is not recognized.
        """
        if reason is None or reason == "":
            return None

        # Legacy string mappings
        legacy_map = {
            "distance": cls.NO_MODULATION,
            "congestion": cls.CONGESTION,
            "xt_threshold": cls.XT_FAILURE,
            "failure": cls.NETWORK_FAILURE,
            "no_route": cls.NO_ROUTE,
            "snr_failure": cls.SNR_FAILURE,
            "no_spectrum": cls.NO_SPECTRUM,
        }

        if reason in legacy_map:
            return legacy_map[reason]

        # Try direct enum value match
        try:
            return cls(reason)
        except ValueError:
            raise ValueError(f"Unknown block reason: {reason}")

    def to_legacy_string(self) -> str:
        """
        Convert to legacy block reason string.

        Returns:
            String value compatible with legacy code.
        """
        return self.value
```

---

## Design Decisions

### 1. RequestStatus Uses auto()

- Values are internal implementation details
- Only enum identity matters for comparisons
- Avoids magic numbers or strings

### 2. BlockReason Uses String Values

- Values match legacy `block_reason` strings where possible
- Enables direct string comparison during migration
- `to_legacy_string()` returns the string value

### 3. State Transition Validation

`RequestStatus.can_transition_to()` enables runtime validation:

```python
if not request.status.can_transition_to(RequestStatus.ROUTED):
    raise ValueError(f"Invalid transition from {request.status}")
```

### 4. Legacy Compatibility

`BlockReason.from_legacy_string()` handles:
- Current strings (`"distance"`, `"congestion"`)
- New enum values (`"no_spectrum"`)
- None/empty -> None

---

## Enum Usage Examples

```python
# Check terminal state
if request.status.is_terminal():
    print("Request processing complete")

# Validate transition
if current.can_transition_to(RequestStatus.ROUTED):
    request.status = RequestStatus.ROUTED

# Convert legacy block reason
reason = BlockReason.from_legacy_string("distance")
assert reason == BlockReason.NO_MODULATION

# Convert to legacy string
legacy = BlockReason.SNR_FAILURE.to_legacy_string()
assert legacy == "snr_failure"
```

---

## Verification

```python
# Test state transitions
def test_valid_transitions():
    assert RequestStatus.PENDING.can_transition_to(RequestStatus.ROUTED)
    assert RequestStatus.PENDING.can_transition_to(RequestStatus.BLOCKED)
    assert RequestStatus.ROUTED.can_transition_to(RequestStatus.RELEASED)
    assert not RequestStatus.BLOCKED.can_transition_to(RequestStatus.ROUTED)

# Test legacy conversion
def test_legacy_block_reason():
    assert BlockReason.from_legacy_string("distance") == BlockReason.NO_MODULATION
    assert BlockReason.from_legacy_string(None) is None
    assert BlockReason.SNR_FAILURE.to_legacy_string() == "snr_failure"
```

---

## Next Task

Proceed to [P1.2.c_implement_request_class.md](P1.2.c_implement_request_class.md) to implement the Request dataclass.
