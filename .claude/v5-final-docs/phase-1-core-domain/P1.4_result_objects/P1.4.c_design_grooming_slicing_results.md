# Task ID: P1.4.c - Design Grooming and Slicing Results

**Sub-phase**: P1.4 Result Objects
**Scope**: Phase 1 - Core Domain Model only
**Task type**: design

---

## Purpose

Design the `GroomingResult` and `SlicingResult` frozen dataclasses.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.shared_context_current_returns.md`
- `.claude/v4-docs/architecture/result_objects.md` (GroomingResult, SlicingResult sections)
- `fusion/core/grooming.py`

---

## Outputs

### GroomingResult Specification

```python
@dataclass(frozen=True)
class GroomingResult:
    """
    Result of grooming pipeline - using existing lightpath capacity.

    Indicates whether a request can be (fully or partially) served
    by existing lightpaths without creating new ones.

    Attributes:
        fully_groomed: Entire request fits in existing lightpaths
        partially_groomed: Some bandwidth groomed, rest needs new LP
        bandwidth_groomed_gbps: Amount successfully groomed
        remaining_bandwidth_gbps: Amount still needing new lightpath
        lightpaths_used: IDs of lightpaths used for grooming
        forced_path: Required path for new lightpath (if partial)

    Invariants:
        - fully_groomed and partially_groomed are mutually exclusive
        - If fully_groomed: remaining_bandwidth_gbps == 0
        - If partially_groomed or fully_groomed: len(lightpaths_used) > 0
        - bandwidth_groomed + remaining_bandwidth == original request
    """

    fully_groomed: bool = False
    partially_groomed: bool = False
    bandwidth_groomed_gbps: int = 0
    remaining_bandwidth_gbps: int = 0
    lightpaths_used: tuple[int, ...] = ()
    forced_path: tuple[str, ...] | None = None

    def __post_init__(self) -> None:
        """Validate grooming result after creation."""
        if self.fully_groomed and self.partially_groomed:
            raise ValueError("fully_groomed and partially_groomed are mutually exclusive")

        if self.fully_groomed and self.remaining_bandwidth_gbps != 0:
            raise ValueError("fully_groomed requires remaining_bandwidth_gbps == 0")

        if (self.fully_groomed or self.partially_groomed) and len(self.lightpaths_used) == 0:
            raise ValueError("groomed requests must have lightpaths_used")

    @property
    def was_groomed(self) -> bool:
        """True if any grooming occurred."""
        return self.fully_groomed or self.partially_groomed

    @property
    def needs_new_lightpath(self) -> bool:
        """True if a new lightpath is still needed."""
        return not self.fully_groomed and self.remaining_bandwidth_gbps > 0

    @classmethod
    def no_grooming(cls, bandwidth_gbps: int) -> GroomingResult:
        """Create result when no grooming is possible."""
        return cls(
            fully_groomed=False,
            partially_groomed=False,
            bandwidth_groomed_gbps=0,
            remaining_bandwidth_gbps=bandwidth_gbps,
            lightpaths_used=(),
        )

    @classmethod
    def full(cls, bandwidth_gbps: int, lightpath_ids: list[int]) -> GroomingResult:
        """Create result for fully groomed request."""
        return cls(
            fully_groomed=True,
            partially_groomed=False,
            bandwidth_groomed_gbps=bandwidth_gbps,
            remaining_bandwidth_gbps=0,
            lightpaths_used=tuple(lightpath_ids),
        )

    @classmethod
    def partial(
        cls,
        bandwidth_groomed: int,
        remaining: int,
        lightpath_ids: list[int],
        forced_path: list[str] | None = None,
    ) -> GroomingResult:
        """Create result for partially groomed request."""
        return cls(
            fully_groomed=False,
            partially_groomed=True,
            bandwidth_groomed_gbps=bandwidth_groomed,
            remaining_bandwidth_gbps=remaining,
            lightpaths_used=tuple(lightpath_ids),
            forced_path=tuple(forced_path) if forced_path else None,
        )
```

---

### SlicingResult Specification

```python
@dataclass(frozen=True)
class SlicingResult:
    """
    Result of slicing pipeline - splitting request across lightpaths.

    When a request is too large for a single lightpath (modulation
    limitations), it may be split into multiple smaller slices.

    Attributes:
        success: Whether slicing succeeded
        num_slices: Number of slices created
        slice_bandwidth_gbps: Bandwidth per slice
        lightpaths_created: IDs of created lightpaths
        total_bandwidth_gbps: Total bandwidth across all slices

    Invariants:
        - If success=True: num_slices > 0 and len(lightpaths_created) == num_slices
        - total_bandwidth_gbps == num_slices * slice_bandwidth_gbps
    """

    success: bool = False
    num_slices: int = 0
    slice_bandwidth_gbps: int = 0
    lightpaths_created: tuple[int, ...] = ()
    total_bandwidth_gbps: int = 0

    def __post_init__(self) -> None:
        """Validate slicing result after creation."""
        if self.success:
            if self.num_slices == 0:
                raise ValueError("success=True requires num_slices > 0")
            if len(self.lightpaths_created) != self.num_slices:
                raise ValueError("lightpaths_created length must match num_slices")

    @property
    def is_sliced(self) -> bool:
        """True if request was sliced (multiple lightpaths)."""
        return self.success and self.num_slices > 1

    @classmethod
    def failed(cls) -> SlicingResult:
        """Create result for failed slicing."""
        return cls(success=False)

    @classmethod
    def single_lightpath(cls, bandwidth_gbps: int, lightpath_id: int) -> SlicingResult:
        """Create result for single lightpath (no slicing needed)."""
        return cls(
            success=True,
            num_slices=1,
            slice_bandwidth_gbps=bandwidth_gbps,
            lightpaths_created=(lightpath_id,),
            total_bandwidth_gbps=bandwidth_gbps,
        )

    @classmethod
    def sliced(
        cls,
        num_slices: int,
        slice_bandwidth: int,
        lightpath_ids: list[int],
    ) -> SlicingResult:
        """Create result for sliced request."""
        return cls(
            success=True,
            num_slices=num_slices,
            slice_bandwidth_gbps=slice_bandwidth,
            lightpaths_created=tuple(lightpath_ids),
            total_bandwidth_gbps=num_slices * slice_bandwidth,
        )
```

---

## Design Decisions

### GroomingResult

1. **Mutually Exclusive Flags**: `fully_groomed` and `partially_groomed` cannot both be True
2. **Forced Path**: When partially groomed, may need to use specific path for remaining
3. **Factory Methods**: `no_grooming()`, `full()`, `partial()` for clear creation

### SlicingResult

1. **Success Flag**: Primary indicator of whether slicing worked
2. **Single Lightpath Case**: `num_slices=1` means no actual slicing occurred
3. **Factory Methods**: `failed()`, `single_lightpath()`, `sliced()`

---

## Usage Examples

### GroomingResult

```python
# No grooming possible
result = GroomingResult.no_grooming(100)
assert not result.was_groomed
assert result.needs_new_lightpath
assert result.remaining_bandwidth_gbps == 100

# Fully groomed
result = GroomingResult.full(100, [1, 2])
assert result.fully_groomed
assert not result.needs_new_lightpath
assert result.lightpaths_used == (1, 2)

# Partially groomed
result = GroomingResult.partial(
    bandwidth_groomed=60,
    remaining=40,
    lightpath_ids=[1],
    forced_path=["0", "2", "5"],
)
assert result.partially_groomed
assert result.needs_new_lightpath
assert result.forced_path == ("0", "2", "5")
```

### SlicingResult

```python
# Failed slicing
result = SlicingResult.failed()
assert not result.success
assert not result.is_sliced

# Single lightpath (no slicing needed)
result = SlicingResult.single_lightpath(100, 42)
assert result.success
assert not result.is_sliced
assert result.num_slices == 1

# Actual slicing
result = SlicingResult.sliced(
    num_slices=4,
    slice_bandwidth=25,
    lightpath_ids=[1, 2, 3, 4],
)
assert result.success
assert result.is_sliced
assert result.total_bandwidth_gbps == 100
```

---

## Next Task

Proceed to [P1.4.d_design_snr_result.md](P1.4.d_design_snr_result.md).
