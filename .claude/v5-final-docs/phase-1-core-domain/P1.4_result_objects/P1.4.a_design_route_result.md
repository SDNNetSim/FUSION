# Task ID: P1.4.a - Design RouteResult

**Sub-phase**: P1.4 Result Objects
**Scope**: Phase 1 - Core Domain Model only
**Task type**: design

---

## Purpose

Design the `RouteResult` frozen dataclass representing routing pipeline output.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.shared_context_current_returns.md`
- `.claude/v4-docs/architecture/result_objects.md` (RouteResult section)
- `fusion/core/properties.py` (RoutingProps class, lines 30-71)

---

## Outputs

### RouteResult Specification

```python
@dataclass(frozen=True)
class RouteResult:
    """
    Result of routing pipeline - candidate paths with modulation options.

    Contains ordered list of candidate paths from best to worst,
    each with associated path weight and valid modulation formats.
    For 1+1 protection, includes disjoint backup paths.

    Attributes:
        paths: List of candidate paths (each path is list of node IDs)
        weights_km: Path lengths/weights in kilometers
        modulations: Valid modulation formats per path
        backup_paths: Disjoint backup paths for 1+1 protection (optional)
        backup_weights_km: Backup path lengths (optional)
        backup_modulations: Modulations for backup paths (optional)
        strategy_name: Name of routing algorithm used
        metadata: Algorithm-specific metadata

    Invariants:
        - len(paths) == len(weights_km) == len(modulations)
        - Each path has at least 2 nodes
        - Weights are non-negative
        - If backup_paths exists: len(backup_paths) == len(paths)
    """

    # Primary path candidates
    paths: tuple[tuple[str, ...], ...]  # Tuple of paths for immutability
    weights_km: tuple[float, ...]
    modulations: tuple[tuple[str, ...], ...]  # Per-path modulation options

    # Backup paths for 1+1 protection (optional)
    backup_paths: tuple[tuple[str, ...], ...] | None = None
    backup_weights_km: tuple[float, ...] | None = None
    backup_modulations: tuple[tuple[str, ...], ...] | None = None

    # Metadata
    strategy_name: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate route result after creation."""
        # Length consistency
        if len(self.paths) != len(self.weights_km):
            raise ValueError("paths and weights_km must have same length")
        if len(self.paths) != len(self.modulations):
            raise ValueError("paths and modulations must have same length")

        # Path validity
        for path in self.paths:
            if len(path) < 2:
                raise ValueError("Each path must have at least 2 nodes")

        # Weight validity
        for weight in self.weights_km:
            if weight < 0:
                raise ValueError("Weights must be non-negative")

        # Backup consistency
        if self.backup_paths is not None:
            if len(self.backup_paths) != len(self.paths):
                raise ValueError("backup_paths must match paths length")

    @property
    def is_empty(self) -> bool:
        """True if no paths found (routing failed)."""
        return len(self.paths) == 0

    @property
    def num_paths(self) -> int:
        """Number of candidate paths."""
        return len(self.paths)

    @property
    def has_protection(self) -> bool:
        """True if backup paths are available."""
        return self.backup_paths is not None and len(self.backup_paths) > 0

    @property
    def best_path(self) -> tuple[str, ...] | None:
        """Best (first) candidate path or None if empty."""
        return self.paths[0] if self.paths else None

    @property
    def best_weight(self) -> float | None:
        """Weight of best path or None if empty."""
        return self.weights_km[0] if self.weights_km else None

    def get_path(self, index: int) -> tuple[str, ...]:
        """Get path at index."""
        return self.paths[index]

    def get_modulations_for_path(self, index: int) -> tuple[str, ...]:
        """Get valid modulations for path at index."""
        return self.modulations[index]

    @classmethod
    def empty(cls, strategy_name: str = "") -> RouteResult:
        """Create empty result (no paths found)."""
        return cls(
            paths=(),
            weights_km=(),
            modulations=(),
            strategy_name=strategy_name,
        )

    @classmethod
    def from_routing_props(cls, routing_props: Any) -> RouteResult:
        """
        Create from legacy RoutingProps.

        Args:
            routing_props: Legacy RoutingProps object

        Returns:
            New RouteResult instance
        """
        # Convert lists to tuples for immutability
        paths = tuple(tuple(p) for p in routing_props.paths_matrix)
        weights = tuple(routing_props.weights_list)
        modulations = tuple(
            tuple(mods) for mods in routing_props.modulation_formats_matrix
        )

        # Handle backup paths if present
        backup_paths = None
        backup_weights = None
        backup_mods = None

        if hasattr(routing_props, 'backup_paths_matrix') and routing_props.backup_paths_matrix:
            backup_paths = tuple(
                tuple(p) if p else () for p in routing_props.backup_paths_matrix
            )
            if hasattr(routing_props, 'backup_weights_list'):
                backup_weights = tuple(routing_props.backup_weights_list)
            if hasattr(routing_props, 'backup_modulation_formats_matrix'):
                backup_mods = tuple(
                    tuple(mods) for mods in routing_props.backup_modulation_formats_matrix
                )

        return cls(
            paths=paths,
            weights_km=weights,
            modulations=modulations,
            backup_paths=backup_paths,
            backup_weights_km=backup_weights,
            backup_modulations=backup_mods,
        )
```

---

## Design Decisions

### 1. Tuples for Immutability

Use nested tuples instead of lists:
```python
paths: tuple[tuple[str, ...], ...]  # Not list[list[str]]
```

This ensures deep immutability for the frozen dataclass.

### 2. Factory Methods

- `empty()` - Create empty result for failed routing
- `from_routing_props()` - Convert from legacy RoutingProps

### 3. Best Path Accessors

Convenience properties for common access pattern:
```python
if not result.is_empty:
    path = result.best_path
    weight = result.best_weight
```

---

## Usage Examples

```python
# Empty result (no routes found)
result = RouteResult.empty(strategy_name="k_shortest_path")
assert result.is_empty
assert result.best_path is None

# Successful routing
result = RouteResult(
    paths=(("0", "2", "5"), ("0", "3", "5")),
    weights_km=(100.0, 120.0),
    modulations=(("QPSK", "16-QAM"), ("QPSK",)),
    strategy_name="k_shortest_path",
)
assert not result.is_empty
assert result.num_paths == 2
assert result.best_path == ("0", "2", "5")

# With protection
result = RouteResult(
    paths=(("0", "2", "5"),),
    weights_km=(100.0,),
    modulations=(("QPSK",),),
    backup_paths=(("0", "3", "5"),),
    backup_weights_km=(120.0,),
    backup_modulations=(("QPSK",),),
    strategy_name="1plus1_protection",
)
assert result.has_protection
```

---

## Next Task

Proceed to [P1.4.b_design_spectrum_result.md](P1.4.b_design_spectrum_result.md).
