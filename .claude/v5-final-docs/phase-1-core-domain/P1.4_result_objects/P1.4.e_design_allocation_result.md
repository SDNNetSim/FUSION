# Task ID: P1.4.e - Design AllocationResult

**Sub-phase**: P1.4 Result Objects
**Scope**: Phase 1 - Core Domain Model only
**Task type**: design

---

## Purpose

Design the `AllocationResult` frozen dataclass - the **final authority** on request outcomes.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.4_result_objects/P1.4.shared_context_current_returns.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.2_request_wrapper/P1.2.b_design_request_enums.md` (BlockReason)
- `.claude/v4-docs/architecture/result_objects.md` (AllocationResult section)

---

## Outputs

### AllocationResult Specification

```python
@dataclass(frozen=True)
class AllocationResult:
    """
    Final result of request allocation - SINGLE SOURCE OF TRUTH.

    This is the authoritative result returned by the orchestrator.
    The `success` field is the final word on whether a request
    was served (fully or partially).

    Attributes:
        success: FINAL AUTHORITY - True if request was served
        lightpaths_created: IDs of newly created lightpaths
        lightpaths_groomed: IDs of existing lightpaths used
        total_bandwidth_allocated_gbps: Total bandwidth allocated

        Feature flags:
            is_groomed: Request used existing lightpath capacity
            is_partially_groomed: Mix of existing and new lightpath
            is_sliced: Request split across multiple lightpaths
            is_protected: Request has 1+1 protection

        Failure info:
            block_reason: BlockReason enum if success=False

        Debug info (nested results):
            route_result: Routing pipeline output
            spectrum_result: Spectrum pipeline output
            grooming_result: Grooming pipeline output
            slicing_result: Slicing pipeline output
            snr_result: SNR validation output

    Invariants:
        - If success=True: len(lightpaths_created) + len(lightpaths_groomed) > 0
        - If success=True: total_bandwidth_allocated_gbps > 0
        - If success=False: block_reason is set
    """

    success: bool

    # Lightpath tracking
    lightpaths_created: tuple[int, ...] = ()
    lightpaths_groomed: tuple[int, ...] = ()
    total_bandwidth_allocated_gbps: int = 0

    # Feature flags
    is_groomed: bool = False
    is_partially_groomed: bool = False
    is_sliced: bool = False
    is_protected: bool = False

    # Failure info
    block_reason: BlockReason | None = None

    # Nested results (for debugging/tracing)
    route_result: RouteResult | None = None
    spectrum_result: SpectrumResult | None = None
    grooming_result: GroomingResult | None = None
    slicing_result: SlicingResult | None = None
    snr_result: SNRResult | None = None

    def __post_init__(self) -> None:
        """Validate allocation result after creation."""
        if self.success:
            # Must have allocated something
            total_lps = len(self.lightpaths_created) + len(self.lightpaths_groomed)
            if total_lps == 0:
                raise ValueError("success=True requires at least one lightpath")
            if self.total_bandwidth_allocated_gbps <= 0:
                raise ValueError("success=True requires total_bandwidth > 0")
        else:
            # Must have a reason for failure
            if self.block_reason is None:
                raise ValueError("success=False requires block_reason")

    @property
    def all_lightpath_ids(self) -> tuple[int, ...]:
        """All lightpath IDs (created + groomed)."""
        return self.lightpaths_created + self.lightpaths_groomed

    @property
    def num_lightpaths(self) -> int:
        """Total number of lightpaths used."""
        return len(self.lightpaths_created) + len(self.lightpaths_groomed)

    @property
    def used_grooming(self) -> bool:
        """True if any grooming was used."""
        return self.is_groomed or self.is_partially_groomed

    @classmethod
    def blocked(
        cls,
        reason: BlockReason,
        route_result: RouteResult | None = None,
        spectrum_result: SpectrumResult | None = None,
        snr_result: SNRResult | None = None,
    ) -> AllocationResult:
        """Create result for blocked request."""
        return cls(
            success=False,
            block_reason=reason,
            route_result=route_result,
            spectrum_result=spectrum_result,
            snr_result=snr_result,
        )

    @classmethod
    def success_new_lightpath(
        cls,
        lightpath_id: int,
        bandwidth_gbps: int,
        route_result: RouteResult | None = None,
        spectrum_result: SpectrumResult | None = None,
        snr_result: SNRResult | None = None,
        is_protected: bool = False,
    ) -> AllocationResult:
        """Create result for successful allocation with new lightpath."""
        return cls(
            success=True,
            lightpaths_created=(lightpath_id,),
            total_bandwidth_allocated_gbps=bandwidth_gbps,
            is_protected=is_protected,
            route_result=route_result,
            spectrum_result=spectrum_result,
            snr_result=snr_result,
        )

    @classmethod
    def success_groomed(
        cls,
        lightpath_ids: list[int],
        bandwidth_gbps: int,
        grooming_result: GroomingResult | None = None,
    ) -> AllocationResult:
        """Create result for fully groomed request."""
        return cls(
            success=True,
            lightpaths_groomed=tuple(lightpath_ids),
            total_bandwidth_allocated_gbps=bandwidth_gbps,
            is_groomed=True,
            grooming_result=grooming_result,
        )

    @classmethod
    def success_partial_groom(
        cls,
        groomed_ids: list[int],
        new_lightpath_id: int,
        total_bandwidth: int,
        grooming_result: GroomingResult | None = None,
        route_result: RouteResult | None = None,
        spectrum_result: SpectrumResult | None = None,
        snr_result: SNRResult | None = None,
    ) -> AllocationResult:
        """Create result for partially groomed request."""
        return cls(
            success=True,
            lightpaths_created=(new_lightpath_id,),
            lightpaths_groomed=tuple(groomed_ids),
            total_bandwidth_allocated_gbps=total_bandwidth,
            is_partially_groomed=True,
            grooming_result=grooming_result,
            route_result=route_result,
            spectrum_result=spectrum_result,
            snr_result=snr_result,
        )

    @classmethod
    def success_sliced(
        cls,
        lightpath_ids: list[int],
        bandwidth_gbps: int,
        slicing_result: SlicingResult | None = None,
        route_result: RouteResult | None = None,
    ) -> AllocationResult:
        """Create result for sliced request."""
        return cls(
            success=True,
            lightpaths_created=tuple(lightpath_ids),
            total_bandwidth_allocated_gbps=bandwidth_gbps,
            is_sliced=True,
            slicing_result=slicing_result,
            route_result=route_result,
        )
```

---

## Design Decisions

### 1. success is FINAL AUTHORITY

The `success` field is the single source of truth:
- `success=True`: Request was served (bandwidth allocated)
- `success=False`: Request was blocked (with reason)

All other fields are supporting details.

### 2. Mandatory Block Reason

When `success=False`, `block_reason` is required:
```python
if not self.success and self.block_reason is None:
    raise ValueError("success=False requires block_reason")
```

### 3. Nested Results for Debugging

All intermediate results are optionally attached:
```python
result = AllocationResult.blocked(
    reason=BlockReason.SNR_FAILURE,
    route_result=route_result,
    spectrum_result=spectrum_result,
    snr_result=snr_result,  # Shows why SNR failed
)
```

### 4. Factory Methods for Common Cases

- `blocked()` - Request failed
- `success_new_lightpath()` - Simple new allocation
- `success_groomed()` - Fully groomed
- `success_partial_groom()` - Mix of grooming and new
- `success_sliced()` - Request sliced

---

## Usage Examples

```python
from fusion.domain.request import BlockReason

# Blocked - no route
result = AllocationResult.blocked(BlockReason.NO_ROUTE)
assert not result.success
assert result.block_reason == BlockReason.NO_ROUTE

# Success - new lightpath
result = AllocationResult.success_new_lightpath(
    lightpath_id=42,
    bandwidth_gbps=100,
    is_protected=True,
)
assert result.success
assert result.lightpaths_created == (42,)
assert result.is_protected

# Success - fully groomed
result = AllocationResult.success_groomed(
    lightpath_ids=[10, 20],
    bandwidth_gbps=100,
)
assert result.success
assert result.is_groomed
assert result.num_lightpaths == 2

# Success - sliced
result = AllocationResult.success_sliced(
    lightpath_ids=[1, 2, 3, 4],
    bandwidth_gbps=400,
)
assert result.success
assert result.is_sliced
assert result.num_lightpaths == 4
```

---

## Relationship to Request State

When the orchestrator returns `AllocationResult`, it updates the `Request`:

```python
if result.success:
    request.mark_routed(list(result.all_lightpath_ids))
    request.is_groomed = result.is_groomed
    request.is_partially_groomed = result.is_partially_groomed
    request.is_sliced = result.is_sliced
    request.is_protected = result.is_protected
else:
    request.mark_blocked(result.block_reason)
```

---

## Next Task

Proceed to [P1.4.f_implement_all_results.md](P1.4.f_implement_all_results.md).
