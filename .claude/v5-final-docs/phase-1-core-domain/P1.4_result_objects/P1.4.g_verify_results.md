# Task ID: P1.4.g - Verify Results

**Sub-phase**: P1.4 Result Objects
**Scope**: Phase 1 - Core Domain Model only
**Task type**: verification-plan

---

## Purpose

Create comprehensive tests for all result dataclasses achieving 90% code coverage.

---

## Context to load before running this task

- `fusion/domain/results.py` (complete implementation from P1.4.f)
- `.claude/v4-docs/testing/phase_1_testing.md`

---

## Outputs

### Create `fusion/tests/domain/test_results.py`

```python
"""Tests for result dataclasses."""

from __future__ import annotations

import pytest

from fusion.domain.request import BlockReason
from fusion.domain.results import (
    AllocationResult,
    GroomingResult,
    RouteResult,
    SlicingResult,
    SNRResult,
    SpectrumResult,
)


# =============================================================================
# RouteResult Tests
# =============================================================================

class TestRouteResult:
    """Test RouteResult dataclass."""

    def test_create_basic_route_result(self) -> None:
        """Test creating basic route result."""
        result = RouteResult(
            paths=(("0", "2", "5"),),
            weights_km=(100.0,),
            modulations=(("QPSK", "16-QAM"),),
            strategy_name="k_shortest_path",
        )
        assert result.num_paths == 1
        assert not result.is_empty
        assert result.best_path == ("0", "2", "5")

    def test_create_empty_route_result(self) -> None:
        """Test creating empty route result."""
        result = RouteResult.empty(strategy_name="ksp")
        assert result.is_empty
        assert result.num_paths == 0
        assert result.best_path is None
        assert result.best_weight is None

    def test_route_result_with_protection(self) -> None:
        """Test route result with backup paths."""
        result = RouteResult(
            paths=(("0", "2", "5"),),
            weights_km=(100.0,),
            modulations=(("QPSK",),),
            backup_paths=(("0", "3", "5"),),
            backup_weights_km=(120.0,),
            backup_modulations=(("QPSK",),),
        )
        assert result.has_protection
        assert result.backup_paths == (("0", "3", "5"),)

    def test_route_result_immutable(self) -> None:
        """Test route result is frozen."""
        result = RouteResult.empty()
        with pytest.raises(AttributeError):
            result.strategy_name = "modified"  # type: ignore

    def test_route_result_validation_length_mismatch(self) -> None:
        """Test validation catches length mismatch."""
        with pytest.raises(ValueError, match="same length"):
            RouteResult(
                paths=(("0", "5"),),
                weights_km=(100.0, 200.0),  # Wrong length
                modulations=(("QPSK",),),
            )

    def test_route_result_validation_short_path(self) -> None:
        """Test validation catches single-node path."""
        with pytest.raises(ValueError, match="at least 2 nodes"):
            RouteResult(
                paths=(("0",),),  # Too short
                weights_km=(100.0,),
                modulations=(("QPSK",),),
            )

    def test_route_result_get_modulations(self) -> None:
        """Test get_modulations_for_path method."""
        result = RouteResult(
            paths=(("0", "5"), ("0", "3", "5")),
            weights_km=(100.0, 120.0),
            modulations=(("QPSK", "16-QAM"), ("QPSK",)),
        )
        assert result.get_modulations_for_path(0) == ("QPSK", "16-QAM")
        assert result.get_modulations_for_path(1) == ("QPSK",)


# =============================================================================
# SpectrumResult Tests
# =============================================================================

class TestSpectrumResult:
    """Test SpectrumResult dataclass."""

    def test_create_successful_spectrum(self) -> None:
        """Test creating successful spectrum result."""
        result = SpectrumResult(
            is_free=True,
            start_slot=100,
            end_slot=108,
            core=0,
            band="c",
            modulation="QPSK",
            slots_needed=8,
        )
        assert result.is_free
        assert result.num_slots == 8

    def test_create_failed_spectrum(self) -> None:
        """Test creating failed spectrum result."""
        result = SpectrumResult.not_found(slots_needed=8)
        assert not result.is_free
        assert result.num_slots == 0

    def test_spectrum_with_backup(self) -> None:
        """Test spectrum result with backup allocation."""
        result = SpectrumResult(
            is_free=True,
            start_slot=100,
            end_slot=108,
            core=0,
            band="c",
            modulation="QPSK",
            slots_needed=8,
            backup_start_slot=200,
            backup_end_slot=208,
            backup_core=1,
            backup_band="c",
        )
        assert result.has_backup

    def test_spectrum_validation_invalid_slots(self) -> None:
        """Test validation when is_free but invalid slots."""
        with pytest.raises(ValueError, match="end_slot must be > start_slot"):
            SpectrumResult(
                is_free=True,
                start_slot=100,
                end_slot=100,  # Invalid
                slots_needed=8,
            )

    def test_spectrum_to_allocation_dict(self) -> None:
        """Test conversion to allocation dict."""
        result = SpectrumResult(
            is_free=True,
            start_slot=100,
            end_slot=108,
            core=0,
            band="c",
            modulation="QPSK",
            slots_needed=8,
        )
        d = result.to_allocation_dict()
        assert d["is_free"] is True
        assert d["start_slot"] == 100
        assert d["core_number"] == 0


# =============================================================================
# GroomingResult Tests
# =============================================================================

class TestGroomingResult:
    """Test GroomingResult dataclass."""

    def test_no_grooming(self) -> None:
        """Test no grooming result."""
        result = GroomingResult.no_grooming(100)
        assert not result.was_groomed
        assert result.needs_new_lightpath
        assert result.remaining_bandwidth_gbps == 100

    def test_full_grooming(self) -> None:
        """Test fully groomed result."""
        result = GroomingResult.full(100, [1, 2])
        assert result.fully_groomed
        assert not result.needs_new_lightpath
        assert result.lightpaths_used == (1, 2)

    def test_partial_grooming(self) -> None:
        """Test partially groomed result."""
        result = GroomingResult.partial(
            bandwidth_groomed=60,
            remaining=40,
            lightpath_ids=[1],
            forced_path=["0", "2", "5"],
        )
        assert result.partially_groomed
        assert result.needs_new_lightpath
        assert result.forced_path == ("0", "2", "5")

    def test_grooming_validation_mutually_exclusive(self) -> None:
        """Test fully and partially groomed are mutually exclusive."""
        with pytest.raises(ValueError, match="mutually exclusive"):
            GroomingResult(
                fully_groomed=True,
                partially_groomed=True,
                lightpaths_used=(1,),
            )

    def test_grooming_validation_full_requires_zero_remaining(self) -> None:
        """Test fully groomed requires zero remaining."""
        with pytest.raises(ValueError, match="remaining_bandwidth_gbps == 0"):
            GroomingResult(
                fully_groomed=True,
                remaining_bandwidth_gbps=10,
                lightpaths_used=(1,),
            )


# =============================================================================
# SlicingResult Tests
# =============================================================================

class TestSlicingResult:
    """Test SlicingResult dataclass."""

    def test_failed_slicing(self) -> None:
        """Test failed slicing result."""
        result = SlicingResult.failed()
        assert not result.success
        assert not result.is_sliced

    def test_single_lightpath(self) -> None:
        """Test single lightpath (no actual slicing)."""
        result = SlicingResult.single_lightpath(100, 42)
        assert result.success
        assert not result.is_sliced
        assert result.num_slices == 1

    def test_sliced(self) -> None:
        """Test actual slicing."""
        result = SlicingResult.sliced(
            num_slices=4,
            slice_bandwidth=25,
            lightpath_ids=[1, 2, 3, 4],
        )
        assert result.success
        assert result.is_sliced
        assert result.total_bandwidth_gbps == 100

    def test_slicing_validation_success_requires_slices(self) -> None:
        """Test success requires num_slices > 0."""
        with pytest.raises(ValueError, match="num_slices > 0"):
            SlicingResult(success=True, num_slices=0)

    def test_slicing_validation_lightpath_count(self) -> None:
        """Test lightpaths count must match num_slices."""
        with pytest.raises(ValueError, match="must match num_slices"):
            SlicingResult(
                success=True,
                num_slices=4,
                lightpaths_created=(1, 2),  # Wrong count
            )


# =============================================================================
# SNRResult Tests
# =============================================================================

class TestSNRResult:
    """Test SNRResult dataclass."""

    def test_snr_success(self) -> None:
        """Test successful SNR validation."""
        result = SNRResult.success(snr_db=18.5, required_snr_db=15.0)
        assert result.passed
        assert result.margin_db == 3.5
        assert not result.is_degraded

    def test_snr_failure(self) -> None:
        """Test failed SNR validation."""
        result = SNRResult.failure(
            snr_db=12.0,
            required_snr_db=15.0,
            reason="SNR too low",
        )
        assert not result.passed
        assert result.margin_db == -3.0
        assert result.failure_reason == "SNR too low"

    def test_snr_skipped(self) -> None:
        """Test SNR validation skipped."""
        result = SNRResult.skipped()
        assert result.passed
        assert result.snr_db == 0.0

    def test_snr_is_degraded(self) -> None:
        """Test marginal SNR is flagged as degraded."""
        result = SNRResult.success(snr_db=15.5, required_snr_db=15.0)
        assert result.passed
        assert result.is_degraded  # margin < 1.0

    def test_snr_with_link_breakdown(self) -> None:
        """Test SNR with per-link values."""
        result = SNRResult.success(
            snr_db=15.0,
            required_snr_db=15.0,
            link_snr_values={("0", "2"): 18.5, ("2", "5"): 15.0},
        )
        assert result.has_link_breakdown
        weakest = result.get_weakest_link()
        assert weakest == (("2", "5"), 15.0)


# =============================================================================
# AllocationResult Tests
# =============================================================================

class TestAllocationResult:
    """Test AllocationResult dataclass."""

    def test_blocked_result(self) -> None:
        """Test blocked allocation result."""
        result = AllocationResult.blocked(BlockReason.NO_ROUTE)
        assert not result.success
        assert result.block_reason == BlockReason.NO_ROUTE

    def test_success_new_lightpath(self) -> None:
        """Test successful new lightpath allocation."""
        result = AllocationResult.success_new_lightpath(
            lightpath_id=42,
            bandwidth_gbps=100,
        )
        assert result.success
        assert result.lightpaths_created == (42,)
        assert result.total_bandwidth_allocated_gbps == 100

    def test_success_groomed(self) -> None:
        """Test successful groomed allocation."""
        result = AllocationResult.success_groomed(
            lightpath_ids=[10, 20],
            bandwidth_gbps=100,
        )
        assert result.success
        assert result.is_groomed
        assert result.lightpaths_groomed == (10, 20)

    def test_success_partial_groom(self) -> None:
        """Test successful partial grooming."""
        result = AllocationResult.success_partial_groom(
            groomed_ids=[10],
            new_lightpath_id=42,
            total_bandwidth=100,
        )
        assert result.success
        assert result.is_partially_groomed
        assert result.lightpaths_groomed == (10,)
        assert result.lightpaths_created == (42,)

    def test_success_sliced(self) -> None:
        """Test successful sliced allocation."""
        result = AllocationResult.success_sliced(
            lightpath_ids=[1, 2, 3, 4],
            bandwidth_gbps=400,
        )
        assert result.success
        assert result.is_sliced
        assert result.num_lightpaths == 4

    def test_all_lightpath_ids(self) -> None:
        """Test all_lightpath_ids property."""
        result = AllocationResult.success_partial_groom(
            groomed_ids=[10, 20],
            new_lightpath_id=42,
            total_bandwidth=100,
        )
        assert result.all_lightpath_ids == (42, 10, 20)

    def test_used_grooming(self) -> None:
        """Test used_grooming property."""
        full = AllocationResult.success_groomed([1], 100)
        assert full.used_grooming

        partial = AllocationResult.success_partial_groom([1], 2, 100)
        assert partial.used_grooming

        new_lp = AllocationResult.success_new_lightpath(1, 100)
        assert not new_lp.used_grooming

    def test_validation_success_requires_lightpath(self) -> None:
        """Test success requires at least one lightpath."""
        with pytest.raises(ValueError, match="at least one lightpath"):
            AllocationResult(success=True, total_bandwidth_allocated_gbps=100)

    def test_validation_success_requires_bandwidth(self) -> None:
        """Test success requires positive bandwidth."""
        with pytest.raises(ValueError, match="total_bandwidth > 0"):
            AllocationResult(
                success=True,
                lightpaths_created=(1,),
                total_bandwidth_allocated_gbps=0,
            )

    def test_validation_failure_requires_reason(self) -> None:
        """Test failure requires block_reason."""
        with pytest.raises(ValueError, match="requires block_reason"):
            AllocationResult(success=False)

    def test_with_nested_results(self) -> None:
        """Test allocation result with nested results."""
        route = RouteResult.empty()
        snr = SNRResult.failure(12.0, 15.0)

        result = AllocationResult.blocked(
            BlockReason.SNR_FAILURE,
            route_result=route,
            snr_result=snr,
        )
        assert result.route_result is route
        assert result.snr_result is snr


# =============================================================================
# Integration Tests
# =============================================================================

class TestResultIntegration:
    """Integration tests for result objects."""

    def test_result_chain_success(self) -> None:
        """Test successful result chain."""
        # Routing succeeded
        route = RouteResult(
            paths=(("0", "2", "5"),),
            weights_km=(100.0,),
            modulations=(("QPSK",),),
        )
        assert not route.is_empty

        # Spectrum found
        spectrum = SpectrumResult(
            is_free=True,
            start_slot=0,
            end_slot=8,
            core=0,
            band="c",
            modulation="QPSK",
            slots_needed=8,
        )
        assert spectrum.is_free

        # SNR passed
        snr = SNRResult.success(18.0, 15.0)
        assert snr.passed

        # Final result
        result = AllocationResult.success_new_lightpath(
            lightpath_id=1,
            bandwidth_gbps=100,
            route_result=route,
            spectrum_result=spectrum,
            snr_result=snr,
        )
        assert result.success

    def test_result_chain_routing_failure(self) -> None:
        """Test failure at routing stage."""
        route = RouteResult.empty()
        assert route.is_empty

        result = AllocationResult.blocked(
            BlockReason.NO_ROUTE,
            route_result=route,
        )
        assert not result.success
        assert result.block_reason == BlockReason.NO_ROUTE

    def test_result_chain_spectrum_failure(self) -> None:
        """Test failure at spectrum stage."""
        route = RouteResult(
            paths=(("0", "5"),),
            weights_km=(100.0,),
            modulations=(("QPSK",),),
        )
        spectrum = SpectrumResult.not_found(slots_needed=8)

        result = AllocationResult.blocked(
            BlockReason.NO_SPECTRUM,
            route_result=route,
            spectrum_result=spectrum,
        )
        assert not result.success
        assert result.block_reason == BlockReason.NO_SPECTRUM
```

---

## Verification Commands

```bash
# Run tests with verbose output
pytest fusion/tests/domain/test_results.py -v

# Check coverage
pytest fusion/tests/domain/test_results.py --cov=fusion/domain/results --cov-report=term-missing

# Verify at least 90% coverage
pytest fusion/tests/domain/test_results.py --cov=fusion/domain/results --cov-fail-under=90

# Type check
mypy fusion/domain/results.py fusion/tests/domain/test_results.py

# Lint
ruff check fusion/domain/ fusion/tests/domain/
ruff format --check fusion/domain/ fusion/tests/domain/

# Ensure existing tests still pass
pytest tests/ -v --ignore=fusion/tests/
```

---

## Coverage Target: 90%

The test suite covers:
- All creation paths for each result type
- All factory methods
- All validation cases
- All computed properties
- Integration between result types

---

## Sub-phase Complete

After P1.4.g is verified, P1.4 Result Objects is complete.
Proceed to [P1.5 Stats Collector](../P1.5_stats_collector/P1.5.index.md).
