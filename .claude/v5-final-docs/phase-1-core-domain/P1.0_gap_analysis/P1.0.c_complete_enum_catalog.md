# P1.0.c Complete Enum Catalog

## Purpose

This document provides a complete catalog of all enumerations needed in the Phase 1 domain model. Each enum includes all values derived from analyzing the legacy codebase.

---

## 1. RequestType

**Location**: `fusion/domain/enums.py`
**Used By**: `Request`

```python
from enum import Enum, auto

class RequestType(Enum):
    """Type of request event in the simulation."""
    ARRIVAL = "arrival"
    RELEASE = "release"

    @classmethod
    def from_legacy(cls, value: str) -> "RequestType":
        """Convert legacy string to enum."""
        mapping = {
            "arrival": cls.ARRIVAL,
            "release": cls.RELEASE,
        }
        return mapping[value.lower()]

    def to_legacy(self) -> str:
        """Convert enum to legacy string."""
        return self.value
```

**Legacy Source**: `fusion/core/request.py` lines 18-19
```python
DEFAULT_REQUEST_TYPE_ARRIVAL = "arrival"
DEFAULT_REQUEST_TYPE_RELEASE = "release"
```

---

## 2. RequestStatus

**Location**: `fusion/domain/enums.py`
**Used By**: `Request`

```python
class RequestStatus(Enum):
    """Lifecycle status of a network request."""
    # Initial state
    PENDING = auto()          # Request created, not yet processed

    # Processing states
    ROUTING = auto()          # Finding candidate paths
    SPECTRUM_SEARCH = auto()  # Searching for spectrum
    SNR_CHECK = auto()        # Validating SNR

    # Terminal success states
    ALLOCATED = auto()        # Successfully allocated resources
    GROOMED = auto()          # Successfully groomed onto existing LP
    PARTIALLY_GROOMED = auto() # Partially groomed, rest allocated

    # Terminal failure states
    BLOCKED = auto()          # Could not allocate (see block_reason)

    # Release states
    RELEASING = auto()        # Release in progress
    RELEASED = auto()         # Resources released

    def is_terminal(self) -> bool:
        """Check if this is a terminal state."""
        return self in {
            RequestStatus.ALLOCATED,
            RequestStatus.GROOMED,
            RequestStatus.PARTIALLY_GROOMED,
            RequestStatus.BLOCKED,
            RequestStatus.RELEASED,
        }

    def is_success(self) -> bool:
        """Check if this represents successful allocation."""
        return self in {
            RequestStatus.ALLOCATED,
            RequestStatus.GROOMED,
            RequestStatus.PARTIALLY_GROOMED,
        }
```

**Legacy Source**: Derived from `SDNProps` flags:
- `was_routed` -> ALLOCATED
- `was_groomed` -> GROOMED
- `was_partially_groomed` -> PARTIALLY_GROOMED
- `block_reason is not None` -> BLOCKED

---

## 3. BlockReason

**Location**: `fusion/domain/enums.py`
**Used By**: `Request`, `AllocationResult`

```python
class BlockReason(Enum):
    """Reason why a request was blocked."""
    # Path-related blocking
    NO_PATH = "no_path"           # No path exists between source and destination
    DISTANCE = "distance"         # Path too long for any modulation format

    # Spectrum-related blocking
    CONGESTION = "congestion"     # No spectrum available on any path

    # Quality-related blocking
    SNR_THRESHOLD = "snr_fail"    # SNR below required threshold
    XT_THRESHOLD = "xt_threshold" # Crosstalk exceeds allowed threshold

    # Feature-specific blocking
    GROOMING_FAIL = "grooming_fail"   # Grooming attempt failed
    SLICING_FAIL = "slicing_fail"     # Slicing attempt failed
    PROTECTION_FAIL = "protection_fail" # Cannot establish protection path

    # Failure-related blocking
    LINK_FAILURE = "link_failure"     # Link failed during processing
    NODE_FAILURE = "node_failure"     # Node failed during processing
    FAILURE = "failure"               # Generic failure (legacy)

    # Resource limits
    TRANSPONDER_LIMIT = "transponder_limit"  # Max transponders reached
    MAX_SEGMENTS = "max_segments"            # Max slicing segments reached

    @classmethod
    def from_legacy(cls, value: str | None) -> "BlockReason | None":
        """Convert legacy string to enum."""
        if value is None:
            return None
        mapping = {
            "distance": cls.DISTANCE,
            "congestion": cls.CONGESTION,
            "xt_threshold": cls.XT_THRESHOLD,
            "failure": cls.FAILURE,
            "snr_fail": cls.SNR_THRESHOLD,
            "no_path": cls.NO_PATH,
            "grooming_fail": cls.GROOMING_FAIL,
            "slicing_fail": cls.SLICING_FAIL,
            "protection_fail": cls.PROTECTION_FAIL,
            "link_failure": cls.LINK_FAILURE,
            "node_failure": cls.NODE_FAILURE,
            "transponder_limit": cls.TRANSPONDER_LIMIT,
            "max_segments": cls.MAX_SEGMENTS,
        }
        return mapping.get(value.lower(), cls.FAILURE)

    def to_legacy(self) -> str:
        """Convert enum to legacy string."""
        return self.value

    def is_path_related(self) -> bool:
        """Check if blocking is path-related."""
        return self in {BlockReason.NO_PATH, BlockReason.DISTANCE}

    def is_spectrum_related(self) -> bool:
        """Check if blocking is spectrum-related."""
        return self == BlockReason.CONGESTION

    def is_quality_related(self) -> bool:
        """Check if blocking is quality-related."""
        return self in {BlockReason.SNR_THRESHOLD, BlockReason.XT_THRESHOLD}
```

**Legacy Source**: `StatsProps.block_reasons_dict` plus additional reasons found in codebase.

---

## 4. ProtectionStatus

**Location**: `fusion/domain/enums.py`
**Used By**: `Request` (for protected requests)

```python
class ProtectionStatus(Enum):
    """Protection state for 1+1 protected connections."""
    UNPROTECTED = auto()              # No protection (normal request)
    ESTABLISHING = auto()             # Setting up protection paths
    ACTIVE_PRIMARY = auto()           # Protected, using primary path
    ACTIVE_BACKUP = auto()            # Protected, using backup path (after switchover)
    SWITCHOVER_IN_PROGRESS = auto()   # Switching between paths
    PRIMARY_FAILED = auto()           # Primary path failed, on backup
    BACKUP_FAILED = auto()            # Backup path failed, on primary
    BOTH_FAILED = auto()              # Both paths failed (connection lost)

    def is_active(self) -> bool:
        """Check if connection is active (either path)."""
        return self in {
            ProtectionStatus.ACTIVE_PRIMARY,
            ProtectionStatus.ACTIVE_BACKUP,
            ProtectionStatus.PRIMARY_FAILED,
            ProtectionStatus.BACKUP_FAILED,
        }

    def is_degraded(self) -> bool:
        """Check if protection is degraded (one path failed)."""
        return self in {
            ProtectionStatus.PRIMARY_FAILED,
            ProtectionStatus.BACKUP_FAILED,
        }

    def is_failed(self) -> bool:
        """Check if connection is failed."""
        return self == ProtectionStatus.BOTH_FAILED
```

**Legacy Source**: Derived from `SDNProps` protection fields:
- `is_protected` + `active_path == "primary"` -> ACTIVE_PRIMARY
- `is_protected` + `active_path == "backup"` -> ACTIVE_BACKUP

---

## 5. FailureType

**Location**: `fusion/domain/enums.py`
**Used By**: `ProtectionResult`, failure handling

```python
class FailureType(Enum):
    """Type of network failure."""
    LINK = "link"               # F1: Single link failure
    NODE = "node"               # F2: Single node failure
    SRLG = "srlg"               # F3: Shared Risk Link Group failure
    GEOGRAPHIC = "geographic"   # F4: Geographic/regional failure
    EQUIPMENT = "equipment"     # Equipment failure (amplifier, etc.)

    @classmethod
    def from_legacy(cls, value: str | None) -> "FailureType | None":
        """Convert legacy string to enum."""
        if value is None:
            return None
        mapping = {
            "link": cls.LINK,
            "node": cls.NODE,
            "srlg": cls.SRLG,
            "geographic": cls.GEOGRAPHIC,
            "equipment": cls.EQUIPMENT,
            "f1": cls.LINK,
            "f2": cls.NODE,
            "f3": cls.SRLG,
            "f4": cls.GEOGRAPHIC,
        }
        return mapping.get(value.lower())
```

**Legacy Source**: Survivability documentation (F1-F4 failure types).

---

## 6. ModulationFormat

**Location**: `fusion/domain/enums.py`
**Used By**: `SimulationConfig`, `RouteResult`, `SpectrumResult`

```python
class ModulationFormat(Enum):
    """Optical modulation formats."""
    BPSK = "BPSK"         # Binary Phase Shift Keying
    QPSK = "QPSK"         # Quadrature Phase Shift Keying
    QAM_8 = "8-QAM"       # 8-Quadrature Amplitude Modulation
    QAM_16 = "16-QAM"     # 16-QAM
    QAM_32 = "32-QAM"     # 32-QAM
    QAM_64 = "64-QAM"     # 64-QAM

    @property
    def spectral_efficiency(self) -> int:
        """Bits per symbol for this modulation."""
        efficiency = {
            ModulationFormat.BPSK: 1,
            ModulationFormat.QPSK: 2,
            ModulationFormat.QAM_8: 3,
            ModulationFormat.QAM_16: 4,
            ModulationFormat.QAM_32: 5,
            ModulationFormat.QAM_64: 6,
        }
        return efficiency[self]

    @property
    def snr_threshold_db(self) -> float:
        """Required SNR threshold in dB."""
        thresholds = {
            ModulationFormat.BPSK: 3.71,
            ModulationFormat.QPSK: 6.72,
            ModulationFormat.QAM_8: 10.84,
            ModulationFormat.QAM_16: 13.24,
            ModulationFormat.QAM_32: 16.16,
            ModulationFormat.QAM_64: 19.01,
        }
        return thresholds[self]

    @classmethod
    def from_legacy(cls, value: str | int) -> "ModulationFormat":
        """Convert legacy string or int to enum."""
        if isinstance(value, int):
            int_mapping = {
                1: cls.BPSK,
                2: cls.QPSK,
                3: cls.QAM_8,
                4: cls.QAM_16,
                5: cls.QAM_32,
                6: cls.QAM_64,
            }
            return int_mapping[value]
        str_mapping = {
            "bpsk": cls.BPSK,
            "qpsk": cls.QPSK,
            "8-qam": cls.QAM_8,
            "16-qam": cls.QAM_16,
            "32-qam": cls.QAM_32,
            "64-qam": cls.QAM_64,
        }
        return str_mapping[value.lower()]

    def to_legacy(self) -> str:
        """Convert enum to legacy string."""
        return self.value
```

**Legacy Source**: `SNRProps.modulation_format_mapping_dict` and `SNRProps.req_snr`.

---

## 7. Band

**Location**: `fusion/domain/enums.py`
**Used By**: `SimulationConfig`, `SpectrumResult`

```python
class Band(Enum):
    """Optical transmission bands."""
    C = "c"    # C-band (conventional band, ~1530-1565 nm)
    L = "l"    # L-band (long wavelength band, ~1565-1625 nm)
    S = "s"    # S-band (short wavelength band, ~1460-1530 nm)
    O = "o"    # O-band (original band, ~1260-1360 nm)
    E = "e"    # E-band (extended band, ~1360-1460 nm)

    @property
    def noise_figure(self) -> float:
        """Typical EDFA noise figure for this band."""
        figures = {
            Band.C: 1.77,
            Band.L: 1.99,
            Band.S: 2.0,
            Band.O: 2.0,
            Band.E: 2.0,
        }
        return figures[self]

    @classmethod
    def from_legacy(cls, value: str) -> "Band":
        """Convert legacy string to enum."""
        return cls(value.lower())

    def to_legacy(self) -> str:
        """Convert enum to legacy string."""
        return self.value
```

**Legacy Source**: `SNRProps.nsp` band keys.

---

## 8. AllocationMethod

**Location**: `fusion/domain/enums.py`
**Used By**: `SimulationConfig`

```python
class AllocationMethod(Enum):
    """Spectrum allocation method."""
    FIRST_FIT = "first_fit"
    BEST_FIT = "best_fit"
    LAST_FIT = "last_fit"
    RANDOM_FIT = "random_fit"
    EXACT_FIT = "exact_fit"

    @classmethod
    def from_legacy(cls, value: str) -> "AllocationMethod":
        """Convert legacy string to enum."""
        mapping = {
            "first_fit": cls.FIRST_FIT,
            "best_fit": cls.BEST_FIT,
            "last_fit": cls.LAST_FIT,
            "random_fit": cls.RANDOM_FIT,
            "exact_fit": cls.EXACT_FIT,
        }
        return mapping.get(value.lower(), cls.FIRST_FIT)
```

**Legacy Source**: `cli_to_config.py` allocation_method parameter.

---

## 9. RouteMethod

**Location**: `fusion/domain/enums.py`
**Used By**: `SimulationConfig`

```python
class RouteMethod(Enum):
    """Routing method/algorithm."""
    KSP = "k_shortest_paths"           # K-shortest paths
    SHORTEST = "shortest_path"         # Single shortest path
    LOAD_BALANCED = "load_balanced"    # Load-balanced routing
    PROTECTION_1PLUS1 = "1plus1_protection"  # 1+1 disjoint protection
    DISJOINT = "disjoint"              # Disjoint paths
    CUSTOM = "custom"                  # Custom/RL routing

    @property
    def requires_protection(self) -> bool:
        """Check if this method requires protection path setup."""
        return self == RouteMethod.PROTECTION_1PLUS1

    @classmethod
    def from_legacy(cls, value: str) -> "RouteMethod":
        """Convert legacy string to enum."""
        mapping = {
            "k_shortest_paths": cls.KSP,
            "ksp": cls.KSP,
            "shortest_path": cls.SHORTEST,
            "load_balanced": cls.LOAD_BALANCED,
            "1plus1_protection": cls.PROTECTION_1PLUS1,
            "disjoint": cls.DISJOINT,
            "custom": cls.CUSTOM,
        }
        return mapping.get(value.lower(), cls.KSP)
```

**Legacy Source**: `cli_to_config.py` route_method parameter.

---

## 10. SNRType

**Location**: `fusion/domain/enums.py`
**Used By**: `SimulationConfig`

```python
class SNRType(Enum):
    """SNR calculation method."""
    NONE = "none"                    # No SNR validation
    ESTIMATED = "estimated"          # Estimated SNR (fast)
    CALCULATED = "calculated"        # Full GN model calculation
    PRECALCULATED = "precalculated"  # Use precalculated values from file

    @classmethod
    def from_legacy(cls, value: str | None) -> "SNRType":
        """Convert legacy string to enum."""
        if value is None:
            return cls.NONE
        mapping = {
            "none": cls.NONE,
            "estimated": cls.ESTIMATED,
            "calculated": cls.CALCULATED,
            "precalculated": cls.PRECALCULATED,
        }
        return mapping.get(value.lower(), cls.NONE)
```

**Legacy Source**: `cli_to_config.py` snr_type parameter.

---

## 11. XTType

**Location**: `fusion/domain/enums.py`
**Used By**: `SimulationConfig`

```python
class XTType(Enum):
    """Crosstalk calculation method."""
    NONE = "none"             # No crosstalk validation
    SIMPLE = "simple"         # Simple XT model
    FULL = "full"             # Full XT calculation

    @classmethod
    def from_legacy(cls, value: str | None) -> "XTType":
        """Convert legacy string to enum."""
        if value is None:
            return cls.NONE
        mapping = {
            "none": cls.NONE,
            "simple": cls.SIMPLE,
            "full": cls.FULL,
        }
        return mapping.get(value.lower(), cls.NONE)
```

**Legacy Source**: `cli_to_config.py` xt_type parameter.

---

## File Organization

All enums should be placed in `fusion/domain/enums.py`:

```python
"""Domain enumerations for FUSION simulation."""

from enum import Enum, auto

__all__ = [
    "RequestType",
    "RequestStatus",
    "BlockReason",
    "ProtectionStatus",
    "FailureType",
    "ModulationFormat",
    "Band",
    "AllocationMethod",
    "RouteMethod",
    "SNRType",
    "XTType",
]

# ... enum definitions ...
```

---

## Verification Checklist

- [ ] All legacy string values have enum mappings
- [ ] All enums have `from_legacy()` class method
- [ ] All enums have `to_legacy()` instance method
- [ ] Enum values are unique within each enum
- [ ] Documentation describes each value's meaning
- [ ] Type hints use enum types, not strings
- [ ] Tests verify round-trip conversion
