# P1.0.b SDNProps Distribution Plan

## Purpose

SDNProps is the largest and most complex legacy class with 47+ fields serving multiple purposes. This document provides a detailed distribution plan showing exactly how each field moves to the new domain model.

## SDNProps Analysis

SDNProps currently serves as a "god object" combining:
1. Network-wide state (topology, spectrum, lightpaths)
2. Current request context (source, dest, bandwidth)
3. Per-request computation results (lists of allocations)
4. Configuration values (transponders, single_core)
5. Protection state (primary/backup paths)
6. Statistical tracking (counters, timings)

## Distribution Strategy

### Principle: Single Responsibility

Each field should move to the class that owns that concept:
- **Network topology/spectrum** -> `NetworkState` (Phase 2)
- **Request identity/lifecycle** -> `Request`
- **Computation outputs** -> Result objects (`RouteResult`, `SpectrumResult`, etc.)
- **Aggregated statistics** -> `StatsCollector`
- **Fixed configuration** -> `SimulationConfig`

### Principle: Eliminate Dual Storage

Current SDNProps stores the same data in multiple forms (e.g., `path_list` and `paths_matrix`). The new model eliminates this redundancy.

---

## Detailed Field Distribution

### Category 1: Network State (-> NetworkState, Phase 2)

These fields represent network-wide mutable state that must be consistent across all request processing.

```python
# Current SDNProps fields
self.topology: Any                          # -> NetworkState.topology
self.network_spectrum_dict: dict            # -> NetworkState.spectrum
self.lightpath_status_dict: dict            # -> NetworkState.lightpaths
self.transponder_usage_dict: dict           # -> NetworkState.transponder_usage
self.lp_bw_utilization_dict: dict           # -> NetworkState.lp_utilization
self.lightpath_counter: int                 # -> NetworkState._lightpath_counter
self.allocated_requests: dict               # -> NetworkState.allocated_requests
```

**Phase 2 Implementation Note**: These move entirely to NetworkState. SDNProps will have properties that delegate to NetworkState during transition.

---

### Category 2: Request Identity (-> Request)

These fields identify and characterize the current request being processed.

```python
# Current SDNProps fields           # New Request fields
self.request_id: int               # -> Request.request_id
self.source: str                   # -> Request.source
self.destination: str              # -> Request.destination
self.bandwidth: float              # -> Request.bandwidth_gbps
self.arrive: float                 # -> Request.arrival_time
self.depart: float                 # -> Request.departure_time
self.request_type: str             # -> Request.request_type (enum)
```

**P1.2 Implementation**:
```python
@dataclass
class Request:
    request_id: int
    source: str
    destination: str
    bandwidth_gbps: float
    arrival_time: float
    departure_time: float
    request_type: RequestType  # Enum: ARRIVAL, RELEASE
    modulation_formats: list[str] = field(default_factory=list)
```

---

### Category 3: Request Lifecycle State (-> Request)

These fields track the processing state of a request.

```python
# Current SDNProps fields           # New Request fields
self.slots_needed: int             # -> Request.slots_needed (computed, cached)
self.path_list: list               # -> Request.path (selected path)
self.path_index: int               # -> Request.path_index (which k-path)
self.was_routed: bool              # -> Request.status (RequestStatus enum)
self.was_groomed: bool             # -> Request.was_groomed
self.was_partially_groomed: bool   # -> Request.was_partially_groomed
self.was_partially_routed: bool    # -> Request.was_partially_routed
self.is_sliced: bool               # -> Request.is_sliced
self.block_reason: str             # -> Request.block_reason (BlockReason enum)
self.remaining_bw: float           # -> Request.remaining_bandwidth
```

**P1.2 Implementation**:
```python
@dataclass
class Request:
    # ... identity fields ...

    # Lifecycle state (mutable)
    status: RequestStatus = RequestStatus.PENDING
    block_reason: BlockReason | None = None

    # Processing flags
    was_groomed: bool = False
    was_partially_groomed: bool = False
    was_partially_routed: bool = False
    is_sliced: bool = False

    # Computed/cached values
    slots_needed: int | None = None
    path: list[str] | None = None
    path_index: int | None = None
    remaining_bandwidth: float | None = None
```

---

### Category 4: Per-Request Allocation Results (-> AllocationResult)

These lists accumulate the multi-segment allocation details for a single request.

```python
# Current SDNProps tracking lists   # New AllocationResult fields
self.bandwidth_list: list[float]   # -> AllocationResult.bandwidth_allocations
self.modulation_list: list[str]    # -> AllocationResult.modulations
self.core_list: list[int]          # -> AllocationResult.cores
self.band_list: list[str]          # -> AllocationResult.bands
self.crosstalk_list: list[float]   # -> AllocationResult.xt_costs
self.snr_list: list[float]         # -> AllocationResult.snr_values
self.xt_list: list[float]          # -> AllocationResult.xt_values
self.start_slot_list: list[int]    # -> AllocationResult.start_slots
self.end_slot_list: list[int]      # -> AllocationResult.end_slots
self.lightpath_id_list: list[int]  # -> AllocationResult.lightpath_ids
self.lightpath_bandwidth_list: list[float]  # -> AllocationResult.lightpath_bandwidths
self.was_new_lp_established: list[int]      # -> AllocationResult.new_lightpath_ids
```

**P1.4 Implementation**:
```python
@dataclass(frozen=True)
class AllocationResult:
    """Final result of request allocation attempt."""
    success: bool
    block_reason: BlockReason | None = None

    # Multi-segment allocation details (for slicing)
    segments: tuple[SegmentAllocation, ...] = ()

    # Lightpath tracking
    lightpath_ids: tuple[int, ...] = ()
    new_lightpath_ids: tuple[int, ...] = ()

    # Aggregated metrics
    total_slots: int = 0
    total_bandwidth_gbps: float = 0.0

@dataclass(frozen=True)
class SegmentAllocation:
    """Single segment of a potentially sliced allocation."""
    path: tuple[str, ...]
    start_slot: int
    end_slot: int
    core: int
    band: str
    modulation: str
    bandwidth_gbps: float
    lightpath_id: int
    snr_db: float | None = None
    xt_cost: float | None = None
```

---

### Category 5: Protection State (-> Request + ProtectionResult)

These fields support 1+1 protection functionality.

```python
# Current SDNProps fields              # Distribution
self.primary_path: list               # -> Request.primary_path
self.backup_path: list                # -> Request.backup_path
self.is_protected: bool               # -> Request.is_protected
self.active_path: str                 # -> Request.active_path ("primary"/"backup")
self.switchover_count: int            # -> StatsCollector.switchover_count
self.last_switchover_time: float      # -> Request.last_switchover_time
self.recovery_start_time: float       # -> ProtectionResult.recovery_start
self.recovery_end_time: float         # -> ProtectionResult.recovery_end
self.recovery_type: str               # -> ProtectionResult.recovery_type
self.protection_switchover_ms: float  # -> SimulationConfig.protection.switchover_ms
self.restoration_latency_ms: float    # -> SimulationConfig.protection.restoration_ms
```

**P1.2 Addition to Request**:
```python
@dataclass
class Request:
    # ... other fields ...

    # Protection state (for 1+1 protected requests)
    is_protected: bool = False
    primary_path: list[str] | None = None
    backup_path: list[str] | None = None
    active_path: str = "primary"  # "primary" or "backup"
    last_switchover_time: float | None = None
```

**P1.4 ProtectionResult**:
```python
@dataclass(frozen=True)
class ProtectionResult:
    """Result of protection establishment or switchover operation."""
    primary_established: bool
    backup_established: bool
    primary_allocation: AllocationResult | None = None
    backup_allocation: AllocationResult | None = None

    # Switchover details (if applicable)
    switchover_triggered: bool = False
    switchover_success: bool = False
    switchover_latency_ms: float | None = None

    # Recovery details
    recovery_type: str | None = None  # "protection", "restoration"
    recovery_start_time: float | None = None
    recovery_end_time: float | None = None
    failure_type: str | None = None  # "link", "node", "srlg", "geographic"
```

---

### Category 6: Configuration (-> SimulationConfig)

These fields are configuration values that don't change during simulation.

```python
# Current SDNProps fields              # New SimulationConfig location
self.number_of_transponders: int       # -> SimulationConfig.topology.max_transponders
self.single_core: bool                 # -> SimulationConfig.topology.single_core
self.modulation_formats_dict: dict     # -> SimulationConfig.modulation.formats_dict
```

---

### Category 7: Transient/Internal (-> DELETE or COMPUTED)

These fields are temporary computation state that should not be stored.

```python
# Current SDNProps fields    # Action
self.route_time: float       # COMPUTED: measure in orchestrator
self.path_weight: float      # COMPUTED: from RouteResult
self.spectrum_object: obj    # DELETE: nested props anti-pattern
self.stat_key_list: list     # DELETE: internal constant
```

---

## Migration Code Pattern

### Before: SDNProps Access
```python
# In sdn_controller.py
def handle_arrival(self, request_info: dict) -> None:
    self.sdn_props.request_id = request_info["req_id"]
    self.sdn_props.source = request_info["source"]
    self.sdn_props.destination = request_info["destination"]
    self.sdn_props.bandwidth = request_info["bandwidth"]

    # ... routing ...

    self.sdn_props.core_list.append(spectrum.core_number)
    self.sdn_props.band_list.append(spectrum.current_band)
    self.sdn_props.was_routed = True
```

### After: Distributed Access
```python
# In orchestrator.py
def handle_arrival(self, request: Request, network_state: NetworkState) -> AllocationResult:
    # Request already has identity fields

    # ... routing returns RouteResult ...
    # ... spectrum returns SpectrumResult ...

    if spectrum_result.is_free:
        segment = SegmentAllocation(
            path=tuple(route_result.paths[0]),
            start_slot=spectrum_result.start_slot,
            end_slot=spectrum_result.end_slot,
            core=spectrum_result.core,
            band=spectrum_result.band,
            modulation=spectrum_result.modulation,
            bandwidth_gbps=request.bandwidth_gbps,
            lightpath_id=network_state.get_next_lightpath_id(),
        )
        request.status = RequestStatus.ALLOCATED
        return AllocationResult(success=True, segments=(segment,))
    else:
        request.status = RequestStatus.BLOCKED
        request.block_reason = BlockReason.CONGESTION
        return AllocationResult(success=False, block_reason=BlockReason.CONGESTION)
```

---

## Transition Helpers

During migration, SDNProps will provide compatibility properties:

```python
class SDNProps:
    """Legacy SDNProps with transition helpers."""

    def __init__(self, request: Request | None = None, network_state: NetworkState | None = None):
        self._request = request
        self._network_state = network_state
        # ... legacy fields for unmigrated code ...

    @property
    def request_id(self) -> int | None:
        """Legacy access - delegates to Request."""
        if self._request:
            return self._request.request_id
        return self._legacy_request_id

    @request_id.setter
    def request_id(self, value: int) -> None:
        """Legacy write - updates Request if available."""
        if self._request:
            # Request.request_id is immutable, so this is a migration error
            raise ValueError("Cannot modify request_id on existing Request")
        self._legacy_request_id = value
```

---

## Verification Checklist

- [ ] All 47 SDNProps fields have explicit destinations
- [ ] No field is duplicated across destinations
- [ ] Request class has all lifecycle fields
- [ ] AllocationResult captures all per-request lists
- [ ] NetworkState (Phase 2) receives all network-wide state
- [ ] ProtectionResult covers all protection scenarios
- [ ] Transition helpers maintain compatibility
- [ ] Tests verify round-trip conversion
