# Task ID: P1.3.c - Implement Lightpath Adapters

**Sub-phase**: P1.3 Lightpath Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: refactor-plan

---

## Purpose

Implement `from_legacy_dict()` and `to_legacy_dict()` methods for bidirectional conversion between `Lightpath` and legacy lightpath dictionaries.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.3_lightpath_wrapper/P1.3.shared_context_lightpath_legacy.md`
- `.claude/v5-final-docs/phase-1-core-domain/P1.3_lightpath_wrapper/P1.3.b_implement_lightpath_class.md`
- `fusion/core/grooming.py` (lines 60-158)

---

## Outputs

### Replace adapter stubs in `fusion/domain/lightpath.py`

```python
    @classmethod
    def from_legacy_dict(
        cls,
        lightpath_id: int,
        lp_info: dict[str, Any],
    ) -> Lightpath:
        """
        Create Lightpath from legacy dictionary.

        The legacy format stores lightpath info in nested dictionaries
        indexed by endpoint pair and lightpath ID.

        Args:
            lightpath_id: Unique lightpath identifier
            lp_info: Legacy lightpath info dictionary with fields:
                - "path": list[str] - Node IDs in path
                - "start_slot": int - First slot index
                - "end_slot": int - Last slot index (exclusive)
                - "core": int - Core number
                - "band": str - Frequency band
                - "mod_format": str - Modulation format
                - "lightpath_bandwidth": float - Total bandwidth
                - "remaining_bandwidth": float - Available bandwidth
                - "requests_dict": dict - Request allocations (optional)
                - "snr_cost": float - SNR value (optional)
                - "xt_cost": float - Crosstalk (optional)
                - "path_weight": float - Path length (optional)
                - "is_degraded": bool - Degradation flag (optional)
                - "backup_path": list[str] - Backup path (optional)
                - "is_protected": bool - Protection flag (optional)
                - "active_path": str - Active path (optional)

        Returns:
            New Lightpath instance

        Example:
            >>> lp_info = {
            ...     "path": ["0", "2", "5"],
            ...     "start_slot": 10,
            ...     "end_slot": 18,
            ...     "core": 0,
            ...     "band": "c",
            ...     "mod_format": "QPSK",
            ...     "lightpath_bandwidth": 100.0,
            ...     "remaining_bandwidth": 50.0,
            ...     "requests_dict": {42: 50.0},
            ... }
            >>> lp = Lightpath.from_legacy_dict(1, lp_info)
            >>> lp.lightpath_id
            1
        """
        # Parse request allocations (convert float -> int if needed)
        requests_dict = lp_info.get("requests_dict", {})
        request_allocations = {
            int(req_id): int(bw) for req_id, bw in requests_dict.items()
        }

        # Handle protection fields
        backup_path = lp_info.get("backup_path")
        is_protected = lp_info.get("is_protected", False)

        # Ensure protection consistency
        if backup_path is not None and not is_protected:
            is_protected = True

        return cls(
            lightpath_id=lightpath_id,
            path=lp_info["path"],
            start_slot=int(lp_info["start_slot"]),
            end_slot=int(lp_info["end_slot"]),
            core=int(lp_info["core"]),
            band=lp_info["band"],
            modulation=lp_info.get("mod_format", lp_info.get("modulation", "")),
            total_bandwidth_gbps=int(lp_info.get("lightpath_bandwidth", lp_info.get("total_bandwidth_gbps", 0))),
            remaining_bandwidth_gbps=int(lp_info.get("remaining_bandwidth", lp_info.get("remaining_bandwidth_gbps", 0))),
            path_weight_km=float(lp_info.get("path_weight", lp_info.get("path_weight_km", 0.0))),
            request_allocations=request_allocations,
            snr_db=lp_info.get("snr_cost", lp_info.get("snr_db")),
            xt_cost=lp_info.get("xt_cost"),
            is_degraded=lp_info.get("is_degraded", False),
            backup_path=backup_path,
            backup_start_slot=lp_info.get("backup_start_slot"),
            backup_end_slot=lp_info.get("backup_end_slot"),
            backup_core=lp_info.get("backup_core"),
            backup_band=lp_info.get("backup_band"),
            is_protected=is_protected,
            active_path=lp_info.get("active_path", "primary"),
        )

    def to_legacy_dict(self) -> dict[str, Any]:
        """
        Convert to legacy dictionary format.

        This enables interoperability with legacy code that expects
        lightpath info dictionaries during the migration period.

        Returns:
            Dictionary compatible with legacy lightpath consumers:
                - "path": list[str]
                - "start_slot": int
                - "end_slot": int
                - "core": int
                - "band": str
                - "mod_format": str
                - "lightpath_bandwidth": float
                - "remaining_bandwidth": float
                - "requests_dict": dict[int, float]
                - "snr_cost": float | None
                - "xt_cost": float | None
                - "path_weight": float
                - "is_degraded": bool
                - "backup_path": list[str] | None
                - "is_protected": bool
                - "active_path": str

        Example:
            >>> lp = Lightpath(lightpath_id=1, path=["0", "5"], ...)
            >>> legacy = lp.to_legacy_dict()
            >>> legacy["mod_format"]
            'QPSK'
        """
        legacy: dict[str, Any] = {
            # Core fields
            "path": self.path,
            "start_slot": self.start_slot,
            "end_slot": self.end_slot,
            "core": self.core,
            "band": self.band,
            "mod_format": self.modulation,

            # Capacity (legacy uses float)
            "lightpath_bandwidth": float(self.total_bandwidth_gbps),
            "remaining_bandwidth": float(self.remaining_bandwidth_gbps),
            "requests_dict": {
                req_id: float(bw) for req_id, bw in self.request_allocations.items()
            },

            # Quality
            "snr_cost": self.snr_db,
            "xt_cost": self.xt_cost,
            "path_weight": self.path_weight_km,
            "is_degraded": self.is_degraded,

            # Protection
            "backup_path": self.backup_path,
            "is_protected": self.is_protected,
            "active_path": self.active_path,
        }

        # Include backup spectrum details if protected
        if self.is_protected:
            legacy["backup_start_slot"] = self.backup_start_slot
            legacy["backup_end_slot"] = self.backup_end_slot
            legacy["backup_core"] = self.backup_core
            legacy["backup_band"] = self.backup_band

        return legacy

    def to_legacy_key(self) -> tuple[str, str]:
        """
        Generate legacy dictionary key (endpoint pair).

        Returns:
            Sorted tuple of (source, destination) for dict indexing.
        """
        return self.endpoint_key
```

---

## Type Handling

### Bandwidth: Float to Int

Legacy code uses `float` for bandwidth, new code uses `int`:

```python
# Legacy
"lightpath_bandwidth": 100.0
"remaining_bandwidth": 50.0
"requests_dict": {42: 50.0}

# New
total_bandwidth_gbps: int = 100
remaining_bandwidth_gbps: int = 50
request_allocations: dict[int, int] = {42: 50}
```

Conversion:
```python
# from_legacy_dict
total_bandwidth_gbps=int(lp_info["lightpath_bandwidth"])

# to_legacy_dict
"lightpath_bandwidth": float(self.total_bandwidth_gbps)
```

### Modulation Field Name

Legacy uses `"mod_format"`, new code uses `modulation`:

```python
# from_legacy_dict - try both
modulation=lp_info.get("mod_format", lp_info.get("modulation", ""))

# to_legacy_dict
"mod_format": self.modulation
```

---

## Roundtrip Invariant

```python
original = {
    "path": ["0", "2", "5"],
    "start_slot": 10,
    "end_slot": 18,
    "core": 0,
    "band": "c",
    "mod_format": "QPSK",
    "lightpath_bandwidth": 100.0,
    "remaining_bandwidth": 50.0,
    "requests_dict": {42: 50.0},
    "snr_cost": 15.5,
    "xt_cost": 0.02,
    "path_weight": 1200.5,
    "is_degraded": False,
    "is_protected": False,
}

lp = Lightpath.from_legacy_dict(1, original)
roundtrip = lp.to_legacy_dict()

# Core fields preserved
assert roundtrip["path"] == original["path"]
assert roundtrip["start_slot"] == original["start_slot"]
assert roundtrip["mod_format"] == original["mod_format"]
assert roundtrip["lightpath_bandwidth"] == original["lightpath_bandwidth"]
```

---

## Edge Cases

### 1. Missing Optional Fields

```python
# Minimal valid legacy dict
minimal = {
    "path": ["0", "5"],
    "start_slot": 0,
    "end_slot": 8,
    "core": 0,
    "band": "c",
    "mod_format": "QPSK",
    "lightpath_bandwidth": 100.0,
    "remaining_bandwidth": 100.0,
}
lp = Lightpath.from_legacy_dict(1, minimal)
assert lp.snr_db is None
assert lp.request_allocations == {}
```

### 2. Protection Without All Fields

```python
# Partial protection info
partial = {
    ...,
    "backup_path": ["0", "3", "5"],
    # Missing is_protected - should infer True
}
lp = Lightpath.from_legacy_dict(1, partial)
assert lp.is_protected is True
```

### 3. Request Allocations Type Coercion

```python
# Request IDs might be strings in some legacy code
legacy = {..., "requests_dict": {"42": 50.0}}
lp = Lightpath.from_legacy_dict(1, legacy)
assert 42 in lp.request_allocations  # Coerced to int
```

---

## Verification

```python
def test_from_legacy_basic():
    lp_info = {
        "path": ["0", "2", "5"],
        "start_slot": 10,
        "end_slot": 18,
        "core": 0,
        "band": "c",
        "mod_format": "QPSK",
        "lightpath_bandwidth": 100.0,
        "remaining_bandwidth": 100.0,
    }
    lp = Lightpath.from_legacy_dict(1, lp_info)

    assert lp.lightpath_id == 1
    assert lp.path == ["0", "2", "5"]
    assert lp.modulation == "QPSK"
    assert lp.total_bandwidth_gbps == 100

def test_to_legacy_basic():
    lp = Lightpath(
        lightpath_id=1,
        path=["0", "5"],
        start_slot=0,
        end_slot=8,
        core=0,
        band="c",
        modulation="QPSK",
        total_bandwidth_gbps=100,
        remaining_bandwidth_gbps=50,
    )
    legacy = lp.to_legacy_dict()

    assert legacy["path"] == ["0", "5"]
    assert legacy["mod_format"] == "QPSK"
    assert legacy["lightpath_bandwidth"] == 100.0

def test_roundtrip():
    original = {...}
    lp = Lightpath.from_legacy_dict(1, original)
    roundtrip = lp.to_legacy_dict()

    assert roundtrip["path"] == original["path"]
    assert roundtrip["mod_format"] == original["mod_format"]
```

---

## Next Task

Proceed to [P1.3.d_verify_lightpath.md](P1.3.d_verify_lightpath.md) to create comprehensive tests.
