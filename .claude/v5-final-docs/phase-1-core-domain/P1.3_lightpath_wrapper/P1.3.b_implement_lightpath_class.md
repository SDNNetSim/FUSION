# Task ID: P1.3.b - Implement Lightpath Class

**Sub-phase**: P1.3 Lightpath Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: refactor-plan

---

## Purpose

Implement the `Lightpath` mutable dataclass with capacity management and computed properties.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.3_lightpath_wrapper/P1.3.a_extract_lightpath_fields.md`
- `.claude/v4-docs/migration/phase_1_core_model.md` (Lightpath section)

---

## Outputs

### Create `fusion/domain/lightpath.py`

```python
"""
Lightpath domain model with capacity management.

This module defines the Lightpath dataclass representing an allocated
optical path with spectrum assignment and capacity tracking.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass
class Lightpath:
    """
    Allocated optical path with capacity management.

    A Lightpath represents an established connection through the network
    with allocated spectrum resources. It tracks capacity usage for
    traffic grooming and supports 1+1 protection.

    Attributes:
        Identity:
            lightpath_id: Unique identifier
            path: Ordered list of node IDs from source to destination

        Spectrum Allocation:
            start_slot: First allocated slot index (inclusive)
            end_slot: Last allocated slot index (exclusive)
            core: Core number for MCF (0-indexed)
            band: Frequency band ("c", "l", "s")
            modulation: Modulation format ("QPSK", "16-QAM", etc.)

        Capacity:
            total_bandwidth_gbps: Maximum capacity
            remaining_bandwidth_gbps: Available for new requests
            request_allocations: Maps request_id -> allocated bandwidth

        Quality:
            snr_db: Signal-to-noise ratio (optional)
            xt_cost: Crosstalk cost (optional)
            path_weight_km: Physical path length in km
            is_degraded: True if quality has degraded

        Protection (1+1):
            backup_path: Disjoint backup path (optional)
            backup_start_slot, backup_end_slot: Backup spectrum range
            backup_core, backup_band: Backup allocation details
            is_protected: Has backup path
            active_path: Currently active path ("primary" or "backup")

    Example:
        >>> lp = Lightpath(
        ...     lightpath_id=1,
        ...     path=["0", "2", "5"],
        ...     start_slot=10,
        ...     end_slot=18,
        ...     core=0,
        ...     band="c",
        ...     modulation="QPSK",
        ...     total_bandwidth_gbps=100,
        ...     remaining_bandwidth_gbps=100,
        ... )
        >>> lp.allocate_bandwidth(42, 50)
        True
        >>> lp.utilization
        0.5
    """

    # =========================================================================
    # Identity Fields
    # =========================================================================
    lightpath_id: int
    path: list[str]

    # =========================================================================
    # Spectrum Allocation
    # =========================================================================
    start_slot: int
    end_slot: int
    core: int
    band: str
    modulation: str

    # =========================================================================
    # Capacity
    # =========================================================================
    total_bandwidth_gbps: int
    remaining_bandwidth_gbps: int
    path_weight_km: float = 0.0
    request_allocations: dict[int, int] = field(default_factory=dict)

    # =========================================================================
    # Quality Metrics
    # =========================================================================
    snr_db: float | None = None
    xt_cost: float | None = None
    is_degraded: bool = False

    # =========================================================================
    # Protection (1+1)
    # =========================================================================
    backup_path: list[str] | None = None
    backup_start_slot: int | None = None
    backup_end_slot: int | None = None
    backup_core: int | None = None
    backup_band: str | None = None
    is_protected: bool = False
    active_path: str = "primary"

    # =========================================================================
    # Validation
    # =========================================================================
    def __post_init__(self) -> None:
        """Validate lightpath after creation."""
        if len(self.path) < 2:
            raise ValueError("path must have at least 2 nodes")
        if self.start_slot >= self.end_slot:
            raise ValueError("start_slot must be < end_slot")
        if self.core < 0:
            raise ValueError("core must be >= 0")
        if self.total_bandwidth_gbps <= 0:
            raise ValueError("total_bandwidth_gbps must be > 0")
        if self.remaining_bandwidth_gbps < 0:
            raise ValueError("remaining_bandwidth_gbps must be >= 0")
        if self.remaining_bandwidth_gbps > self.total_bandwidth_gbps:
            raise ValueError("remaining_bandwidth_gbps cannot exceed total_bandwidth_gbps")
        if self.active_path not in ("primary", "backup"):
            raise ValueError("active_path must be 'primary' or 'backup'")

        # Protection consistency
        if self.is_protected and self.backup_path is None:
            raise ValueError("is_protected=True requires backup_path")
        if self.backup_path is not None and not self.is_protected:
            raise ValueError("backup_path requires is_protected=True")

    # =========================================================================
    # Computed Properties
    # =========================================================================
    @property
    def source(self) -> str:
        """Source node ID."""
        return self.path[0]

    @property
    def destination(self) -> str:
        """Destination node ID."""
        return self.path[-1]

    @property
    def endpoint_key(self) -> tuple[str, str]:
        """
        Canonical endpoint pair for lightpath matching.

        Returns sorted tuple to ensure bidirectional matching.
        """
        return tuple(sorted([self.source, self.destination]))  # type: ignore[return-value]

    @property
    def num_slots(self) -> int:
        """Number of spectrum slots used."""
        return self.end_slot - self.start_slot

    @property
    def num_hops(self) -> int:
        """Number of links in the path."""
        return len(self.path) - 1

    @property
    def utilization(self) -> float:
        """
        Bandwidth utilization ratio.

        Returns:
            Float between 0.0 and 1.0 representing capacity usage.
        """
        if self.total_bandwidth_gbps == 0:
            return 0.0
        used = self.total_bandwidth_gbps - self.remaining_bandwidth_gbps
        return used / self.total_bandwidth_gbps

    @property
    def has_capacity(self) -> bool:
        """True if lightpath can accept more traffic."""
        return self.remaining_bandwidth_gbps > 0

    @property
    def num_requests(self) -> int:
        """Number of requests using this lightpath."""
        return len(self.request_allocations)

    @property
    def is_empty(self) -> bool:
        """True if no requests are using this lightpath."""
        return len(self.request_allocations) == 0

    # =========================================================================
    # Capacity Management
    # =========================================================================
    def can_accommodate(self, bandwidth_gbps: int) -> bool:
        """
        Check if lightpath can accommodate the requested bandwidth.

        Args:
            bandwidth_gbps: Bandwidth to check

        Returns:
            True if sufficient capacity available
        """
        return self.remaining_bandwidth_gbps >= bandwidth_gbps

    def allocate_bandwidth(self, request_id: int, bandwidth_gbps: int) -> bool:
        """
        Allocate bandwidth to a request.

        Args:
            request_id: ID of the request
            bandwidth_gbps: Bandwidth to allocate

        Returns:
            True if allocation successful, False if insufficient capacity

        Raises:
            ValueError: If request_id already has an allocation
        """
        if request_id in self.request_allocations:
            raise ValueError(f"Request {request_id} already has allocation on this lightpath")

        if bandwidth_gbps <= 0:
            raise ValueError("bandwidth_gbps must be > 0")

        if not self.can_accommodate(bandwidth_gbps):
            return False

        self.request_allocations[request_id] = bandwidth_gbps
        self.remaining_bandwidth_gbps -= bandwidth_gbps
        return True

    def release_bandwidth(self, request_id: int) -> int:
        """
        Release bandwidth from a request.

        Args:
            request_id: ID of the request to release

        Returns:
            Amount of bandwidth released

        Raises:
            KeyError: If request_id has no allocation
        """
        if request_id not in self.request_allocations:
            raise KeyError(f"Request {request_id} has no allocation on this lightpath")

        bandwidth = self.request_allocations.pop(request_id)
        self.remaining_bandwidth_gbps += bandwidth
        return bandwidth

    def get_allocation(self, request_id: int) -> int | None:
        """
        Get bandwidth allocated to a request.

        Args:
            request_id: ID of the request

        Returns:
            Allocated bandwidth or None if no allocation
        """
        return self.request_allocations.get(request_id)

    # =========================================================================
    # Protection
    # =========================================================================
    def switch_to_backup(self) -> bool:
        """
        Switch to backup path (for failure recovery).

        Returns:
            True if switch successful, False if not protected

        Raises:
            ValueError: If already on backup path
        """
        if not self.is_protected:
            return False

        if self.active_path == "backup":
            raise ValueError("Already on backup path")

        self.active_path = "backup"
        return True

    def switch_to_primary(self) -> bool:
        """
        Switch back to primary path (after recovery).

        Returns:
            True if switch successful, False if not protected

        Raises:
            ValueError: If already on primary path
        """
        if not self.is_protected:
            return False

        if self.active_path == "primary":
            raise ValueError("Already on primary path")

        self.active_path = "primary"
        return True

    @property
    def current_path(self) -> list[str]:
        """Get currently active path."""
        if self.active_path == "backup" and self.backup_path is not None:
            return self.backup_path
        return self.path

    # =========================================================================
    # Legacy Adapters (stubs - implemented in P1.3.c)
    # =========================================================================
    @classmethod
    def from_legacy_dict(
        cls,
        lightpath_id: int,
        lp_info: dict[str, Any],
    ) -> Lightpath:
        """
        Create Lightpath from legacy dictionary.

        Args:
            lightpath_id: Unique lightpath identifier
            lp_info: Legacy lightpath info dictionary

        Returns:
            New Lightpath instance
        """
        raise NotImplementedError("Implement in P1.3.c")

    def to_legacy_dict(self) -> dict[str, Any]:
        """
        Convert to legacy dictionary format.

        Returns:
            Dictionary compatible with legacy code
        """
        raise NotImplementedError("Implement in P1.3.c")
```

---

## Design Decisions

### 1. Mutable Dataclass (not frozen)

`Lightpath` is mutable because:
- Capacity changes during grooming
- Quality metrics may change (degradation)
- Active path switches during protection

### 2. Explicit Capacity Methods

Instead of direct attribute modification:
```python
# Discouraged
lp.remaining_bandwidth_gbps -= 50
lp.request_allocations[42] = 50

# Preferred - maintains invariants
lp.allocate_bandwidth(42, 50)
```

### 3. Capacity Invariant

The class maintains:
```python
remaining == total - sum(allocations.values())
```

All capacity methods maintain this invariant.

### 4. Protection as Optional Fields

Protection fields are all optional (`None`) for unprotected lightpaths.
When `is_protected=True`, all backup fields should be set.

---

## Update `fusion/domain/__init__.py`

```python
"""FUSION Domain Model Package."""

from fusion.domain.config import SimulationConfig
from fusion.domain.lightpath import Lightpath
from fusion.domain.request import BlockReason, Request, RequestStatus

__all__ = [
    "SimulationConfig",
    "Request",
    "RequestStatus",
    "BlockReason",
    "Lightpath",
]
```

---

## Next Task

Proceed to [P1.3.c_implement_lightpath_adapters.md](P1.3.c_implement_lightpath_adapters.md) to implement legacy adapters.
