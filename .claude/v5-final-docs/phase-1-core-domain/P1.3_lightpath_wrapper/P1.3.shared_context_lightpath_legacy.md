# Shared Context: Legacy Lightpath Structure

**Purpose**: Document current lightpath representations for P1.3 tasks
**Source**: Extracted from `fusion/core/grooming.py` and related modules

---

## Current Lightpath Status Dictionary

From `fusion/core/grooming.py` (lines 60-158), lightpaths are stored in a nested dictionary structure.

### Dictionary Indexing

```python
lightpath_status_dict: dict[tuple[str, str], dict[int, dict[str, Any]]] = {
    ("0", "5"): {           # light_id = sorted(source, destination)
        1: {...},            # lightpath_id = 1
        3: {...},            # lightpath_id = 3
    },
    ("2", "7"): {
        2: {...},
    },
}
```

### Lightpath Entry Structure

```python
lightpath_status_dict[light_id][lightpath_id] = {
    # Identity
    "path": list[str],              # ["0", "2", "5"] - list of node IDs

    # Spectrum allocation
    "start_slot": int,              # Starting slot index
    "end_slot": int,                # Ending slot index (exclusive)
    "core": int,                    # Core number (0-indexed)
    "band": str,                    # Frequency band ("c", "l", "s")
    "mod_format": str,              # Modulation format ("QPSK", "16-QAM", etc.)

    # Capacity
    "lightpath_bandwidth": float,   # Total bandwidth in Gbps
    "remaining_bandwidth": float,   # Available bandwidth for grooming

    # Quality metrics
    "snr_cost": float,              # SNR value in dB
    "xt_cost": float,               # Crosstalk cost
    "path_weight": float,           # Path length in km
    "is_degraded": bool,            # True if SNR has degraded

    # Request tracking
    "requests_dict": dict[int, float],  # Maps request_id -> allocated_bandwidth

    # Utilization history
    "time_bw_usage": dict[float, float],  # Maps time -> utilization_percentage
}
```

### Example Entry

```python
{
    "path": ["0", "2", "4", "5"],
    "start_slot": 10,
    "end_slot": 18,
    "core": 0,
    "band": "c",
    "mod_format": "QPSK",
    "lightpath_bandwidth": 100.0,
    "remaining_bandwidth": 50.0,
    "snr_cost": 15.5,
    "xt_cost": 0.02,
    "path_weight": 1200.5,
    "is_degraded": False,
    "requests_dict": {42: 50.0},
    "time_bw_usage": {0.0: 0.0, 12.345: 0.5},
}
```

---

## Protection Fields

For 1+1 protected lightpaths, additional fields are used:

```python
{
    # Primary path (standard fields)
    "path": ["0", "2", "5"],
    ...

    # Backup path (protection)
    "backup_path": ["0", "3", "5"],      # Disjoint backup path
    "backup_start_slot": int,             # Backup spectrum start
    "backup_end_slot": int,               # Backup spectrum end
    "backup_core": int,                   # Backup core number
    "backup_band": str,                   # Backup band
    "is_protected": bool,                 # True if protected
    "active_path": str,                   # "primary" or "backup"
}
```

---

## Lightpath ID Generation

From `fusion/core/properties.py`, SDNProps manages lightpath IDs:

```python
class SDNProps:
    lightpath_counter: int = 0  # Auto-incrementing counter

    def get_lightpath_id(self) -> int:
        """Generate unique lightpath ID."""
        self.lightpath_counter += 1
        return self.lightpath_counter
```

---

## Mapping to Lightpath Dataclass

| Legacy Field | Lightpath Field | Notes |
|--------------|-----------------|-------|
| (key) | `lightpath_id` | Integer from dict key |
| `path` | `path` | Direct mapping |
| `start_slot` | `start_slot` | Direct mapping |
| `end_slot` | `end_slot` | Direct mapping |
| `core` | `core` | Direct mapping |
| `band` | `band` | Direct mapping |
| `mod_format` | `modulation` | Renamed for clarity |
| `lightpath_bandwidth` | `total_bandwidth_gbps` | Renamed |
| `remaining_bandwidth` | `remaining_bandwidth_gbps` | Renamed |
| `snr_cost` | `snr_db` | Renamed |
| `xt_cost` | `xt_cost` | Direct mapping |
| `path_weight` | `path_weight_km` | Renamed with unit |
| `is_degraded` | `is_degraded` | Direct mapping |
| `requests_dict` | `request_allocations` | Renamed |
| `backup_path` | `backup_path` | Direct mapping |
| `is_protected` | `is_protected` | Direct mapping |
| `active_path` | `active_path` | Direct mapping |

---

## Computed Properties

Derived from stored fields:

```python
@property
def endpoint_key(self) -> tuple[str, str]:
    """Canonical endpoint pair."""
    return tuple(sorted([self.path[0], self.path[-1]]))

@property
def num_slots(self) -> int:
    """Number of spectrum slots used."""
    return self.end_slot - self.start_slot

@property
def num_hops(self) -> int:
    """Number of hops (links) in the path."""
    return len(self.path) - 1

@property
def utilization(self) -> float:
    """Bandwidth utilization ratio (0.0 to 1.0)."""
    if self.total_bandwidth_gbps == 0:
        return 0.0
    return (self.total_bandwidth_gbps - self.remaining_bandwidth_gbps) / self.total_bandwidth_gbps
```

---

## Capacity Invariant

Must always hold:

```python
assert self.remaining_bandwidth_gbps >= 0
assert sum(self.request_allocations.values()) <= self.total_bandwidth_gbps
assert self.remaining_bandwidth_gbps == self.total_bandwidth_gbps - sum(self.request_allocations.values())
```

---

## Reference Files

For the complete source of truth, see:
- `fusion/core/grooming.py` - Lightpath status dict usage
- `fusion/core/properties.py` - SDNProps with lightpath tracking
- `fusion/core/sdn_controller.py` - Lightpath allocation
