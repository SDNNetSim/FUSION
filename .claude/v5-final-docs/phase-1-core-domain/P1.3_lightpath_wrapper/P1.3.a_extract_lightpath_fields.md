# Task ID: P1.3.a - Extract Lightpath Fields

**Sub-phase**: P1.3 Lightpath Wrapper
**Scope**: Phase 1 - Core Domain Model only
**Task type**: context-extraction

---

## Purpose

Extract and document all lightpath-related fields from the current codebase to inform the `Lightpath` dataclass design.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.3_lightpath_wrapper/P1.3.shared_context_lightpath_legacy.md`
- `fusion/core/grooming.py` (lines 60-158)
- `fusion/core/properties.py` (SDNProps class)

---

## Outputs

### 1. Identity Fields (Immutable after creation)

```python
lightpath_id: int       # Unique identifier
path: list[str]         # Ordered list of node IDs [src, ..., dst]
```

### 2. Spectrum Allocation Fields (Set at creation)

```python
start_slot: int         # First allocated slot index
end_slot: int           # Last allocated slot index + 1 (exclusive)
core: int               # Core number (0-indexed for MCF)
band: str               # Frequency band ("c", "l", "s")
modulation: str         # Modulation format ("QPSK", "16-QAM", etc.)
```

### 3. Capacity Fields (Mutable during grooming)

```python
total_bandwidth_gbps: int          # Maximum capacity
remaining_bandwidth_gbps: int      # Available for new requests
request_allocations: dict[int, int]  # Maps request_id -> allocated_gbps
```

### 4. Quality Metrics (May change if network degrades)

```python
snr_db: float | None = None        # Signal-to-noise ratio
xt_cost: float | None = None       # Crosstalk cost
path_weight_km: float = 0.0        # Physical path length
is_degraded: bool = False          # True if quality has degraded
```

### 5. Protection Fields (For 1+1 protection)

```python
backup_path: list[str] | None = None      # Disjoint backup path
backup_start_slot: int | None = None      # Backup spectrum start
backup_end_slot: int | None = None        # Backup spectrum end
backup_core: int | None = None            # Backup core
backup_band: str | None = None            # Backup band
is_protected: bool = False                # Has backup path
active_path: str = "primary"              # "primary" or "backup"
```

---

## Field Sources in Current Codebase

| New Field | Source Location | Current Key |
|-----------|-----------------|-------------|
| `lightpath_id` | dict key | (integer key in nested dict) |
| `path` | lightpath entry | `"path"` |
| `start_slot` | lightpath entry | `"start_slot"` |
| `end_slot` | lightpath entry | `"end_slot"` |
| `core` | lightpath entry | `"core"` |
| `band` | lightpath entry | `"band"` |
| `modulation` | lightpath entry | `"mod_format"` |
| `total_bandwidth_gbps` | lightpath entry | `"lightpath_bandwidth"` |
| `remaining_bandwidth_gbps` | lightpath entry | `"remaining_bandwidth"` |
| `request_allocations` | lightpath entry | `"requests_dict"` |
| `snr_db` | lightpath entry | `"snr_cost"` |
| `xt_cost` | lightpath entry | `"xt_cost"` |
| `path_weight_km` | lightpath entry | `"path_weight"` |
| `is_degraded` | lightpath entry | `"is_degraded"` |
| `backup_path` | lightpath entry | `"backup_path"` |
| `is_protected` | lightpath entry | `"is_protected"` |
| `active_path` | lightpath entry | `"active_path"` |

---

## Validation Rules

From `validation_rules.md` and codebase analysis:

1. `len(path) >= 2` - Path must have at least source and destination
2. `start_slot < end_slot` - Valid slot range
3. `core >= 0` - Non-negative core index
4. `band in ("c", "l", "s", "o", "e")` - Valid band
5. `total_bandwidth_gbps > 0` - Positive capacity
6. `remaining_bandwidth_gbps >= 0` - Non-negative available
7. `remaining_bandwidth_gbps <= total_bandwidth_gbps` - Cannot exceed total
8. If `is_protected`, then `backup_path is not None`
9. If `backup_path is not None`, then `is_protected is True`
10. `active_path in ("primary", "backup")` - Valid active path

---

## Capacity Invariant

```python
remaining_bandwidth_gbps == total_bandwidth_gbps - sum(request_allocations.values())
```

This invariant must be maintained by all capacity-modifying methods.

---

## Computed Properties

```python
@property
def endpoint_key(self) -> tuple[str, str]:
    """Canonical endpoint pair for matching."""
    return tuple(sorted([self.path[0], self.path[-1]]))

@property
def num_slots(self) -> int:
    """Number of spectrum slots."""
    return self.end_slot - self.start_slot

@property
def num_hops(self) -> int:
    """Number of links in path."""
    return len(self.path) - 1

@property
def utilization(self) -> float:
    """Capacity utilization (0.0 to 1.0)."""
    if self.total_bandwidth_gbps == 0:
        return 0.0
    used = self.total_bandwidth_gbps - self.remaining_bandwidth_gbps
    return used / self.total_bandwidth_gbps

@property
def source(self) -> str:
    """Source node."""
    return self.path[0]

@property
def destination(self) -> str:
    """Destination node."""
    return self.path[-1]

@property
def has_capacity(self) -> bool:
    """True if can accept more traffic."""
    return self.remaining_bandwidth_gbps > 0
```

---

## Capacity Management Methods

```python
def allocate_bandwidth(self, request_id: int, bandwidth_gbps: int) -> bool:
    """
    Allocate bandwidth to a request.

    Returns True if allocation successful, False if insufficient capacity.
    """

def release_bandwidth(self, request_id: int) -> int:
    """
    Release bandwidth from a request.

    Returns the amount of bandwidth released.
    """

def can_accommodate(self, bandwidth_gbps: int) -> bool:
    """Check if lightpath can accommodate bandwidth."""
    return self.remaining_bandwidth_gbps >= bandwidth_gbps
```

---

## Next Task

Proceed to [P1.3.b_implement_lightpath_class.md](P1.3.b_implement_lightpath_class.md) to implement the Lightpath dataclass.
