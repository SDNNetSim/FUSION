# Task ID: P1.1.c - Implement Config Adapters

**Sub-phase**: P1.1 Domain Scaffolding
**Scope**: Phase 1 - Core Domain Model only
**Task type**: refactor-plan

---

## Purpose

Implement `from_engine_props()` and `to_engine_props()` methods for bidirectional conversion between `SimulationConfig` and legacy `engine_props` dictionaries.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.1_domain_scaffolding/P1.1.shared_context_engine_props.md`
- `fusion/domain/config.py` (from P1.1.b)
- `fusion/core/properties.py` (lines 1-100, EngineProps structure)

---

## Outputs

### Update `fusion/domain/config.py` - Replace adapter stubs

Replace the `from_engine_props` and `to_engine_props` stub methods with:

```python
    @classmethod
    def from_engine_props(cls, engine_props: dict[str, Any]) -> SimulationConfig:
        """
        Create SimulationConfig from legacy engine_props dictionary.

        Args:
            engine_props: Legacy configuration dictionary containing:
                - network: Network name
                - cores_per_link: Cores per fiber
                - band_list: List of bands
                - c_band, l_band, s_band: Slot counts (optional)
                - guard_slots: Guard band slots
                - num_requests: Request count
                - arrival_rate: Poisson arrival rate
                - holding_time: Mean holding time
                - route_method: Routing algorithm
                - k_paths: K-shortest paths count
                - allocation_method: Spectrum allocation method
                - is_grooming_enabled: Grooming flag (optional)
                - max_segments: Max slices (optional)
                - snr_type: SNR validation type (optional)
                - mod_per_bw: Modulation formats per bandwidth

        Returns:
            New SimulationConfig instance

        Raises:
            KeyError: If required fields are missing
            ValueError: If field values are invalid

        Example:
            >>> engine_props = {
            ...     "network": "NSFNET",
            ...     "cores_per_link": 1,
            ...     "band_list": ["c"],
            ...     "c_band": 320,
            ...     "guard_slots": 1,
            ...     "num_requests": 1000,
            ...     "arrival_rate": 10.0,
            ...     "holding_time": 5.0,
            ...     "route_method": "k_shortest_path",
            ...     "k_paths": 3,
            ...     "allocation_method": "first_fit",
            ... }
            >>> config = SimulationConfig.from_engine_props(engine_props)
            >>> config.network_name
            'NSFNET'
        """
        # Extract band list (convert list to tuple for immutability)
        band_list_raw = engine_props.get("band_list", ["c"])
        band_list = tuple(band_list_raw) if isinstance(band_list_raw, list) else (band_list_raw,)

        # Build band_slots dict from individual band slot counts
        band_slots: dict[str, int] = {}
        band_key_map = {"c": "c_band", "l": "l_band", "s": "s_band", "o": "o_band", "e": "e_band"}
        for band in band_list:
            key = band_key_map.get(band, f"{band}_band")
            band_slots[band] = engine_props.get(key, 320)  # Default 320 slots

        # Compute erlang from arrival_rate and holding_time
        arrival_rate = engine_props.get("arrival_rate", 1.0)
        holding_time = engine_props.get("holding_time", 1.0)
        erlang = arrival_rate * holding_time

        # Extract SNR configuration
        snr_type = engine_props.get("snr_type")
        snr_enabled = snr_type is not None and snr_type != ""

        # Extract modulation configuration
        mod_per_bw = engine_props.get("mod_per_bw", {})
        modulation_formats = engine_props.get("modulation_formats", {})
        snr_thresholds = engine_props.get("snr_thresholds", {})

        return cls(
            # Network
            network_name=engine_props["network"],
            cores_per_link=engine_props.get("cores_per_link", 1),
            band_list=band_list,
            band_slots=band_slots,
            guard_slots=engine_props.get("guard_slots", 1),

            # Traffic
            num_requests=engine_props.get("num_requests", 1000),
            erlang=erlang,
            holding_time=holding_time,

            # Routing
            route_method=engine_props.get("route_method", "k_shortest_path"),
            k_paths=engine_props.get("k_paths", 3),
            allocation_method=engine_props.get("allocation_method", "first_fit"),

            # Features
            grooming_enabled=engine_props.get("is_grooming_enabled", False),
            slicing_enabled=engine_props.get("max_segments", 1) > 1,
            max_slices=engine_props.get("max_segments", 1),
            snr_enabled=snr_enabled,
            snr_type=snr_type if snr_enabled else None,
            snr_recheck=engine_props.get("snr_recheck", False),
            can_partially_serve=engine_props.get("can_partially_serve", False),

            # Modulation
            modulation_formats=modulation_formats,
            mod_per_bw=mod_per_bw,
            snr_thresholds=snr_thresholds,
        )

    def to_engine_props(self) -> dict[str, Any]:
        """
        Convert to legacy engine_props dictionary format.

        This method enables gradual migration by allowing new code using
        SimulationConfig to interoperate with legacy code expecting dicts.

        Returns:
            Dictionary compatible with legacy engine_props consumers

        Example:
            >>> config = SimulationConfig(...)
            >>> props = config.to_engine_props()
            >>> props["network"]
            'NSFNET'
        """
        props: dict[str, Any] = {
            # Network
            "network": self.network_name,
            "cores_per_link": self.cores_per_link,
            "band_list": list(self.band_list),  # Convert tuple back to list
            "guard_slots": self.guard_slots,

            # Traffic
            "num_requests": self.num_requests,
            "arrival_rate": self.arrival_rate,  # Computed property
            "holding_time": self.holding_time,

            # Routing
            "route_method": self.route_method,
            "k_paths": self.k_paths,
            "allocation_method": self.allocation_method,

            # Features
            "is_grooming_enabled": self.grooming_enabled,
            "max_segments": self.max_slices,
            "snr_type": self.snr_type,
            "snr_recheck": self.snr_recheck,
            "can_partially_serve": self.can_partially_serve,

            # Modulation
            "modulation_formats": self.modulation_formats,
            "mod_per_bw": self.mod_per_bw,
            "snr_thresholds": self.snr_thresholds,
        }

        # Add individual band slot counts
        band_key_map = {"c": "c_band", "l": "l_band", "s": "s_band", "o": "o_band", "e": "e_band"}
        for band, slots in self.band_slots.items():
            key = band_key_map.get(band, f"{band}_band")
            props[key] = slots

        return props
```

---

## Roundtrip Invariant

The following must hold for all valid `engine_props`:

```python
original = {...}  # Valid engine_props dict
config = SimulationConfig.from_engine_props(original)
roundtrip = config.to_engine_props()

# All essential fields preserved
assert roundtrip["network"] == original["network"]
assert roundtrip["k_paths"] == original["k_paths"]
assert roundtrip["route_method"] == original["route_method"]
# ... etc
```

---

## Edge Cases to Handle

### 1. Missing Optional Fields

```python
# Minimal valid engine_props
minimal = {
    "network": "test",
    "num_requests": 100,
}
# Should use defaults for all optional fields
config = SimulationConfig.from_engine_props(minimal)
```

### 2. Empty Band List

```python
# Default to C-band if not specified
props = {"network": "test", "num_requests": 100}
config = SimulationConfig.from_engine_props(props)
assert config.band_list == ("c",)
```

### 3. SNR Type Variations

```python
# Empty string should be treated as None
props = {..., "snr_type": ""}
config = SimulationConfig.from_engine_props(props)
assert config.snr_type is None
assert config.snr_enabled is False
```

---

## Verification

```python
# Test roundtrip conversion
def test_roundtrip():
    original = {
        "network": "NSFNET",
        "cores_per_link": 2,
        "band_list": ["c", "l"],
        "c_band": 320,
        "l_band": 320,
        "guard_slots": 1,
        "num_requests": 1000,
        "arrival_rate": 10.0,
        "holding_time": 5.0,
        "route_method": "k_shortest_path",
        "k_paths": 3,
        "allocation_method": "first_fit",
        "is_grooming_enabled": True,
        "max_segments": 4,
        "snr_type": "snr_e2e",
    }

    config = SimulationConfig.from_engine_props(original)
    roundtrip = config.to_engine_props()

    assert roundtrip["network"] == original["network"]
    assert roundtrip["cores_per_link"] == original["cores_per_link"]
    assert roundtrip["k_paths"] == original["k_paths"]
    assert roundtrip["is_grooming_enabled"] == original["is_grooming_enabled"]
```

---

## Next Task

Proceed to [P1.1.d_verify_config.md](P1.1.d_verify_config.md) to create comprehensive tests.
