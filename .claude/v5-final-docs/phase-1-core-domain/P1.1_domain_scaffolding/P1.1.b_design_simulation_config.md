# Task ID: P1.1.b - Design SimulationConfig

**Sub-phase**: P1.1 Domain Scaffolding
**Scope**: Phase 1 - Core Domain Model only
**Task type**: design

---

## Purpose

Define the complete `SimulationConfig` frozen dataclass with all fields, types, and documentation.

---

## Context to load before running this task

- `.claude/v5-final-docs/phase-1-core-domain/P1.1_domain_scaffolding/P1.1.shared_context_engine_props.md`
- `.claude/v4-docs/migration/phase_1_core_model.md` (SimulationConfig section)
- `fusion/domain/config.py` (stub from P1.1.a)

---

## Outputs

### Replace `fusion/domain/config.py` with full implementation

```python
"""
SimulationConfig - Immutable simulation configuration.

This module defines the SimulationConfig frozen dataclass that replaces
the legacy engine_props dictionary with a typed, immutable structure.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class SimulationConfig:
    """
    Immutable simulation configuration.

    This dataclass captures all simulation parameters in a typed,
    frozen structure. Once created, the configuration cannot be modified.

    Attributes:
        Network Configuration:
            network_name: Network topology identifier (e.g., "USbackbone60")
            cores_per_link: Number of cores per fiber link (MCF support)
            band_list: Available frequency bands as immutable tuple
            band_slots: Slot count per band (e.g., {"c": 320, "l": 320})
            guard_slots: Guard band slots between allocations

        Traffic Configuration:
            num_requests: Total requests to simulate
            erlang: Traffic intensity (arrival_rate * holding_time)
            holding_time: Mean request duration

        Routing Configuration:
            route_method: Routing algorithm name
            k_paths: Number of candidate paths to compute
            allocation_method: Spectrum allocation strategy

        Feature Flags:
            grooming_enabled: Enable traffic grooming
            slicing_enabled: Enable lightpath slicing
            max_slices: Maximum slices per request
            snr_enabled: Enable SNR validation
            snr_type: SNR calculation method or None
            snr_recheck: Re-validate SNR after allocation
            can_partially_serve: Allow partial bandwidth fulfillment

        Modulation Configuration:
            modulation_formats: Available modulation format definitions
            mod_per_bw: Modulation formats available per bandwidth
            snr_thresholds: SNR thresholds per modulation format

    Example:
        >>> config = SimulationConfig.from_engine_props(engine_props)
        >>> config.k_paths
        3
        >>> config.grooming_enabled
        True
        >>> legacy = config.to_engine_props()
    """

    # =========================================================================
    # Network Configuration
    # =========================================================================
    network_name: str
    cores_per_link: int
    band_list: tuple[str, ...]  # Immutable tuple: ("c",) or ("c", "l")
    band_slots: dict[str, int]  # {"c": 320, "l": 320, "s": 320}
    guard_slots: int

    # =========================================================================
    # Traffic Configuration
    # =========================================================================
    num_requests: int
    erlang: float
    holding_time: float

    # =========================================================================
    # Routing Configuration
    # =========================================================================
    route_method: str  # "k_shortest_path", "1plus1_protection", etc.
    k_paths: int
    allocation_method: str  # "first_fit", "best_fit", "last_fit"

    # =========================================================================
    # Feature Flags
    # =========================================================================
    grooming_enabled: bool = False
    slicing_enabled: bool = False
    max_slices: int = 1
    snr_enabled: bool = False
    snr_type: str | None = None  # "snr_e2e", "snr_segment", or None
    snr_recheck: bool = False
    can_partially_serve: bool = False

    # =========================================================================
    # Modulation Configuration
    # =========================================================================
    modulation_formats: dict[str, Any] = field(default_factory=dict)
    mod_per_bw: dict[str, Any] = field(default_factory=dict)
    snr_thresholds: dict[str, float] = field(default_factory=dict)

    # =========================================================================
    # Validation
    # =========================================================================
    def __post_init__(self) -> None:
        """Validate configuration after creation."""
        # Validate network config
        if self.cores_per_link < 1:
            raise ValueError("cores_per_link must be >= 1")
        if not self.band_list:
            raise ValueError("band_list cannot be empty")
        if self.guard_slots < 0:
            raise ValueError("guard_slots must be >= 0")

        # Validate traffic config
        if self.num_requests < 1:
            raise ValueError("num_requests must be >= 1")
        if self.erlang <= 0:
            raise ValueError("erlang must be > 0")
        if self.holding_time <= 0:
            raise ValueError("holding_time must be > 0")

        # Validate routing config
        if self.k_paths < 1:
            raise ValueError("k_paths must be >= 1")

        # Validate feature flags
        if self.max_slices < 1:
            raise ValueError("max_slices must be >= 1")

        # Validate band_slots matches band_list
        for band in self.band_list:
            if band not in self.band_slots:
                raise ValueError(f"band_slots missing entry for band '{band}'")

    # =========================================================================
    # Computed Properties
    # =========================================================================
    @property
    def total_slots(self) -> int:
        """Total spectrum slots across all bands."""
        return sum(self.band_slots.values())

    @property
    def arrival_rate(self) -> float:
        """Computed arrival rate from erlang and holding_time."""
        return self.erlang / self.holding_time

    @property
    def is_multiband(self) -> bool:
        """True if using multiple frequency bands."""
        return len(self.band_list) > 1

    @property
    def is_multicore(self) -> bool:
        """True if using multiple cores per fiber."""
        return self.cores_per_link > 1

    # =========================================================================
    # Legacy Adapters (stubs - implemented in P1.1.c)
    # =========================================================================
    @classmethod
    def from_engine_props(cls, engine_props: dict[str, Any]) -> SimulationConfig:
        """
        Create SimulationConfig from legacy engine_props dictionary.

        Args:
            engine_props: Legacy configuration dictionary

        Returns:
            New SimulationConfig instance

        Raises:
            KeyError: If required fields are missing
            ValueError: If field values are invalid
        """
        raise NotImplementedError("Implement in P1.1.c")

    def to_engine_props(self) -> dict[str, Any]:
        """
        Convert to legacy engine_props dictionary format.

        Returns:
            Dictionary compatible with legacy code
        """
        raise NotImplementedError("Implement in P1.1.c")
```

---

## Field Design Decisions

### 1. Immutable Collections

- `band_list` uses `tuple[str, ...]` instead of `list[str]` for immutability
- `band_slots`, `modulation_formats`, `mod_per_bw` use `dict` (shallow immutability from frozen dataclass)

### 2. Naming Conventions

| Legacy Name | Config Name | Reason |
|-------------|-------------|--------|
| `network` | `network_name` | Clarity: it's the name, not the object |
| `is_grooming_enabled` | `grooming_enabled` | Remove `is_` prefix for dataclass fields |
| `max_segments` | `max_slices` | Align with "slicing" terminology |

### 3. Computed vs Stored

- `erlang` is stored (user-facing config value)
- `arrival_rate` is computed property (derived from erlang/holding_time)

### 4. SNR Configuration

- `snr_enabled` is computed from `snr_type is not None`
- But we store it explicitly for clearer intent

---

## Verification

```bash
# Verify types
mypy fusion/domain/config.py

# Verify frozen behavior
python -c "
from fusion.domain.config import SimulationConfig
# This should fail if properly frozen
"
```

---

## Next Task

Proceed to [P1.1.c_implement_config_adapters.md](P1.1.c_implement_config_adapters.md) to implement the legacy adapters.
