# An example of running the simulation with Arash's research assumptions, paper cited in run_sim.py

# For every simulation, you must label it s* (some number)
[s1]
# If you'd like to disable warnings in the simulator, you shouldn't do this unless you understand the entire simulator
# line by line!
warnings = True
# Valid simulation type assumptions are arash and yue
sim_type = arash
# Valid options are USNet, NSFNet, and Pan-European
network = Pan-European
# The range of traffic volumes
erlangs = {'start': 50, 'stop': 200, 'step': 50}
# The holding time for the requests
holding_time = 3600.0
# If you would like to run Erlang values in parallel or not
thread_erlangs = False
# The number of requests for a single iteration
num_requests = 10000
# The maximum number of iterations allowed
max_iters = 10
# The number of spectral slots per core for every link
spectral_slots = 256
# The frequency for one spectral slot on any given core in GHz
bw_per_slot = 12.5
# The amount of cores for every link in the network
cores_per_link = 1
# Whether link lengths are considered as weights or a constant value of one
const_link_weight = True
# How many spectral slots will be allocated for a guard band
guard_slots = 1
# The maximum number of light segments for a single request (light segment slicing)
max_segments = 1
# Whether dynamic light path slicing should be allowed or not
dynamic_lps = False
# The spectrum assignment allocation method, valid values are first_fit, best_fit, last_fit, cross_talk_aware
allocation_method = first_fit
# If k_shortest_path selected, how many paths to consider
k_paths=4
# The routing policy, valid values are least-congested, nli_aware, shortest_path, k_shortest_path,
# xt_aware, and ai (specified below)
route_method = least_congested
# Options are with length and without length
xt_type = without_length
# Only used for nli-aware routing, determines the tradeoff between link length and nli cost
# Must be between 0.0-1.0
beta = 0.5
# The keys are bandwidth in Gbps, the values can be anywhere from 0.0-1.0
# They MUST add up to 1.0 if you want the simulator the work properly
request_distribution = {"25": 0.0, "50": 0.0, "100": 0.5, "200": 0.0, "400": 0.5}
# The only valid algorithm at the moment is q_learning
# Assign None if no ai_algorithm will be used
ai_algorithm = None
# Arguments related to the ai_algorithm, all valid parameters are listed here
ai_arguments = {"is_training": "True", "table_path": "None", "epsilon": 0.2, "learn_rate": 0.3, "discount": 0.1}

# A flag to determine if we'd like to check the SNR values for each request
# Valid options are None, snr_calculation_nli, xt_calculation, and snr_calculation_xt
check_snr = None
# Parameters related to SNR calculations, please see snr_measurements.py for a more in-depth explanation
# If you don't know what these are, odds are you shouldn't use them :)
input_power = 0.001
egn_model = False
phi = {"QPSK": 1, "16-QAM": 0.68, "64-QAM": 0.6190476190476191}
bi_directional = True
xt_noise = False
# Adopted from Table I in  https://doi.org/10.1109/JPHOT.2016.2523993
requested_xt = {"QPSK": -18.5, "16-QAM": -25.0, "64-QAM": -34.0}

# An example of how to run multiple threads, you ONLY have to write the labels you'd like
# to be changed between simulations, for example, the number of cores per link, all other params
# will be the same as s1
[s2]
cores_per_link = 7

# Even here, all parameters besides 'route_method' will be the same as s1, the main thread
[s3]
route_method = shortest_path
